[{"mnemonic": "LDNT1D (scalar plus scalar)", "short_desc": "Contiguous load non-temporal doublewords to vector (scalar index)", "full_desc": "Contiguous load non-temporal of doublewords to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 8 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNT1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(64) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = X[m];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "ZIP1", "short_desc": "Zip vectors (primary)", "full_desc": "Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.", "syntax": ["ZIP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger base = part * pairs;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\n\nV[d] = result;"}, {"mnemonic": "FMLAL, FMLAL2 (vector)", "short_desc": "Floating-point fused Multiply-Add Long to accumulator (vector)", "full_desc": "Floating-point fused Multiply-Add Long to accumulator (vector). This instruction multiplies corresponding half-precision floating-point values in the vectors in the two source SIMD&FP registers, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.", "syntax": ["FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; FMLAL", "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; FMLAL2"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz == '1' then UNDEFINED;\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (S == '1');\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize DIV 2) operand1 = Vpart[n,part];\nbits(datasize DIV 2) operand2 = Vpart[m,part];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize DIV 2) element1;\nbits(esize DIV 2) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize DIV 2];\n    element2 = Elem[operand2, e, esize DIV 2];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result,e,esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "TSB CSYNC", "short_desc": "Trace Synchronization Barrier", "full_desc": "Trace Synchronization Barrier. This instruction is a barrier that synchronizes the trace operations of instructions.", "syntax": ["TSB CSYNC\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "UMOV", "short_desc": "Unsigned Move vector element to general-purpose register", "full_desc": "Unsigned Move vector element to general-purpose register. This instruction reads the unsigned integer from the source SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register.", "syntax": ["UMOV  <Wd>, <Vn>.<Ts>[<index>]\t; 32-bit", "UMOV  <Xd>, <Vn>.<Ts>[<index>]\t; 64-reg,UMOV-64-reg"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ts>\n", "<Ts>\n", "<index>\n", "<index>\nFor the 64-reg,UMOV-64-reg variant: is the element index encoded in \"imm5<4>\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size;\ncase Q:imm5 of\n    when '0xxxx1' size = 0;     // UMOV Wd, Vn.B\n    when '0xxx10' size = 1;     // UMOV Wd, Vn.H\n    when '0xx100' size = 2;     // UMOV Wd, Vn.S\n    when '1x1000' size = 3;     // UMOV Xd, Vn.D\n    otherwise     UNDEFINED;\n\ninteger idxdsize = if imm5<4> == '1' then 128 else 64;\ninteger index = UInt(imm5<4:size+1>);\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 64 else 32;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\n\nX[d] = ZeroExtend(Elem[operand, index, esize], datasize);"}, {"mnemonic": "FMIN (immediate)", "short_desc": "Floating-point minimum with immediate (predicated)", "full_desc": "Determine the minimum of an immediate and each active floating-point element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate may take the value +0.0 or +1.0 only. If the element value is NaN then the result is NaN. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\nbits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMin(element1, imm, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "LDURSB", "short_desc": "Load Register Signed Byte (unscaled)", "full_desc": "Load Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDURSB  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDURSB  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "FABS (vector)", "short_desc": "Floating-point Absolute value (vector)", "full_desc": "Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FABS  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FABS  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    if neg then\n        element = FPNeg(element);\n    else\n        element = FPAbs(element);\n    Elem[result, e, esize] = element;\n\nV[d] = result;"}, {"mnemonic": "CMEQ (zero)", "short_desc": "Compare bitwise Equal to zero (vector)", "full_desc": "Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMEQ  <V><d>, <V><n>, #0\t; Scalar", "CMEQ  <Vd>.<T>, <Vn>.<T>, #0\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "MRS", "short_desc": "Move System Register", "full_desc": "Move System Register allows the PE to read an AArch64 System register into a general-purpose register.", "syntax": ["MRS  <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)\t; System"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rt\" field.", "<systemreg>\nIs a System register name, encoded in the \"o0:op1:CRn:CRm:op2\".", "<op0>\n", "<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cn>\nIs a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<Cm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field."], "decode": "AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 2 + UInt(o0);\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean read = (L == '1');", "operation": "if read then\n    X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"}, {"mnemonic": "MOV (immediate, predicated, merging)", "short_desc": "Move signed integer immediate to vector elements (merging)", "full_desc": "Move a signed integer immediate to each active element in the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["MOV     <Zd>.<T>, <Pg>/M, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<imm>\nIs a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<shift>\n"]}, {"mnemonic": "RDFFR, RDFFRS (predicated)", "short_desc": "Return predicate of succesfully loaded elements", "full_desc": "Read the first-fault register () and place active elements in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["RDFFR   <Pd>.B, <Pg>/Z\t; Not setting the condition flags", "RDFFRS  <Pd>.B, <Pg>/Z\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger g = UInt(Pg);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\nbits(PL) mask = P[g];\nbits(PL) ffr = FFR[];\nbits(PL) result = ffr AND mask;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, 8);\nP[d] = result;"}, {"mnemonic": "USHR", "short_desc": "Unsigned Shift Right (immediate)", "full_desc": "Unsigned Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see .", "syntax": ["USHR  <V><d>, <V><n>, #<shift>\t; Scalar", "USHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FDIV (scalar)", "short_desc": "Floating-point Divide (scalar)", "full_desc": "Floating-point Divide (scalar). This instruction divides the floating-point value of the first source SIMD&FP register by the floating-point value of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.", "syntax": ["FDIV  <Hd>, <Hn>, <Hm>\t; Half-precision", "FDIV  <Sd>, <Sn>, <Sm>\t; Single-precision", "FDIV  <Dd>, <Dn>, <Dm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nresult = FPDiv(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "NGC", "short_desc": "Negate with Carry", "full_desc": "Negate with Carry negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register.", "syntax": ["NGC  <Wd>, <Wm>\t; 32-bit", "NGC  <Xd>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field."]}, {"mnemonic": "SM3PARTW2", "short_desc": "SM3PARTW2", "full_desc": "SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and returns a 128-bit result in the destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information.", "syntax": ["SM3PARTW2  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveSM3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) result; \nbits(128) tmp;\nbits(32) tmp2;\ntmp<127:0> = Vn EOR (ROL(Vm<127:96>,7):ROL(Vm<95:64>,7):ROL(Vm<63:32>,7):ROL(Vm<31:0>,7)); \nresult<127:0> = Vd<127:0> EOR tmp<127:0>;\ntmp2 = ROL(tmp<31:0>,15);\ntmp2 = tmp2 EOR ROL(tmp2,15) EOR ROL(tmp2,23);\nresult<127:96> = result<127:96> EOR tmp2;\nV[d]= result;"}, {"mnemonic": "LDADD, LDADDA, LDADDAL, LDADDL", "short_desc": "Atomic add on word or doubleword in memory", "full_desc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDADD  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDADD", "LDADDA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDADDA", "LDADDAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDADDAL", "LDADDL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDADDL", "LDADD  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDADD", "LDADDA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDADDA", "LDADDAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDADDAL", "LDADDL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDADDL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDRH (immediate)", "short_desc": "Load Register Halfword (immediate)", "full_desc": "Load Register Halfword (immediate) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see .", "syntax": ["LDRH  <Wt>, [<Xn|SP>], #<simm>\t; Post-index", "LDRH  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index", "LDRH  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nIs the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "STLLRB", "short_desc": "Store LORelease Register Byte", "full_desc": "Store LORelease Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["STLLRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UCVTF", "short_desc": "Unsigned integer convert to floating-point (predicated)", "full_desc": "Convert to floating-point from the unsigned integer in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["UCVTF   <Zd>.H, <Pg>/M, <Zn>.H\t; 16-bit to half-precision", "UCVTF   <Zd>.H, <Pg>/M, <Zn>.S\t; 32-bit to half-precision", "UCVTF   <Zd>.S, <Pg>/M, <Zn>.S\t; 32-bit to single-precision", "UCVTF   <Zd>.D, <Pg>/M, <Zn>.S\t; 32-bit to double-precision", "UCVTF   <Zd>.H, <Pg>/M, <Zn>.D\t; 64-bit to half-precision", "UCVTF   <Zd>.S, <Pg>/M, <Zn>.D\t; 64-bit to single-precision", "UCVTF   <Zd>.D, <Pg>/M, <Zn>.D\t; 64-bit to double-precision"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\ninteger s_esize = 16;\ninteger d_esize = 16;\nboolean unsigned = TRUE;\nFPRounding rounding = FPRoundingMode(FPCR<31:0>);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        bits(d_esize) fpval = FixedToFP(element<s_esize-1:0>, 0, unsigned, FPCR<31:0>, rounding);\n        Elem[result, e, esize] = ZeroExtend(fpval);\n\nZ[d] = result;"}, {"mnemonic": "STUR (SIMD&FP)", "short_desc": "Store SIMD&FP register (unscaled offset)", "full_desc": "Store SIMD&FP register (unscaled offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset.", "syntax": ["STUR  <Bt>, [<Xn|SP>{, #<simm>}]\t; 8-bit", "STUR  <Ht>, [<Xn|SP>{, #<simm>}]\t; 16-bit", "STUR  <St>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "STUR  <Dt>, [<Xn|SP>{, #<simm>}]\t; 64-bit", "STUR  <Qt>, [<Xn|SP>{, #<simm>}]\t; 128-bit"], "symbols": ["<Bt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Ht>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UNDEFINED;\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "BLRAA, BLRAAZ, BLRAB, BLRABZ", "short_desc": "Branch with Link to Register, with pointer authentication", "full_desc": "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by , using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4.", "syntax": ["BLRAAZ  <Xn>\t; Key A, zero modifier", "BLRAA  <Xn>, <Xm|SP>\t; Key A, register modifier", "BLRABZ  <Xn>\t; Key B, zero modifier", "BLRAB  <Xn>, <Xm|SP>\t; Key B, register modifier"], "symbols": ["<Xn>\nIs the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field.", "<Xm|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer holding the modifier, encoded in the \"Rm\" field."], "decode": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UNDEFINED;\nelsif pac && !HavePACExt() then \n    UNDEFINED;\n\ncase op of\n    when '00' branch_type = BranchType_INDIR;\n    when '01' branch_type = BranchType_INDCALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UNDEFINED;\n\nif pac then\n    if Z == '0' && m != 31 then\n        UNDEFINED;\n\n    if branch_type == BranchType_RET then\n        if n != 31 then UNDEFINED;\n        n = 30;\n        source_is_sp = TRUE;", "operation": "bits(64) target = X[n];\nboolean auth_then_branch = TRUE;\n\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier, auth_then_branch);\n    else\n        target = AuthIB(target, modifier, auth_then_branch);\n\nif branch_type == BranchType_INDCALL then X[30] = PC[] + 4;\n\n// Value in BTypeNext will be used to set PSTATE.BTYPE\ncase branch_type of\n    when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ\n        if InGuardedPage then\n            if n == 16 || n == 17 then\n                BTypeNext = '01';\n            else\n                BTypeNext = '11';\n        else\n            BTypeNext = '01';\n    when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ\n        BTypeNext = '10';\n    when BranchType_RET             // RET, RETAA, RETAB \n        BTypeNext = '00';\n\nBranchTo(target, branch_type);"}, {"mnemonic": "FRINTI (vector)", "short_desc": "Floating-point Round to Integral, using current rounding mode (vector)", "full_desc": "Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the , and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTI  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FRINTI  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "FADDP (vector)", "short_desc": "Floating-point Add Pairwise (vector)", "full_desc": "Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ASRR", "short_desc": "Reversed arithmetic shift right by vector (predicated)", "full_desc": "Reversed shift right, preserving the sign bit, active elements of the second source vector by corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. The shift amount operand is a vector of unsigned elements in which all bits are significant, and not used modulo the element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["ASRR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    integer shift = Min(UInt(element1), esize);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = ASR(element2, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "STRB (immediate)", "short_desc": "Store Register Byte (immediate)", "full_desc": "Store Register Byte (immediate) stores the least significant byte of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see .", "syntax": ["STRB  <Wt>, [<Xn|SP>], #<simm>\t; Post-index", "STRB  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index", "STRB  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nIs the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "FCVTZS", "short_desc": "Floating-point convert to signed integer, rounding toward zero (predicated)", "full_desc": "Convert to the signed integer nearer to zero from each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FCVTZS  <Zd>.H, <Pg>/M, <Zn>.H\t; Half-precision to 16-bit", "FCVTZS  <Zd>.S, <Pg>/M, <Zn>.H\t; Half-precision to 32-bit", "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.H\t; Half-precision to 64-bit", "FCVTZS  <Zd>.S, <Pg>/M, <Zn>.S\t; Single-precision to 32-bit", "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.S\t; Single-precision to 64-bit", "FCVTZS  <Zd>.S, <Pg>/M, <Zn>.D\t; Double-precision to 32-bit", "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.D\t; Double-precision to 64-bit"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\ninteger s_esize = 16;\ninteger d_esize = 16;\nboolean unsigned = FALSE;\nFPRounding rounding = FPRounding_ZERO;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        bits(d_esize) res = FPToFixed(element<s_esize-1:0>, 0, unsigned, FPCR<31:0>, rounding);\n        Elem[result, e, esize] = Extend(res, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "SQDECH (scalar)", "short_desc": "Signed saturating decrement scalar by multiple of 16-bit predicate constraint element count", "full_desc": "Determines the number of active 16-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQDECH  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "SQDECH  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "SHA1SU1", "short_desc": "SHA1 schedule update 1", "full_desc": "SHA1 schedule update 1.", "syntax": ["SHA1SU1  <Vd>.4S, <Vn>.4S\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HaveSHA1Ext() then UNDEFINED;", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand1 EOR LSR(operand2, 32);\nresult<31:0>   = ROL(T<31:0>,   1);\nresult<63:32>  = ROL(T<63:32>,  1);\nresult<95:64>  = ROL(T<95:64>,  1);\nresult<127:96> = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);\nV[d] = result;"}, {"mnemonic": "FAC<cc>", "short_desc": "Floating-point absolute compare vectors", "full_desc": "Compare active absolute values of floating-point elements in the first source vector with corresponding absolute values of elements in the second source vector, and place the boolean results of the specified comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Does not set the condition flags.", "syntax": ["FACGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than", "FACGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than or equal"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Pd);\nSVECmp op = Cmp_GT;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        case op of\n            when Cmp_GE res = FPCompareGE(FPAbs(element1), FPAbs(element2), FPCR<31:0>);\n            when Cmp_GT res = FPCompareGT(FPAbs(element1), FPAbs(element2), FPCR<31:0>);\n        ElemP[result, e, esize] = if res then '1' else '0';\n    else\n        ElemP[result, e, esize] = '0';\n\nP[d] = result;"}, {"mnemonic": "LDLAR", "short_desc": "Load LOAcquire Register", "full_desc": "Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["LDLAR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit", "LDLAR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SQADD", "short_desc": "Signed saturating Add", "full_desc": "Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SQADD  <V><d>, <V><n>, <V><m>\t; Scalar", "SQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "FMLS (indexed)", "short_desc": "Floating-point fused multiply-subtract by indexed elements (Zda = Zda + -Zn * Zm[indexed])", "full_desc": "Multiply all floating-point elements within each 128-bit segment of the first source vector by the specified element in the corresponding second source vector segment. The products are then destructively subtracted without intermediate rounding from the corresponding elements of the addend and destination vector.", "syntax": ["FMLS    <Zda>.H, <Zn>.H, <Zm>.H[<imm>]\t; Half-precision", "FMLS    <Zda>.S, <Zn>.S, <Zm>.S[<imm>]\t; Single-precision", "FMLS    <Zda>.D, <Zn>.D, <Zm>.D[<imm>]\t; Double-precision"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nFor the half-precision and single-precision variant: is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zm>\nFor the double-precision variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<imm>\nFor the half-precision variant: is the immediate index, in the range 0 to 7, encoded in the \"i3h:i3l\" fields.", "<imm>\nFor the single-precision variant: is the immediate index, in the range 0 to 3, encoded in the \"i2\" field.", "<imm>\nFor the double-precision variant: is the immediate index, in the range 0 to 1, encoded in the \"i1\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger index = UInt(i3h:i3l);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean op1_neg = TRUE;\nboolean op3_neg = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger eltspersegment = 128 DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result = Z[da];\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = segmentbase + index;\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, s, esize];\n    bits(esize) element3 = Elem[result, e, esize];\n    if op1_neg then element1 = FPNeg(element1);\n    if op3_neg then element3 = FPNeg(element3);\n    Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n\nZ[da] = result;"}, {"mnemonic": "LDFF1D (scalar plus vector)", "short_desc": "Gather load first-fault doublewords to vector (vector index)", "full_desc": "Gather load with first-faulting behavior of doublewords to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 8. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]\t; 32-bit unpacked scaled offset", "LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]\t; 64-bit scaled offset", "LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\ninteger offs_size = 32;\nboolean unsigned = TRUE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "LD4H (scalar plus scalar)", "short_desc": "Contiguous load four-halfword structures to four vectors (scalar index)", "full_desc": "Contiguous load four-halfword structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by four. The index register is not updated by the instruction.", "syntax": ["LD4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "EXT", "short_desc": "Extract vector from pair of vectors", "full_desc": "Copy the indexed byte up to the last byte of the first source vector to the bottom of the result vector, then fill the remainder of the result starting from the first byte of the second source vector. The result is placed destructively in the first source vector. This instruction is unpredicated.", "syntax": ["EXT     <Zdn>.B, <Zdn>.B, <Zm>.B, #<imm>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<imm>\nIs the unsigned immediate operand, in the range 0 to 255, encoded in the \"imm8h:imm8l\" fields."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\ninteger position = UInt(imm8h:imm8l);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nif position >= elements then\n    position = 0;\n\nposition = position << 3;\nbits(VL*2) concat = operand2 : operand1;\nresult = concat<position+VL-1:position>;\n\nZ[dn] = result;"}, {"mnemonic": "MLA (vector)", "short_desc": "Multiply-Add to accumulator (vector)", "full_desc": "Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.", "syntax": ["MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n\nV[d] = result;"}, {"mnemonic": "SSUBL, SSUBL2", "short_desc": "Signed Subtract Long", "full_desc": "Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.", "syntax": ["SSUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LD3H (scalar plus immediate)", "short_desc": "Contiguous load three-halfword structures to three vectors (immediate index)", "full_desc": "Contiguous load three-halfword structures, each to the same element number in three vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 3 in the range -24 to 21 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "SQSHRUN, SQSHRUN2", "short_desc": "Signed saturating Shift Right Unsigned Narrow (immediate)", "full_desc": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see .", "syntax": ["SQSHRUN  <Vb><d>, <Va><n>, #<shift>\t; Scalar", "SQSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then UNDEFINED;\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "LD2 (single structure)", "short_desc": "Load single 2-element structure to one lane of two registers", "full_desc": "Load single 2-element structure to one lane of two registers. This instruction loads a 2-element structure from memory and writes the result to the corresponding elements of the two SIMD&FP registers without affecting the other bits of the registers.", "syntax": ["LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]\t; 8-bit", "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]\t; 16-bit", "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]\t; 32-bit", "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]\t; 64-bit", "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2\t; 8-bit, immediate offset", "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset", "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4\t; 16-bit, immediate offset", "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset", "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8\t; 32-bit, immediate offset", "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset", "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16\t; 64-bit, immediate offset", "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<index>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<index>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<index>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<index>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "BFMLALB (indexed)", "short_desc": "BFloat16 floating-point multiply-add long to single-precision (bottom, indexed)", "full_desc": "This BFloat16 floating-point multiply-add long instruction widens the even-numbered 16-bit BFloat16 elements in the first source vector and the indexed element from the corresponding 128-bit segment in the second source vector to single-precision format and then destructively multiplies and adds these values without intermediate rounding to the overlapping 32-bit single-precision elements of the addend and destination vector. This instruction is unpredicated.", "syntax": ["BFMLALB <Zda>.S, <Zn>.H, <Zm>.H[<imm>]\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<imm>\nIs the immediate index, in the range 0 to 7, encoded in the \"i3h:i3l\" fields."], "decode": "if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\ninteger index = UInt(i3h:i3l);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 32;\ninteger eltspersegment = 128 DIV 32;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = 2 * segmentbase + index;\n    bits(32) element1 = Elem[operand1, 2 * e + 0, 16] : Zeros(16);\n    bits(32) element2 = Elem[operand2, s, 16] : Zeros(16);\n    bits(32) element3 = Elem[operand3, e, 32];\n    Elem[result, e, 32] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n\nZ[da] = result;"}, {"mnemonic": "FNMUL (scalar)", "short_desc": "Floating-point Multiply-Negate (scalar)", "full_desc": "Floating-point Multiply-Negate (scalar). This instruction multiplies the floating-point values of the two source SIMD&FP registers, and writes the negation of the result to the destination SIMD&FP register.", "syntax": ["FNMUL  <Hd>, <Hn>, <Hm>\t; Half-precision", "FNMUL  <Sd>, <Sn>, <Sm>\t; Single-precision", "FNMUL  <Dd>, <Dn>, <Dm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean negated = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nresult = FPMul(operand1, operand2, FPCR);\n\nif negated then result = FPNeg(result);\n\nV[d] = result;"}, {"mnemonic": "CMPLO (vectors)", "short_desc": "Compare unsigned lower than vector, setting the condition flags", "full_desc": "Compare active unsigned integer elements in the first source vector being lower than corresponding unsigned elements in the second source vector, and place the boolean results of the comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["CMPLO   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Higher"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."]}, {"mnemonic": "FSCALE", "short_desc": "Floating-point adjust exponent by vector (predicated)", "full_desc": "Multiply the active floating-point elements of the first source vector by 2.0 to the power of the signed integer values in the corresponding elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FSCALE  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    integer element2 = SInt(Elem[operand2, e, esize]);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPScale(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "SEVL", "short_desc": "Send Event Local", "full_desc": "Send Event Local is a hint instruction that causes an event to be signaled locally without requiring the event to be signaled to other PEs in the multiprocessor system. It can prime a wait-loop which starts with a  instruction.", "syntax": ["SEVL\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "CPY (immediate, zeroing)", "short_desc": "Copy signed integer immediate to vector elements (zeroing)", "full_desc": "Copy a signed integer immediate to each active element in the destination vector. Inactive elements in the destination vector register are set to zero.", "syntax": ["CPY     <Zd>.<T>, <Pg>/Z, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<imm>\nIs a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger d = UInt(Zd);\nboolean merging = FALSE;\ninteger imm = SInt(imm8);\nif sh == '1' then imm = imm << 8;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) dest = Z[d];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = imm<esize-1:0>;\n    elsif merging then\n        Elem[result, e, esize] = Elem[dest, e, esize];\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[d] = result;"}, {"mnemonic": "ABS", "short_desc": "Absolute value (predicated)", "full_desc": "Compute the absolute value of the signed integer in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["ABS     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    integer element = SInt(Elem[operand, e, esize]);\n    if ElemP[mask, e, esize] == '1' then\n        element = Abs(element);\n        Elem[result, e, esize] = element<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "STLLR", "short_desc": "Store LORelease Register", "full_desc": "Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["STLLR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit", "STLLR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "BIC (immediate)", "short_desc": "Bitwise clear bits using immediate (unpredicated)", "full_desc": "Bitwise clear bits using immediate with each 64-bit element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is a 64-bit value consisting of a single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction is unpredicated.", "syntax": ["BIC     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<const>\nIs a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."]}, {"mnemonic": "UDOT (by element)", "short_desc": "Dot Product unsigned arithmetic (vector, by element)", "full_desc": "Dot Product unsigned arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<index>\nIs the element index, encoded in the \"H:L\" fields."], "decode": "if !HaveDOTPExt() then UNDEFINED;\nif size  != '10' then UNDEFINED;\nboolean signed = (U=='0');\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\ninteger index = UInt(H:L);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(datasize) result = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3\n        if signed then  \n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        res = res + element1 * element2; \n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nV[d] = result;"}, {"mnemonic": "SM3TT2B", "short_desc": "SM3TT2B", "full_desc": "SM3TT2B takes three 128-bit vectors from three source SIMD&FP registers, and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:", "syntax": ["SM3TT2B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field.", "<imm2>\nIs a 32-bit element indexed out of <Vm>, encoded in \"imm2\"."], "decode": "if !HaveSM3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger i = UInt(imm2);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) Wj;\nbits(128) result; \nbits(32) TT2;\n\nWj = Elem[Vm,i,32];\nTT2 = (Vd<127:96> AND Vd<95:64>) OR (NOT(Vd<127:96>) AND Vd<63:32>); \nTT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;\n\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,19); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); \nV[d] = result;"}, {"mnemonic": "FRSQRTE", "short_desc": "Floating-point Reciprocal Square Root Estimate", "full_desc": "Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FRSQRTE  <Hd>, <Hn>\t; Scalar half precision", "FRSQRTE  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FRSQRTE  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FRSQRTE  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SDOT (vector)", "short_desc": "Dot Product signed arithmetic (vector)", "full_desc": "Dot Product signed arithmetic (vector). This instruction performs the dot product of the four signed 8-bit elements in each 32-bit element of the first source register with the four signed 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveDOTPExt() then UNDEFINED;\nif size!= '10' then UNDEFINED;\nboolean signed = (U=='0');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nresult = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3 \n        if signed then\n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        res = res + element1 * element2; \n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nV[d] = result;"}, {"mnemonic": "LD1RQD (scalar plus immediate)", "short_desc": "Contiguous load and replicate two doublewords (immediate index)", "full_desc": "Load two contiguous doublewords to elements of a short, 128-bit (quadword) vector from the memory address generated by a 64-bit scalar base address and immediate index that is a multiple of 16 in the range -128 to +112 added to the base address.", "syntax": ["LD1RQD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate byte offset, a multiple of 16 in the range -128 to 112, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = 128 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low 16 bits only\nbits(128) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * 16;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = Replicate(result, VL DIV 128);"}, {"mnemonic": "LDAPUR", "short_desc": "Load-Acquire RCpc Register (unscaled)", "full_desc": "Load-Acquire RCpc Register (unscaled) calculates an address from a base register and an immediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register.", "syntax": ["LDAPUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDAPUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_ORDERED;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "FMIN (scalar)", "short_desc": "Floating-point Minimum (scalar)", "full_desc": "Floating-point Minimum (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the smaller of the two floating-point values to the destination SIMD&FP register.", "syntax": ["FMIN  <Hd>, <Hn>, <Hm>\t; Half-precision", "FMIN  <Sd>, <Sn>, <Sm>\t; Single-precision", "FMIN  <Dd>, <Dn>, <Dm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "LD1ROH (scalar plus immediate)", "short_desc": "Contiguous load and replicate sixteen halfwords (immediate index)", "full_desc": "Load sixteen contiguous halfwords to elements of a 256-bit (octaword) vector from the memory address generated by a 64-bit scalar base address and immediate index that is a multiple of 32 in the range -256 to +224 added to the base address.", "syntax": ["LD1ROH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate byte offset, a multiple of 32 in the range -256 to 224, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVEFP64MatMulExt() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\nif VL < 256 then UNDEFINED;\ninteger elements = 256 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low bits only\nbits(256) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * 32;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);"}, {"mnemonic": "CLZ (vector)", "short_desc": "Count Leading Zero bits (vector)", "full_desc": "Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["CLZ  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    if countop == CountOp_CLS then\n        count = CountLeadingSignBits(Elem[operand, e, esize]);\n    else\n        count = CountLeadingZeroBits(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;"}, {"mnemonic": "PRFM (register)", "short_desc": "Prefetch Memory (register)", "full_desc": "Prefetch Memory (register) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.", "syntax": ["PRFM  (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; Integer"], "symbols": ["<prfop>\nIs the prefetch operation, defined as .", "<imm5>\nIs the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\n"], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "B.cond", "short_desc": "Branch conditionally", "full_desc": "Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.", "syntax": ["B.<cond>  <label>\t; 19-bit signed PC-relative branch offset"], "symbols": ["<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<label>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "bits(64) offset = SignExtend(imm19:'00', 64);\nbits(4) condition = cond;", "operation": "if ConditionHolds(condition) then\n    BranchTo(PC[] + offset, BranchType_DIR);"}, {"mnemonic": "SQRSHRN, SQRSHRN2", "short_desc": "Signed saturating Rounded Shift Right Narrow (immediate)", "full_desc": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see .", "syntax": ["SQRSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar", "SQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then UNDEFINED;\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "UQSUB (immediate)", "short_desc": "Unsigned saturating subtract immediate (unpredicated)", "full_desc": "Unsigned saturating subtract an unsigned immediate from each element of the source vector, and destructively place the results in the corresponding elements of the source vector. Each result element is saturated to the N-bit element's unsigned integer range 0 to (2)-1. This instruction is unpredicated.", "syntax": ["UQSUB   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger imm = UInt(imm8);\nif sh == '1' then imm = imm << 8;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - imm, esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "LDAPURB", "short_desc": "Load-Acquire RCpc Register Byte (unscaled)", "full_desc": "Load-Acquire RCpc Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register.", "syntax": ["LDAPURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_ORDERED;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "PRFUM", "short_desc": "Prefetch Memory (unscaled offset)", "full_desc": "Prefetch Memory (unscaled offset) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.", "syntax": ["PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<prfop>\nIs the prefetch operation, defined as .", "<imm5>\nIs the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "MLS", "short_desc": "Multiply-subtract vectors (predicated), writing addend [Zda = Zda - Zn * Zm]", "full_desc": "Multiply the corresponding active elements of the first and second source vectors and subtract from elements of the third source (addend) vector. Destructively place the results in the destination and third source (addend) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["MLS     <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean sub_op = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = UInt(Elem[operand1, e, esize]);\n    integer element2 = UInt(Elem[operand2, e, esize]);\n    if ElemP[mask, e, esize] == '1' then\n        integer product = element1 * element2;\n        if sub_op then\n            Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n        else\n            Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize];\n\nZ[da] = result;"}, {"mnemonic": "LSRV", "short_desc": "Logical Shift Right Variable", "full_desc": "Logical Shift Right Variable shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["LSRV  <Wd>, <Wn>, <Wm>\t; 32-bit", "LSRV  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);", "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"}, {"mnemonic": "LSL (register)", "short_desc": "Logical Shift Left (register)", "full_desc": "Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted.", "syntax": ["LSL  <Wd>, <Wn>, <Wm>\t; 32-bit", "LSL  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."]}, {"mnemonic": "ADD (shifted register)", "short_desc": "Add (shifted register)", "full_desc": "Add (shifted register) adds a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ADD  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "ADD  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then UNDEFINED;\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "FACGE", "short_desc": "Floating-point Absolute Compare Greater than or Equal (vector)", "full_desc": "Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FACGE  <Hd>, <Hn>, <Hm>\t; Scalar half precision", "FACGE  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision", "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision", "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FCMEQ (register)", "short_desc": "Floating-point Compare Equal (vector)", "full_desc": "Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FCMEQ  <Hd>, <Hn>, <Hm>\t; Scalar half precision", "FCMEQ  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision", "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision", "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "SMC", "short_desc": "Secure Monitor Call", "full_desc": "Secure Monitor Call causes an exception to EL3.", "syntax": ["SMC  #<imm>\t; System"], "symbols": ["<imm>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "bits(16) imm = imm16;", "operation": "AArch64.CheckForSMCUndefOrTrap(imm);\n\nif SCR_EL3.SMD == '1' then\n    // SMC disabled\n    UNDEFINED;\nelse\n    AArch64.CallSecureMonitor(imm);"}, {"mnemonic": "SSHLL, SSHLL2", "short_desc": "Signed Shift Left Long (immediate)", "full_desc": "Signed Shift Left Long (immediate). This instruction reads each vector element from the source SIMD&FP register, left shifts each vector element by the specified shift amount, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.", "syntax": ["SSHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(datasize*2) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FCMLA (by element)", "short_desc": "Floating-point Complex Multiply Accumulate (by element)", "full_desc": "Floating-point Complex Multiply Accumulate (by element).", "syntax": ["FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>\t; ", "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>\t; "], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<Ts>\n", "<index>\n", "<rotate>\n"], "decode": "if !HaveFCADDExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\nif size == '00' || size == '11' then UNDEFINED;\nif size == '01' then index = UInt(H:L);\nif size == '10' then index = UInt(H);\ninteger esize = 8 << UInt(size);\nif !HaveFP16Ext() && esize == 16 then UNDEFINED;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nif size == '10' && (L == '1' || Q == '0') then UNDEFINED; \nif size == '01' && H == '1' && Q=='0' then UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '00'\n            element1 = Elem[operand2, index*2, esize]; \n            element2 = Elem[operand1, e*2, esize];\n            element3 = Elem[operand2, index*2+1, esize];\n            element4 = Elem[operand1, e*2, esize];\n        when '01'\n            element1 = FPNeg(Elem[operand2, index*2+1, esize]); \n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = Elem[operand2, index*2, esize];\n            element4 = Elem[operand1, e*2+1, esize];\n        when '10'\n            element1 = FPNeg(Elem[operand2, index*2,esize]); \n            element2 = Elem[operand1, e*2, esize];\n            element3 = FPNeg(Elem[operand2, index*2+1, esize]);\n            element4 = Elem[operand1, e*2, esize];\n        when '11'\n            element1 = Elem[operand2, index*2+1, esize]; \n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = FPNeg(Elem[operand2, index*2, esize]);\n            element4 = Elem[operand1, e*2+1, esize];\n\n    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, FPCR);\n    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);\n\nV[d] = result;"}, {"mnemonic": "UDIVR", "short_desc": "Unsigned reversed divide (predicated)", "full_desc": "Unsigned reversed divide active elements of the second source vector by corresponding elements of the first source vector and destructively place the quotient in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["UDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '0x' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer quotient;\n        if element1 == 0 then\n            quotient = 0;\n        else\n            quotient = RoundTowardsZero(Real(element2) / Real(element1));\n        Elem[result, e, esize] = quotient<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "FCVTXN, FCVTXN2", "short_desc": "Floating-point Convert to lower precision Narrow, rounding to odd (vector)", "full_desc": "Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FCVTXN  <Vb><d>, <Va><n>\t; Scalar", "FCVTXN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '0' then UNDEFINED;\ninteger esize = 32;\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, FPRounding_ODD);\n\nVpart[d, part] = result;"}, {"mnemonic": "ASR (wide elements, unpredicated)", "short_desc": "Arithmetic shift right by 64-bit wide elements (unpredicated)", "full_desc": "Shift right, preserving the sign bit, all elements of the first source vector by corresponding overlapping 64-bit elements of the second source vector and place the first in the corresponding elements of the destination vector. The shift amount is a vector of unsigned 64-bit doubleword elements in which all bits are significant, and not used modulo the destination element size. This instruction is unpredicated.", "syntax": ["ASR     <Zd>.<T>, <Zn>.<T>, <Zm>.D\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];\n    integer shift = Min(UInt(element2), esize);\n    Elem[result, e, esize] = ASR(element1, shift);\n\nZ[d] = result;"}, {"mnemonic": "UMIN (vectors)", "short_desc": "Unsigned minimum vectors (predicated)", "full_desc": "Determine the unsigned minimum of active elements of the second source vector and corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["UMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer minimum = Min(element1, element2);\n        Elem[result, e, esize] = minimum<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "ST2W (scalar plus scalar)", "short_desc": "Contiguous store two-word structures from two vectors (scalar index)", "full_desc": "Contiguous store two-word structures, each from the same element number in two vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by two. The index register is not updated by the instruction.", "syntax": ["ST2W    { <Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB", "short_desc": "Atomic unsigned minimum on byte in memory", "full_desc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDUMINAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINAB", "LDUMINALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINALB", "LDUMINB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINB", "LDUMINLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "ADR", "short_desc": "Form PC-relative address", "full_desc": "Form PC-relative address adds an immediate value to the PC value to form a PC-relative address, and writes the result to the destination register.", "syntax": ["ADR  <Xd>, <label>\t; Literal"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<label>\nIs the program label whose address is to be calculated. Its offset from the address of this instruction, in the range +/-1MB, is encoded in \"immhi:immlo\"."], "decode": "integer d = UInt(Rd);\nboolean page = (op == '1');\nbits(64) imm;\n\nif page then\n    imm = SignExtend(immhi:immlo:Zeros(12), 64);\nelse\n    imm = SignExtend(immhi:immlo, 64);", "operation": "bits(64) base = PC[];\n\nif page then\n    base<11:0> = Zeros(12);\n\nX[d] = base + imm;"}, {"mnemonic": "TRN2", "short_desc": "Transpose vectors (secondary)", "full_desc": "Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.", "syntax": ["TRN2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\n\nV[d] = result;"}, {"mnemonic": "LD2D (scalar plus immediate)", "short_desc": "Contiguous load two-doubleword structures to two vectors (immediate index)", "full_desc": "Contiguous load two-doubleword structures, each to the same element number in two vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 2 in the range -16 to 14 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD2D    { <Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "MOV (wide immediate)", "short_desc": "Move (wide immediate)", "full_desc": "Move (wide immediate) moves a 16-bit immediate value to a register.", "syntax": ["MOV  <Wd>, #<imm>\t; 32-bit", "MOV  <Xd>, #<imm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<imm>\nFor the 32-bit variant: is a 32-bit immediate which can be encoded in \"imm16:hw\".", "<imm>\nFor the 64-bit variant: is a 64-bit immediate which can be encoded in \"imm16:hw\".", "<shift>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<shift>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."]}, {"mnemonic": "UQDECW (vector)", "short_desc": "Unsigned saturating decrement vector by multiple of 32-bit predicate constraint element count", "full_desc": "Determines the number of active 32-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement all destination vector elements. The results are saturated to the 32-bit unsigned integer range.", "syntax": ["UQDECW  <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "CNT", "short_desc": "Population Count per byte", "full_desc": "Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["CNT  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '00' then UNDEFINED;\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    count = BitCount(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;"}, {"mnemonic": "INDEX (immediates)", "short_desc": "Create index starting from and incremented by immediate", "full_desc": "Populates the destination vector by setting the first element to the first signed immediate integer operand and monotonically incrementing the value by the second signed immediate integer operand for each subsequent element. This instruction is unpredicated.", "syntax": ["INDEX   <Zd>.<T>, #<imm1>, #<imm2>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<imm1>\nIs the first signed immediate operand, in the range -16 to 15, encoded in the \"imm5\" field.", "<imm2>\nIs the second signed immediate operand, in the range -16 to 15, encoded in the \"imm5b\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger d = UInt(Zd);\ninteger imm1 = SInt(imm5);\ninteger imm2 = SInt(imm5b);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer index = imm1 + e * imm2;\n    Elem[result, e, esize] = index<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "EOR (vectors, predicated)", "short_desc": "Bitwise exclusive OR vectors (predicated)", "full_desc": "Bitwise exclusive OR active elements of the second source vector with corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["EOR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = element1 EOR element2;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "LDARH", "short_desc": "Load-Acquire Register Halfword", "full_desc": "Load-Acquire Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["LDARH  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UQXTN, UQXTN2", "short_desc": "Unsigned saturating extract Narrow", "full_desc": "Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.", "syntax": ["UQXTN  <Vb><d>, <Va><n>\t; Scalar", "UQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "UHSUB", "short_desc": "Unsigned Halving Subtract", "full_desc": "Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    Elem[result, e, esize] = diff<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "XPACD, XPACI, XPACLRI", "short_desc": "Strip Pointer Authentication Code", "full_desc": "Strip Pointer Authentication Code. This instruction removes the pointer authentication code from an address. The address is in the specified general-purpose register for  and , and is in LR for .", "syntax": ["XPACD  <Xd>\t; XPACD", "XPACI  <Xd>\t; XPACI", "XPACLRI\t; System"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."], "decode": "boolean data = (D == '1');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif n != 31 then UNDEFINED;", "operation": "if HavePACExt() then\n    X[d] = Strip(X[d], data);"}, {"mnemonic": "FSQRT", "short_desc": "Floating-point square root (predicated)", "full_desc": "Calculate the square root of each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FSQRT   <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPSqrt(element, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "UZP1, UZP2 (vectors)", "short_desc": "Concatenate even or odd elements from two vectors", "full_desc": "Concatenate adjacent even or odd-numbered elements from the first and second source vectors and place in elements of the destination vector. This instruction is unpredicated. The 128-bit element variant of this instruction requires that the current vector length is at least 256 bits, and if the current vector length is not an integer multiple of 256 bits then the trailing bits are set to zero.", "syntax": ["UZP1    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Even", "UZP1    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Even (quadwords)", "UZP2    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Odd", "UZP2    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Odd (quadwords)"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);\ninteger part = 0;", "operation": "CheckSVEEnabled();\nif VL < esize * 2 then UNDEFINED;\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result = Zeros();\n\nbits(VL*2) zipped = operand2:operand1;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\n\nZ[d] = result;"}, {"mnemonic": "STNT1H (scalar plus immediate)", "short_desc": "Contiguous store non-temporal halfwords from vector (immediate index)", "full_desc": "Contiguous store non-temporal of halfwords from elements of a vector register to the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements are not written to memory.", "syntax": ["STNT1H  { <Zt>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nconstant integer mbytes = esize DIV 8;\nbits(VL) src;\nbits(PL) mask = P[g];\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\nsrc = Z[t];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];\n    addr = addr + mbytes;"}, {"mnemonic": "LDGM", "short_desc": "Load Tag Multiple", "full_desc": "Load Tag Multiple reads a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID_EL1.BS, and writes the Allocation Tag read from address A to the destination register at 4*A<7:4>+3:4*A<7:4>. Bits of the destination register not written with an Allocation Tag are set to 0.", "syntax": ["LDGM  <Xt>, [<Xn|SP>]\t; Integer"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger t = UInt(Xt);\ninteger n = UInt(Xn);", "operation": "if PSTATE.EL == EL0 then\n    UNDEFINED;\n\nbits(64) data = Zeros(64);\nbits(64) address;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ninteger size = 4*(2^(UInt(GMID_EL1.BS)));\naddress = Align(address,size);\ninteger count = size >> LOG2_TAG_GRANULE;\ninteger index = UInt(address<LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE>);\n\nfor i = 0 to count-1\n    bits(4) tag = AArch64.MemTag[address, AccType_NORMAL];\n    data<(index*4)+3:index*4> = tag;\n    address = address + TAG_GRANULE;\n    index = index + 1;\n\nX[t] = data;"}, {"mnemonic": "LD1RQW (scalar plus immediate)", "short_desc": "Contiguous load and replicate four words (immediate index)", "full_desc": "Load four contiguous words to elements of a short, 128-bit (quadword) vector from the memory address generated by a 64-bit scalar base address and immediate index that is a multiple of 16 in the range -128 to +112 added to the base address.", "syntax": ["LD1RQW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate byte offset, a multiple of 16 in the range -128 to 112, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = 128 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low 16 bits only\nbits(128) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * 16;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = Replicate(result, VL DIV 128);"}, {"mnemonic": "STZGM", "short_desc": "Store Tag and Zero Multiple", "full_desc": "Store Tag and Zero Multiple writes a naturally aligned block of N Allocation Tags and stores zero to the associated data locations, where the size of N is identified in DCZID_EL0.BS, and the Allocation Tag written to address A is taken from the source register bits<3:0>.", "syntax": ["STZGM  <Xt>, [<Xn|SP>]\t; Integer"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger t = UInt(Xt);\ninteger n = UInt(Xn);", "operation": "if PSTATE.EL == EL0 then\n    UNDEFINED;\n\nbits(64) data = X[t];\nbits(4) tag = data<3:0>;\nbits(64) address;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ninteger size = 4*(2^(UInt(DCZID_EL0.BS)));\naddress = Align(address,size);\ninteger count = size >> LOG2_TAG_GRANULE;\n\nfor i = 0 to count-1\n    AArch64.MemTag[address, AccType_NORMAL] = tag;\n    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);\n    address = address + TAG_GRANULE;"}, {"mnemonic": "FCM<cc> (zero)", "short_desc": "Floating-point compare vector with zero", "full_desc": "Compare active floating-point elements in the source vector with zero, and place the boolean results of the specified comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Does not set the condition flags.", "syntax": ["FCMEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Equal", "FCMGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Greater than", "FCMGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Greater than or equal", "FCMLT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Less than", "FCMLE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Less than or equal", "FCMNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0\t; Not equal"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Pd);\nSVECmp op = Cmp_EQ;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        case op of\n            when Cmp_EQ res = FPCompareEQ(element, 0<esize-1:0>, FPCR<31:0>);\n            when Cmp_GE res = FPCompareGE(element, 0<esize-1:0>, FPCR<31:0>);\n            when Cmp_GT res = FPCompareGT(element, 0<esize-1:0>, FPCR<31:0>);\n            when Cmp_NE res = FPCompareNE(element, 0<esize-1:0>, FPCR<31:0>);\n            when Cmp_LT res = FPCompareGT(0<esize-1:0>, element, FPCR<31:0>);\n            when Cmp_LE res = FPCompareGE(0<esize-1:0>, element, FPCR<31:0>);\n        ElemP[result, e, esize] = if res then '1' else '0';\n    else\n        ElemP[result, e, esize] = '0';\n\nP[d] = result;"}, {"mnemonic": "LDFF1B (vector plus immediate)", "short_desc": "Gather load first-fault unsigned bytes to vector (immediate index)", "full_desc": "Gather load with first-faulting behavior of unsigned bytes to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is in the range 0 to 31. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1B  { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LDFF1B  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 8;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "URECPE", "short_desc": "Unsigned Reciprocal Estimate", "full_desc": "Unsigned Reciprocal Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse for the unsigned integer value, places the result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["URECPE  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '1' then UNDEFINED;\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRecipEstimate(element);\n\nV[d] = result;"}, {"mnemonic": "LDFF1B (scalar plus scalar)", "short_desc": "Contiguous load first-fault unsigned bytes to vector (scalar index)", "full_desc": "Contiguous load with first-faulting behavior of unsigned bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDFF1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 8-bit element", "LDFF1B  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 16-bit element", "LDFF1B  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 32-bit element", "LDFF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger msize = 8;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + UInt(offset) * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "LDXRH", "short_desc": "Load Exclusive Register Halfword", "full_desc": "Load Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See . For information about memory accesses see .", "syntax": ["LDXRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SHA1M", "short_desc": "SHA1 hash update (majority)", "full_desc": "SHA1 hash update (majority).", "syntax": ["SHA1M  <Qd>, <Sn>, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif !HaveSHA1Ext() then UNDEFINED;", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;"}, {"mnemonic": "SYS", "short_desc": "System instruction", "full_desc": "System instruction. For more information, see  for the encodings of System instructions.", "syntax": ["SYS  #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}\t; System"], "symbols": ["<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cn>\nIs a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<Cm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Xt>\nIs the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the \"Rt\" field."], "decode": "AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 1;\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean has_result = (L == '1');", "operation": "if has_result then\n    // No architecturally defined instructions here.\n    X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"}, {"mnemonic": "REV (predicate)", "short_desc": "Reverse all elements in a predicate", "full_desc": "Reverse the order of all elements in the source predicate and place in the destination predicate. This instruction is unpredicated.", "syntax": ["REV     <Pd>.<T>, <Pn>.<T>\t; SVE"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pn>\nIs the name of the source scalable predicate register, encoded in the \"Pn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Pn);\ninteger d = UInt(Pd);", "operation": "CheckSVEEnabled();\nbits(PL) operand = P[n];\nbits(PL) result = Reverse(operand, esize DIV 8);\nP[d] = result;"}, {"mnemonic": "SPLICE", "short_desc": "Splice two vectors under predicate control", "full_desc": "Copy the first active to last active elements (inclusive) from the first source vector to the lowest-numbered elements of the result. Then set any remaining elements of the result to a copy of the lowest-numbered elements from the second source vector. The result is placed destructively in the first source vector.", "syntax": ["SPLICE  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\ninteger x = 0;\nboolean active = FALSE;\ninteger lastnum = LastActiveElement(mask, esize);\n\nif lastnum >= 0 then\n    for e = 0 to lastnum\n        active = active || ElemP[mask, e, esize] == '1';\n        if active then\n            Elem[result, x, esize] = Elem[operand1, e, esize];\n            x = x + 1;\n\nelements = elements - x - 1;\nfor e = 0 to elements\n    Elem[result, x, esize] = Elem[operand2, e, esize];\n    x = x + 1;\n\nZ[dn] = result;"}, {"mnemonic": "UBFIZ", "short_desc": "Unsigned Bitfield Insert in Zero", "full_desc": "Unsigned Bitfield Insert in Zeros copies a bitfield of  bits from the least significant bits of the source register to bit position  of the destination register, setting the destination bits above and below the bitfield to zero.", "syntax": ["UBFIZ  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit", "UBFIZ  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<lsb>\nFor the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.", "<lsb>\nFor the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<width>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<width>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "CNT", "short_desc": "Count non-zero bits (predicated)", "full_desc": "Count non-zero bits in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["CNT     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = BitCount(element)<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "SQDECB", "short_desc": "Signed saturating decrement scalar by multiple of 8-bit predicate constraint element count", "full_desc": "Determines the number of active 8-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQDECB  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "SQDECB  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "UQINCD (vector)", "short_desc": "Unsigned saturating increment vector by multiple of 64-bit predicate constraint element count", "full_desc": "Determines the number of active 64-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment all destination vector elements. The results are saturated to the 64-bit unsigned integer range.", "syntax": ["UQINCD  <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "PRFH (scalar plus vector)", "short_desc": "Gather prefetch halfwords (scalar plus vector)", "full_desc": "Gather prefetch of halfwords from the active memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then multiplied by 2. Inactive addresses are not prefetched from memory.", "syntax": ["PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset", "PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset", "PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger offs_size = 32;\nboolean offs_unsigned = (xs == '0');\ninteger scale = 1;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);"}, {"mnemonic": "FRSQRTS", "short_desc": "Floating-point Reciprocal Square Root Step", "full_desc": "Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FRSQRTS  <Hd>, <Hn>, <Hm>\t; Scalar half precision", "FRSQRTS  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision", "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision", "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);\n\nV[d] = result;"}, {"mnemonic": "LDFF1SW (scalar plus vector)", "short_desc": "Gather load first-fault signed words to vector (vector index)", "full_desc": "Gather load with first-faulting behavior of signed words to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 4. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset", "LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset", "LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 32;\ninteger offs_size = 32;\nboolean unsigned = FALSE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "ORR (vector, immediate)", "short_desc": "Bitwise inclusive OR (vector, immediate)", "full_desc": "Bitwise inclusive OR (vector, immediate). This instruction reads each vector element from the destination SIMD&FP register, performs a bitwise OR between each result and an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit", "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit"], "symbols": ["<Vd>\nIs the name of the SIMD&FP register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<imm8>\nIs an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\".", "<amount>\n", "<amount>\n"], "decode": "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UNDEFINED;\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"}, {"mnemonic": "ST1H (scalar plus vector)", "short_desc": "Scatter store halfwords from a vector (vector index)", "full_desc": "Scatter store of halfwords from the active elements of a vector register to the memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 2. Inactive elements are not written to memory.", "syntax": ["ST1H    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "ST1H    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\ninteger offs_size = 32;\nboolean offs_unsigned = xs == '0';\ninteger scale = 1;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(VL) offset = Z[m];\nbits(VL) src = Z[t];\nbits(PL) mask = P[g];\nbits(64) addr;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;"}, {"mnemonic": "ST2D (scalar plus scalar)", "short_desc": "Contiguous store two-doubleword structures from two vectors (scalar index)", "full_desc": "Contiguous store two-doubleword structures, each from the same element number in two vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by two. The index register is not updated by the instruction.", "syntax": ["ST2D    { <Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "SMULH", "short_desc": "Signed multiply returning high half (predicated)", "full_desc": "Widening multiply signed integer values in active elements of the first source vector by corresponding elements of the second source vector and destructively place the high half of the result in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SMULH   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer product = (element1 * element2) >> esize;\n        Elem[result, e, esize] = product<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "LD2W (scalar plus immediate)", "short_desc": "Contiguous load two-word structures to two vectors (immediate index)", "full_desc": "Contiguous load two-word structures, each to the same element number in two vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 2 in the range -16 to 14 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD2W    { <Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "BIC (vectors, predicated)", "short_desc": "Bitwise clear vectors (predicated)", "full_desc": "Bitwise AND inverted active elements of the second source vector with corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["BIC     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = element1 AND (NOT element2);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "FRINTX (scalar)", "short_desc": "Floating-point Round to Integral exact, using current rounding mode (scalar)", "full_desc": "Floating-point Round to Integral exact, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the , and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTX  <Hd>, <Hn>\t; Half-precision", "FRINTX  <Sd>, <Sn>\t; Single-precision", "FRINTX  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "NEGS", "short_desc": "Negate, setting flags", "full_desc": "Negate, setting flags, negates an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["NEGS  <Wd>, <Wm>{, <shift> #<amount>}\t; 32-bit", "NEGS  <Xd>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."]}, {"mnemonic": "CMP<cc> (immediate)", "short_desc": "Compare vector to immediate", "full_desc": "Compare active integer elements in the source vector with an immediate, and place the boolean results of the specified comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["CMPEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Equal", "CMPGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Greater than", "CMPGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Greater than or equal", "CMPHI   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Higher", "CMPHS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Higher or same", "CMPLT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Less than", "CMPLE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Less than or equal", "CMPLO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Lower", "CMPLS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Lower or same", "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>\t; Not equal"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<imm>\nFor the equal, greater than, greater than or equal, less than, less than or equal and not equal variant: is the signed immediate operand, in the range -16 to 15, encoded in the \"imm5\" field.", "<imm>\nFor the higher, higher or same, lower and lower or same variant: is the unsigned immediate operand, in the range 0 to 127, encoded in the \"imm7\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Pd);\nSVECmp op = Cmp_EQ;\ninteger imm = SInt(imm5);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        boolean cond;\n        case op of\n            when Cmp_EQ cond = element1 == imm;\n            when Cmp_NE cond = element1 != imm;\n            when Cmp_GE cond = element1 >= imm;\n            when Cmp_LT cond = element1 <  imm;\n            when Cmp_GT cond = element1 >  imm;\n            when Cmp_LE cond = element1 <= imm;\n        ElemP[result, e, esize] = if cond then '1' else '0';\n    else\n        ElemP[result, e, esize] = '0';\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "ASRD", "short_desc": "Arithmetic shift right for divide by immediate (predicated)", "full_desc": "Shift right by immediate, preserving the sign bit, each active element of the source vector, and destructively place the results in the corresponding elements of the source vector. The result rounds toward zero as in a signed division. The immediate shift amount is an unsigned value in the range 1 to number of bits per element. Inactive elements in the destination vector register remain unmodified.", "syntax": ["ASRD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\nIs the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\"."], "decode": "if !HaveSVE() then UNDEFINED;\nbits(4) tsize = tszh:tszl;\ncase tsize of\n    when '0000' UNDEFINED;\n    when '0001' esize = 8;\n    when '001x' esize = 16;\n    when '01xx' esize = 32;\n    when '1xxx' esize = 64;\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger shift = (2 * esize) - UInt(tsize:imm3);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = SInt(Elem[operand1, e, esize]);\n    if ElemP[mask, e, esize] == '1' then\n        if element1 < 0 then\n            element1 = element1 + ((1 << shift) - 1);\n        Elem[result, e, esize] = (element1 >> shift)<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "LD1RSB", "short_desc": "Load and broadcast signed byte to vector", "full_desc": "Load a single signed byte from a memory address generated by a 64-bit scalar base address plus an immediate offset which is in the range 0 to 63.", "syntax": ["LD1RSB  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 16-bit element", "LD1RSB  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element", "LD1RSB  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, in the range 0 to 63, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 8;\nboolean unsigned = FALSE;\ninteger offset = UInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\ninteger last = LastActiveElement(mask, esize);\nif last >= 0 then\n    addr = base + offset * mbytes;\n    data = Mem[addr, mbytes, AccType_NORMAL];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "MUL (by element)", "short_desc": "Multiply (vector, by element)", "full_desc": "Multiply (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.", "syntax": ["MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\n\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;"}, {"mnemonic": "FCVTPU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTPU  <Hd>, <Hn>\t; Scalar half precision", "FCVTPU  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTPU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTPU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "SETF8, SETF16", "short_desc": "Evaluation of 8 or 16 bit flag values", "full_desc": "Set the PSTATE.NZV flags based on the value in the specified general-purpose register.  treats the value as an 8 bit value, and  treats the value as an 16 bit value.", "syntax": ["SETF8  <Wn>\t; SETF8", "SETF16  <Wn>\t; SETF16"], "symbols": ["<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "if !HaveFlagManipulateExt() || sf != '0' then UNDEFINED;\ninteger msb = if sz=='1' then 15 else 7;\ninteger n = UInt(Rn);", "operation": "bits(32) tmpreg = X[n];\nPSTATE.N = tmpreg<msb>;\nPSTATE.Z = if (tmpreg<msb:0> == Zeros(msb+1)) then '1' else '0';\nPSTATE.V = tmpreg<msb+1> EOR tmpreg<msb>;\n//PSTATE.C unchanged;"}, {"mnemonic": "UQDECP (scalar)", "short_desc": "Unsigned saturating decrement scalar by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to decrement the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQDECP  <Wdn>, <Pm>.<T>\t; 32-bit", "UQDECP  <Xdn>, <Pm>.<T>\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Rdn);\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(ssize) operand1 = X[dn];\nbits(PL) operand2 = P[m];\nbits(ssize) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\ninteger element = Int(operand1, unsigned);\n(result, -) = SatQ(element - count, ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "LD1RB", "short_desc": "Load and broadcast unsigned byte to vector", "full_desc": "Load a single unsigned byte from a memory address generated by a 64-bit scalar base address plus an immediate offset which is in the range 0 to 63.", "syntax": ["LD1RB   { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 8-bit element", "LD1RB   { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 16-bit element", "LD1RB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element", "LD1RB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, in the range 0 to 63, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger msize = 8;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\ninteger last = LastActiveElement(mask, esize);\nif last >= 0 then\n    addr = base + offset * mbytes;\n    data = Mem[addr, mbytes, AccType_NORMAL];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "SADDLV", "short_desc": "Signed Add Long across Vector", "full_desc": "Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values.", "syntax": ["SADDLV  <V><d>, <Vn>.<T>\t; Advanced SIMD"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger sum;\n\nsum = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    sum = sum + Int(Elem[operand, e, esize], unsigned);\n\nV[d] = sum<2*esize-1:0>;"}, {"mnemonic": "LDFF1SB (scalar plus scalar)", "short_desc": "Contiguous load first-fault signed bytes to vector (scalar index)", "full_desc": "Contiguous load with first-faulting behavior of signed bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDFF1SB { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 16-bit element", "LDFF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 32-bit element", "LDFF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 8;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + UInt(offset) * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "LDFF1SB (vector plus immediate)", "short_desc": "Gather load first-fault signed bytes to vector (immediate index)", "full_desc": "Gather load with first-faulting behavior of signed bytes to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is in the range 0 to 31. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1SB { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LDFF1SB { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 8;\nboolean unsigned = FALSE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "LSR (wide elements, unpredicated)", "short_desc": "Logical shift right by 64-bit wide elements (unpredicated)", "full_desc": "Shift right, inserting zeroes, all elements of the first source vector by corresponding overlapping 64-bit elements of the second source vector and place the first in the corresponding elements of the destination vector. The shift amount is a vector of unsigned 64-bit doubleword elements in which all bits are significant, and not used modulo the destination element size. This instruction is unpredicated.", "syntax": ["LSR     <Zd>.<T>, <Zn>.<T>, <Zm>.D\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];\n    integer shift = Min(UInt(element2), esize);\n    Elem[result, e, esize] = LSR(element1, shift);\n\nZ[d] = result;"}, {"mnemonic": "STUMINB, STUMINLB", "short_desc": "Atomic unsigned minimum on byte in memory, without return", "full_desc": "Atomic unsigned minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.", "syntax": ["STUMINB  <Ws>, [<Xn|SP>]\t; No memory ordering", "STUMINLB  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "CLS (vector)", "short_desc": "Count Leading Sign bits (vector)", "full_desc": "Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.", "syntax": ["CLS  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    if countop == CountOp_CLS then\n        count = CountLeadingSignBits(Elem[operand, e, esize]);\n    else\n        count = CountLeadingZeroBits(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;"}, {"mnemonic": "UMSUBL", "short_desc": "Unsigned Multiply-Subtract Long", "full_desc": "Unsigned Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["UMSUBL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xa>\nIs the 64-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"}, {"mnemonic": "BTI", "short_desc": "Branch Target Identification", "full_desc": "Branch Target Identification. A  instruction is used to guard against the execution of instructions which are not the intended target of a branch.", "syntax": ["BTI  {<targets>}\t; System"], "symbols": ["<targets>\n"], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "LDNT1W (scalar plus scalar)", "short_desc": "Contiguous load non-temporal words to vector (scalar index)", "full_desc": "Contiguous load non-temporal of words to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 4 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNT1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(64) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = X[m];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "CASB, CASAB, CASALB, CASLB", "short_desc": "Compare and Swap byte in memory", "full_desc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.", "syntax": ["CASAB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASAB", "CASALB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASALB", "CASB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASB", "CASLB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\ncomparevalue = X[s];\nnewvalue = X[t];\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);\n\nX[s] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDSETH, LDSETAH, LDSETALH, LDSETLH", "short_desc": "Atomic bit set on halfword in memory", "full_desc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDSETAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETAH", "LDSETALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETALH", "LDSETH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETH", "LDSETLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SQSUB (vectors)", "short_desc": "Signed saturating subtract vectors (unpredicated)", "full_desc": "Signed saturating subtract all elements of the second source vector from corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. Each result element is saturated to the N-bit element's signed integer range -2 to (2)-1. This instruction is unpredicated.", "syntax": ["SQSUB   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - element2, esize, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "UMLAL, UMLAL2 (vector)", "short_desc": "Unsigned Multiply-Add Long (vector)", "full_desc": "Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"}, {"mnemonic": "AESD", "short_desc": "AES single round decryption", "full_desc": "AES single round decryption.", "syntax": ["AESD  <Vd>.16B, <Vn>.16B\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HaveAESExt() then UNDEFINED;\nboolean decrypt = (D == '1');", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nresult = operand1 EOR operand2;\nif decrypt then\n    result = AESInvSubBytes(AESInvShiftRows(result));\nelse\n    result = AESSubBytes(AESShiftRows(result));\n\nV[d] = result;"}, {"mnemonic": "STRH (register)", "short_desc": "Store Register Halfword (register)", "full_desc": "Store Register Halfword (register) calculates an address from a base register value and an offset register value, and stores a halfword from a 32-bit register to the calculated address. For information about memory accesses, see .", "syntax": ["STRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\n"], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "REV (vector)", "short_desc": "Reverse all elements in a vector (unpredicated)", "full_desc": "Reverse the order of all elements in the source vector and place in the destination vector. This instruction is unpredicated.", "syntax": ["REV     <Zd>.<T>, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\nbits(VL) operand = Z[n];\nbits(VL) result = Reverse(operand, esize);\nZ[d] = result;"}, {"mnemonic": "EOR (shifted register)", "short_desc": "Bitwise Exclusive OR (shifted register)", "full_desc": "Bitwise Exclusive OR (shifted register) performs a bitwise Exclusive OR of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "MOV (scalar, unpredicated)", "short_desc": "Move general-purpose register to vector elements (unpredicated)", "full_desc": "Unconditionally broadcast the general-purpose scalar source register into each element of the destination vector. This instruction is unpredicated.", "syntax": ["MOV     <Zd>.<T>, <R><n|SP>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<R>\n", "<n|SP>\nIs the number [0-30] of the general-purpose source register or the name SP (31), encoded in the \"Rn\" field."]}, {"mnemonic": "ST4H (scalar plus immediate)", "short_desc": "Contiguous store four-halfword structures from four vectors (immediate index)", "full_desc": "Contiguous store four-halfword structures, each from the same element number in four vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 4 in the range -32 to 28 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "LDFF1W (scalar plus vector)", "short_desc": "Gather load first-fault unsigned words to vector (vector index)", "full_desc": "Gather load with first-faulting behavior of unsigned words to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 4. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]\t; 32-bit scaled offset", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\ninteger offs_size = 32;\nboolean unsigned = TRUE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "UMMLA", "short_desc": "Unsigned integer matrix multiply-accumulate", "full_desc": "The unsigned integer matrix multiply-accumulate instruction multiplies the 2\u00d78 matrix of unsigned 8-bit integer values held in each 128-bit segment of the first source vector by the 8\u00d72 matrix of unsigned 8-bit integer values in the corresponding segment of the second source vector. The resulting 2\u00d72 widened 32-bit integer matrix product is then destructively added to the 32-bit integer matrix accumulator held in the corresponding segment of the addend and destination vector. This is equivalent to performing an 8-way dot product per destination element.", "syntax": ["UMMLA   <Zda>.S, <Zn>.B, <Zm>.B\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean op1_unsigned = TRUE;\nboolean op2_unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger segments = VL DIV 128;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result = Zeros();\nbits(128) op1, op2;\nbits(128) res, addend;\n\nfor s = 0 to segments-1\n    op1    = Elem[operand1, s, 128];\n    op2    = Elem[operand2, s, 128];\n    addend = Elem[operand3, s, 128];\n    res    = MatMulAdd(addend, op1, op2, op1_unsigned, op2_unsigned);\n    Elem[result, s, 128] = res;\n\nZ[da] = result;"}, {"mnemonic": "ST3H (scalar plus scalar)", "short_desc": "Contiguous store three-halfword structures from three vectors (scalar index)", "full_desc": "Contiguous store three-halfword structures, each from the same element number in three vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by three. The index register is not updated by the instruction.", "syntax": ["ST3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "RSUBHN, RSUBHN2", "short_desc": "Rounding Subtract returning High Narrow", "full_desc": "Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.", "syntax": ["RSUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"}, {"mnemonic": "LDRB (register)", "short_desc": "Load Register Byte (register)", "full_desc": "Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; Extended register", "LDRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; Shifted register"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\nIs the index shift amount, it must be , encoded in \"S\" as  if omitted, or as  if present."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "FABS (scalar)", "short_desc": "Floating-point Absolute value (scalar)", "full_desc": "Floating-point Absolute value (scalar). This instruction calculates the absolute value in the SIMD&FP source register and writes the result to the SIMD&FP destination register.", "syntax": ["FABS  <Hd>, <Hn>\t; Half-precision", "FABS  <Sd>, <Sn>\t; Single-precision", "FABS  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"}, {"mnemonic": "STLURB", "short_desc": "Store-Release Register Byte (unscaled)", "full_desc": "Store-Release Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register.", "syntax": ["STLURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_ORDERED;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "STTRB", "short_desc": "Store Register Byte (unprivileged)", "full_desc": "Store Register Byte (unprivileged) stores a byte from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset.", "syntax": ["STTRB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\n\nunpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');\nunpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';\n\nuser_access_override = HaveUAOExt() && PSTATE.UAO == '1';\nif !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then\n    acctype = AccType_UNPRIV;\nelse\n    acctype = AccType_NORMAL;\n\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "DECP (scalar)", "short_desc": "Decrement scalar by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to decrement the scalar destination.", "syntax": ["DECP    <Xdn>, <Pm>.<T>\t; SVE"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Rdn);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) operand1 = X[dn];\nbits(PL) operand2 = P[m];\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\nX[dn] = operand1 - count;"}, {"mnemonic": "LDURSW", "short_desc": "Load Register Signed Word (unscaled)", "full_desc": "Load Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDURSW  <Xt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "BIC (shifted register)", "short_desc": "Bitwise Bit Clear (shifted register)", "full_desc": "Bitwise Bit Clear (shifted register) performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["BIC  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "BIC  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "UADALP", "short_desc": "Unsigned Add and Accumulate Long Pairwise", "full_desc": "Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.", "syntax": ["UADALP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nif acc then result = V[d];\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    if acc then\n        Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n    else\n        Elem[result, e, 2*esize] = sum;\n\nV[d] = result;"}, {"mnemonic": "RDFFR (unpredicated)", "short_desc": "Read the first-fault register", "full_desc": "Read the first-fault register () and place in the destination predicate without predication.", "syntax": ["RDFFR   <Pd>.B\t; SVE"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger d = UInt(Pd);", "operation": "CheckSVEEnabled();\nbits(PL) ffr = FFR[];\nP[d] = ffr;"}, {"mnemonic": "EXTR", "short_desc": "Extract register", "full_desc": "Extract register extracts a register from a pair of registers.", "syntax": ["EXTR  <Wd>, <Wn>, <Wm>, #<lsb>\t; 32-bit", "EXTR  <Xd>, <Xn>, <Xm>, #<lsb>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<lsb>\nFor the 32-bit variant: is the least significant bit position from which to extract, in the range 0 to 31, encoded in the \"imms\" field.", "<lsb>\nFor the 64-bit variant: is the least significant bit position from which to extract, in the range 0 to 63, encoded in the \"imms\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\ninteger lsb;\n\nif N != sf then UNDEFINED;\nif sf == '0' && imms<5> == '1' then UNDEFINED;\nlsb = UInt(imms);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(2*datasize) concat = operand1:operand2;\n\nresult = concat<lsb+datasize-1:lsb>;\n\nX[d] = result;"}, {"mnemonic": "LD1 (multiple structures)", "short_desc": "Load multiple single-element structures to one, two, three, or four registers", "full_desc": "Load multiple single-element structures to one, two, three, or four registers. This instruction loads multiple single-element structures from memory and writes the result to one, two, three, or four SIMD&FP registers.", "syntax": ["LD1  { <Vt>.<T> }, [<Xn|SP>]\t; One register", "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; Two registers", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; Three registers", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; Four registers", "LD1  { <Vt>.<T> }, [<Xn|SP>], <imm>\t; One register, immediate offset", "LD1  { <Vt>.<T> }, [<Xn|SP>], <Xm>\t; One register, register offset", "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Two registers, immediate offset", "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Two registers, register offset", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Three registers, immediate offset", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Three registers, register offset", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Four registers, immediate offset", "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Four registers, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Vt4>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<imm>\n", "<imm>\n", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UNDEFINED;\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then UNDEFINED;"}, {"mnemonic": "STZ2G", "short_desc": "Store Allocation Tags, Zeroing", "full_desc": "Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of memory, zeroing the associated data locations. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.", "syntax": ["STZ2G  <Xt|SP>, [<Xn|SP>], #<simm>\t; Post-index", "STZ2G  <Xt|SP>, [<Xn|SP>, #<simm>]!\t; Pre-index", "STZ2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]\t; Signed offset"], "symbols": ["<Xt|SP>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<simm>\nIs the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger n = UInt(Xn);\ninteger t = UInt(Xt);\nbits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);\nboolean writeback = TRUE;\nboolean postindex = TRUE;\nboolean zero_data = TRUE;", "operation": "bits(64) address;\nbits(64) data = if t == 31 then SP[] else X[t];\nbits(4) tag = AArch64.AllocationTagFromAddress(data);\n\nSetTagCheckedInstruction(FALSE);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif !postindex then\n    address = address + offset;\n\nif zero_data then\n    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);\n    Mem[address+TAG_GRANULE, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);\n\nAArch64.MemTag[address, AccType_NORMAL] = tag;\nAArch64.MemTag[address+TAG_GRANULE, AccType_NORMAL] = tag;\n\nif writeback then\n    if postindex then\n        address = address + offset;\n\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "FRINTM (scalar)", "short_desc": "Floating-point Round to Integral, toward Minus infinity (scalar)", "full_desc": "Floating-point Round to Integral, toward Minus infinity (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTM  <Hd>, <Hn>\t; Half-precision", "FRINTM  <Sd>, <Sn>\t; Single-precision", "FRINTM  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "MOV (inverted wide immediate)", "short_desc": "Move (inverted wide immediate)", "full_desc": "Move (inverted wide immediate) moves an inverted 16-bit immediate value to a register.", "syntax": ["MOV  <Wd>, #<imm>\t; 32-bit", "MOV  <Xd>, #<imm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<imm>\nFor the 32-bit variant: is a 32-bit immediate, the bitwise inverse of which can be encoded in \"imm16:hw\", but excluding 0xffff0000 and 0x0000ffff", "<imm>\nFor the 64-bit variant: is a 64-bit immediate, the bitwise inverse of which can be encoded in \"imm16:hw\".", "<shift>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<shift>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."]}, {"mnemonic": "STZG", "short_desc": "Store Allocation Tag, Zeroing", "full_desc": "Store Allocation Tag, Zeroing stores an Allocation Tag to memory, zeroing the associated data location. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.", "syntax": ["STZG  <Xt|SP>, [<Xn|SP>], #<simm>\t; Post-index", "STZG  <Xt|SP>, [<Xn|SP>, #<simm>]!\t; Pre-index", "STZG  <Xt|SP>, [<Xn|SP>{, #<simm>}]\t; Signed offset"], "symbols": ["<Xt|SP>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<simm>\nIs the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger n = UInt(Xn);\ninteger t = UInt(Xt);\nbits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);\nboolean writeback = TRUE;\nboolean postindex = TRUE;\nboolean zero_data = TRUE;", "operation": "bits(64) address;\n\nSetTagCheckedInstruction(FALSE);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif !postindex then\n    address = address + offset;\n\nif zero_data then\n    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(TAG_GRANULE * 8);\n\nbits(64) data = if t == 31 then SP[] else X[t];\nbits(4) tag = AArch64.AllocationTagFromAddress(data);\nAArch64.MemTag[address, AccType_NORMAL] = tag;\n\nif writeback then\n    if postindex then\n        address = address + offset;\n\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "SQDMULH (by element)", "short_desc": "Signed saturating Doubling Multiply returning High half (by element)", "full_desc": "Signed saturating Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SQDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar", "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    // The following only saturates if element1 and element2 equal -(2^(esize-1))\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "XAFLAG", "short_desc": "Convert floating-point condition flags from external format to Arm format", "full_desc": "Convert floating-point condition flags from external format to Arm format. This instruction converts the state of the PSTATE.{N,Z,C,V} flags from an alternative representation required by some software to a form representing the result of an Arm floating-point scalar compare instruction.", "syntax": ["XAFLAG\t; System"], "symbols": [], "decode": "if !HaveFlagFormatExt() then UNDEFINED;", "operation": "bit N = NOT(PSTATE.C) AND NOT(PSTATE.Z);\nbit Z = PSTATE.Z AND PSTATE.C;\nbit C = PSTATE.C OR PSTATE.Z;\nbit V = NOT(PSTATE.C) AND PSTATE.Z;\n\nPSTATE.N = N;\nPSTATE.Z = Z;\nPSTATE.C = C;\nPSTATE.V = V;"}, {"mnemonic": "SQINCD (scalar)", "short_desc": "Signed saturating increment scalar by multiple of 64-bit predicate constraint element count", "full_desc": "Determines the number of active 64-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQINCD  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "SQINCD  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "LSL (wide elements, unpredicated)", "short_desc": "Logical shift left by 64-bit wide elements (unpredicated)", "full_desc": "Shift left all elements of the first source vector by corresponding overlapping 64-bit elements of the second source vector and place the first in the corresponding elements of the destination vector. The shift amount is a vector of unsigned 64-bit doubleword elements in which all bits are significant, and not used modulo the destination element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["LSL     <Zd>.<T>, <Zn>.<T>, <Zm>.D\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];\n    integer shift = Min(UInt(element2), esize);\n    Elem[result, e, esize] = LSL(element1, shift);\n\nZ[d] = result;"}, {"mnemonic": "BL", "short_desc": "Branch with Link", "full_desc": "Branch with Link branches to a PC-relative offset, setting the register X30 to PC+4. It provides a hint that this is a subroutine call.", "syntax": ["BL  <label>\t; 26-bit signed PC-relative branch offset"], "symbols": ["<label>\nIs the program label to be unconditionally branched to. Its offset from the address of this instruction, in the range +/-128MB, is encoded as \"imm26\" times 4."], "decode": "BranchType branch_type = if op == '1' then BranchType_DIRCALL else BranchType_DIR;\nbits(64) offset = SignExtend(imm26:'00', 64);", "operation": "if branch_type == BranchType_DIRCALL then X[30] = PC[] + 4;\n\nBranchTo(PC[] + offset, branch_type);"}, {"mnemonic": "CRC32CB, CRC32CH, CRC32CW, CRC32CX", "short_desc": "CRC32C checksum", "full_desc": "checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial  is used for the CRC calculation.", "syntax": ["CRC32CB  <Wd>, <Wn>, <Wm>\t; CRC32CB", "CRC32CH  <Wd>, <Wn>, <Wm>\t; CRC32CH", "CRC32CW  <Wd>, <Wn>, <Wm>\t; CRC32CW", "CRC32CX  <Wd>, <Wn>, <Xm>\t; CRC32CX"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose accumulator output register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose accumulator input register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose data source register, encoded in the \"Rm\" field.", "<Wm>\nIs the 32-bit name of the general-purpose data source register, encoded in the \"Rm\" field."], "decode": "if !HaveCRCExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sf == '1' && sz != '11' then UNDEFINED;\nif sf == '0' && sz == '11' then UNDEFINED;\ninteger size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64\nboolean crc32c = (C == '1');", "operation": "bits(32)      acc     = X[n];   // accumulator\nbits(size)    val     = X[m];   // input value\nbits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\n\nbits(32+size) tempacc = BitReverse(acc) : Zeros(size);\nbits(size+32) tempval = BitReverse(val) : Zeros(32);\n\n// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation\nX[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"}, {"mnemonic": "SMLAL, SMLAL2 (vector)", "short_desc": "Signed Multiply-Add Long (vector)", "full_desc": "Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"}, {"mnemonic": "SHL", "short_desc": "Shift Left (immediate)", "full_desc": "Shift Left (immediate). This instruction reads each value from a vector, left shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SHL  <V><d>, <V><n>, #<shift>\t; Scalar", "SHL  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);\n\nV[d] = result;"}, {"mnemonic": "LDRSW (register)", "short_desc": "Load Register Signed Word (register)", "full_desc": "Load Register Signed Word (register) calculates an address from a base register value and an offset register value, loads a word from memory, sign-extends it to form a 64-bit value, and writes it to a register. The offset register value can be shifted left by 0 or 2 bits. For information about memory accesses, see .", "syntax": ["LDRSW  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\n"], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "FTMAD", "short_desc": "Floating-point trigonometric multiply-add coefficient", "full_desc": "The  instruction calculates the series terms for either  or , where the argument  has been adjusted to be in the range -\u03c0/4 <  \u2264 \u03c0/4.", "syntax": ["FTMAD   <Zdn>.<T>, <Zdn>.<T>, <Zm>.<T>, #<imm>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<imm>\nIs the unsigned immediate operand, in the range 0 to 7, encoded in the \"imm3\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\ninteger imm = UInt(imm3);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPTrigMAdd(imm, element1, element2, FPCR<31:0>);\n\nZ[dn] = result;"}, {"mnemonic": "LDNP (SIMD&FP)", "short_desc": "Load Pair of SIMD&FP registers, with Non-temporal hint", "full_desc": "Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads a pair of SIMD&FP registers from memory, issuing a hint to the memory system that the access is non-temporal. The address that is used for the load is calculated from a base register value and an optional immediate offset.", "syntax": ["LDNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit", "LDNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit", "LDNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit"], "symbols": ["<Dt1>\nIs the 64-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt2>\nIs the 64-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Qt1>\nIs the 128-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt2>\nIs the 128-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<St1>\nIs the 32-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St2>\nIs the 32-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8.", "<imm>\nFor the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as <imm>/16."], "decode": "boolean wback  = FALSE;\nboolean postindex = FALSE;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VECSTREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UNDEFINED;\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\nboolean tag_checked = wback || n != 31;"}, {"mnemonic": "SRSHR", "short_desc": "Signed Rounding Shift Right (immediate)", "full_desc": "Signed Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see .", "syntax": ["SRSHR  <V><d>, <V><n>, #<shift>\t; Scalar", "SRSHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "DECB, DECD, DECH, DECW (scalar)", "short_desc": "Decrement scalar by multiple of predicate constraint element count", "full_desc": "Determines the number of active elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement the scalar destination.", "syntax": ["DECB    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Byte", "DECD    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Doubleword", "DECH    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Halfword", "DECW    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Word"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(64) operand1 = X[dn];\n\nX[dn] = operand1 - (count * imm);"}, {"mnemonic": "LD1RQB (scalar plus scalar)", "short_desc": "Contiguous load and replicate sixteen bytes (scalar index)", "full_desc": "Load sixteen contiguous bytes to elements of a short, 128-bit (quadword) vector from the memory address generated by a 64-bit scalar base address and scalar index which is added to the base address.", "syntax": ["LD1RQB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;", "operation": "CheckSVEEnabled();\ninteger elements = 128 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low 16 bits only\nbits(64) offset;\nbits(128) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = X[m];\n\naddr = base + UInt(offset) * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = Replicate(result, VL DIV 128);"}, {"mnemonic": "LDNF1SW", "short_desc": "Contiguous load non-fault signed words to vector (immediate index)", "full_desc": "Contiguous load with non-faulting behavior of signed words to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 32;\nboolean unsigned = FALSE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif n == 31 then\n    if ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        // MemNF[] will return fault=TRUE if access is not performed for any reason\n        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "LDR (predicate)", "short_desc": "Load predicate register", "full_desc": "Load a predicate register from a memory address generated by a 64-bit scalar base, plus an immediate offset in the range -256 to 255 which is multiplied by the current predicate register size in bytes. This instruction is unpredicated.", "syntax": ["LDR     <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Pt>\nIs the name of the destination scalable predicate register, encoded in the \"Pt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -256 to 255, defaulting to 0, encoded in the \"imm9h:imm9l\" fields."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Pt);\ninteger n = UInt(Rn);\ninteger imm = SInt(imm9h:imm9l);", "operation": "CheckSVEEnabled();\ninteger elements = PL DIV 8;\nbits(64) base;\ninteger offset = imm * elements;\nbits(PL) result;\n\nif n == 31 then\n    CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nboolean aligned = AArch64.CheckAlignment(base + offset, 2, AccType_NORMAL, FALSE);\nfor e = 0 to elements-1\n    Elem[result, e, 8] = AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned];\n    offset = offset + 1;\n\nP[t] = result;"}, {"mnemonic": "MOV (vector, predicated)", "short_desc": "Move vector elements (predicated)", "full_desc": "Move elements from the source vector to the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["MOV     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field."]}, {"mnemonic": "LDUMIN, LDUMINA, LDUMINAL, LDUMINL", "short_desc": "Atomic unsigned minimum on word or doubleword in memory", "full_desc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDUMIN  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMIN", "LDUMINA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMINA", "LDUMINAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMINAL", "LDUMINL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMINL", "LDUMIN  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMIN", "LDUMINA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMINA", "LDUMINAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMINAL", "LDUMINL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMINL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STUMAXB, STUMAXLB", "short_desc": "Atomic unsigned maximum on byte in memory, without return", "full_desc": "Atomic unsigned maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.", "syntax": ["STUMAXB  <Ws>, [<Xn|SP>]\t; No memory ordering", "STUMAXLB  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "LDAPURSB", "short_desc": "Load-Acquire RCpc Register Signed Byte (unscaled)", "full_desc": "Load-Acquire RCpc Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register.", "syntax": ["LDAPURSB  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDAPURSB  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_ORDERED;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "ADDHN, ADDHN2", "short_desc": "Add returning High Narrow", "full_desc": "Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.", "syntax": ["ADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"}, {"mnemonic": "STLXP", "short_desc": "Store-Release Exclusive Pair of registers", "full_desc": "Store-Release Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords to a memory location if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See . A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. The instruction also has memory ordering semantics as described in . For information about memory accesses see .", "syntax": ["STLXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit", "STLXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SQSUB (immediate)", "short_desc": "Signed saturating subtract immediate (unpredicated)", "full_desc": "Signed saturating subtract of an unsigned immediate from each element of the source vector, and destructively place the results in the corresponding elements of the source vector. Each result element is saturated to the N-bit element's signed integer range -2 to (2)-1. This instruction is unpredicated.", "syntax": ["SQSUB   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger imm = UInt(imm8);\nif sh == '1' then imm = imm << 8;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - imm, esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "SDIVR", "short_desc": "Signed reversed divide (predicated)", "full_desc": "Signed reversed divide active elements of the second source vector by corresponding elements of the first source vector and destructively place the quotient in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '0x' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer quotient;\n        if element1 == 0 then\n            quotient = 0;\n        else\n            quotient = RoundTowardsZero(Real(element2) / Real(element1));\n        Elem[result, e, esize] = quotient<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "ISB", "short_desc": "Instruction Synchronization Barrier", "full_desc": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a context synchronization event. For more information, see .", "syntax": ["ISB  {<option>|#<imm>}\t; System"], "symbols": ["<option>\nSpecifies an optional limitation on the barrier operation. Values are:", "<imm>\nIs an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the \"CRm\" field."], "decode": "// No additional decoding required", "operation": "InstructionSynchronizationBarrier();"}, {"mnemonic": "SWPB, SWPAB, SWPALB, SWPLB", "short_desc": "Swap byte in memory", "full_desc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.", "syntax": ["SWPAB  <Ws>, <Wt>, [<Xn|SP>]\t; SWPAB", "SWPALB  <Ws>, <Wt>, [<Xn|SP>]\t; SWPALB", "SWPB  <Ws>, <Wt>, [<Xn|SP>]\t; SWPB", "SWPLB  <Ws>, <Wt>, [<Xn|SP>]\t; SWPLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nbits(datasize) store_value;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nstore_value = X[s];\ndata = MemAtomic(address, MemAtomicOp_SWP, store_value, ldacctype, stacctype);\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDPSW", "short_desc": "Load Pair of Registers Signed Word", "full_desc": "Load Pair of Registers Signed Word calculates an address from a base register value and an immediate offset, loads two 32-bit words from memory, sign-extends them, and writes them to two registers. For information about memory accesses, see .", "syntax": ["LDPSW  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; Post-index", "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; Pre-index", "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; Signed offset"], "symbols": ["<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nFor the post-index and pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_NORMAL;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif L:opc<0> == '01' || opc == '11' then UNDEFINED;\nboolean signed = (opc<0> != '0');\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\nboolean tag_checked = wback || n != 31;"}, {"mnemonic": "SHA1H", "short_desc": "SHA1 fixed rotate", "full_desc": "SHA1 fixed rotate.", "syntax": ["SHA1H  <Sd>, <Sn>\t; Advanced SIMD"], "symbols": ["<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HaveSHA1Ext() then UNDEFINED;", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(32) operand = V[n];        // read element [0] only,  [1-3] zeroed\nV[d] = ROL(operand, 30);"}, {"mnemonic": "LD2B (scalar plus scalar)", "short_desc": "Contiguous load two-byte structures to two vectors (scalar index)", "full_desc": "Contiguous load two-byte structures, each to the same element number in two vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register and added to the base address. After each structure access the index value is incremented by two. The index register is not updated by the instruction.", "syntax": ["LD2B    { <Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "LDRSB (register)", "short_desc": "Load Register Signed Byte (register)", "full_desc": "Load Register Signed Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDRSB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 32-bit with extended register offset", "LDRSB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 32-bit with shifted register offset", "LDRSB  <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 64-bit with extended register offset", "LDRSB  <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 64-bit with shifted register offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\nIs the index shift amount, it must be , encoded in \"S\" as  if omitted, or as  if present."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "FSUB (vectors, unpredicated)", "short_desc": "Floating-point subtract vectors (unpredicated)", "full_desc": "Subtract all floating-point elements of the second source vector from corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["FSUB    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPSub(element1, element2, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "FMULX", "short_desc": "Floating-point multiply-extended vectors (predicated)", "full_desc": "Multiply active floating-point elements of the first source vector by corresponding floating-point elements of the second source vector except that \u221e\u00d70.0 gives 2.0 instead of NaN, and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMULX   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMulX(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "LASTA (scalar)", "short_desc": "Extract element after last to general-purpose register", "full_desc": "If there is an active element then extract the element after the last active element modulo the number of elements from the final source vector register. If there are no active elements, extract element zero. Then zero-extend and place the extracted element in the destination general-purpose register.", "syntax": ["LASTA   <R><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<R>\n", "<d>\nIs the number [0-30] of the destination general-purpose register or the name ZR (31), encoded in the \"Rd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger rsize = if esize < 64 then 32 else 64;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Rd);\nboolean isBefore = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(rsize) result;\ninteger last = LastActiveElement(mask, esize);\n\nif isBefore then\n    if last < 0 then last = elements - 1;\nelse\n    last = last + 1;\n    if last >= elements then last = 0;\nresult = ZeroExtend(Elem[operand, last, esize]);\n\nX[d] = result;"}, {"mnemonic": "SMOV", "short_desc": "Signed Move vector element to general-purpose register", "full_desc": "Signed Move vector element to general-purpose register. This instruction reads the signed integer from the source SIMD&FP register, sign-extends it to form a 32-bit or 64-bit value, and writes the result to destination general-purpose register.", "syntax": ["SMOV  <Wd>, <Vn>.<Ts>[<index>]\t; 32-bit", "SMOV  <Xd>, <Vn>.<Ts>[<index>]\t; 64-reg,SMOV-64-reg"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ts>\n", "<Ts>\n", "<index>\n", "<index>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size;\ncase Q:imm5 of\n    when 'xxxxx1' size = 0;     // SMOV [WX]d, Vn.B\n    when 'xxxx10' size = 1;     // SMOV [WX]d, Vn.H\n    when '1xx100' size = 2;     // SMOV Xd, Vn.S\n    otherwise     UNDEFINED;\n\ninteger idxdsize = if imm5<4> == '1' then 128 else 64;\ninteger index = UInt(imm5<4:size+1>);\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 64 else 32;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\n\nX[d] = SignExtend(Elem[operand, index, esize], datasize);"}, {"mnemonic": "BFMLALT (indexed)", "short_desc": "BFloat16 floating-point multiply-add long to single-precision (top, indexed)", "full_desc": "This BFloat16 floating-point multiply-add long instruction widens the odd-numbered 16-bit BFloat16 elements in the first source vector and the indexed element from the corresponding 128-bit segment in the second source vector to single-precision format and then destructively multiplies and adds these values without intermediate rounding to the overlapping 32-bit single-precision elements of the addend and destination vector. This instruction is unpredicated.", "syntax": ["BFMLALT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<imm>\nIs the immediate index, in the range 0 to 7, encoded in the \"i3h:i3l\" fields."], "decode": "if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\ninteger index = UInt(i3h:i3l);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 32;\ninteger eltspersegment = 128 DIV 32;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = 2 * segmentbase + index;\n    bits(32) element1 = Elem[operand1, 2 * e + 1, 16] : Zeros(16);\n    bits(32) element2 = Elem[operand2, s, 16] : Zeros(16);\n    bits(32) element3 = Elem[operand3, e, 32];\n    Elem[result, e, 32] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n\nZ[da] = result;"}, {"mnemonic": "LDAPRB", "short_desc": "Load-Acquire RCpc Register Byte", "full_desc": "Load-Acquire RCpc Register Byte derives an address from a base register value, loads a byte from the derived address in memory, zero-extends it and writes it to a register.", "syntax": ["LDAPRB  <Wt>, [<Xn|SP> {,#0}]\t; Integer"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = AccType_ORDERED;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = Mem[address, dbytes, acctype];\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "NAND, NANDS", "short_desc": "Bitwise NAND predicates", "full_desc": "Bitwise NAND active elements of the second source predicate with corresponding elements of the first source predicate and place the results in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["NAND    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags", "NANDS   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bit element1 = ElemP[operand1, e, esize];\n    bit element2 = ElemP[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        ElemP[result, e, esize] = NOT(element1 AND element2);\n    else\n        ElemP[result, e, esize] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "FRINTZ (vector)", "short_desc": "Floating-point Round to Integral, toward Zero (vector)", "full_desc": "Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTZ  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FRINTZ  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "MSR (register)", "short_desc": "Move general-purpose register to System Register", "full_desc": "Move general-purpose register to System Register allows the PE to write an AArch64 System register from a general-purpose register.", "syntax": ["MSR  (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>\t; System"], "symbols": ["<systemreg>\nIs a System register name, encoded in the \"o0:op1:CRn:CRm:op2\".", "<op0>\n", "<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cn>\nIs a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<Cm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Xt>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."], "decode": "AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 2 + UInt(o0);\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean read = (L == '1');", "operation": "if read then\n    X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"}, {"mnemonic": "FADDP (scalar)", "short_desc": "Floating-point Add Pair of elements (scalar)", "full_desc": "Floating-point Add Pair of elements (scalar). This instruction adds two floating-point vector elements in the source SIMD&FP register and writes the scalar result into the destination SIMD&FP register.", "syntax": ["FADDP  <V><d>, <Vn>.<T>\t; Half-precision", "FADDP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<V>\n", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<T>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\nif sz == '1' then UNDEFINED;\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = ReduceOp_FADD;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "LDNT1B (scalar plus immediate)", "short_desc": "Contiguous load non-temporal bytes to vector (immediate index)", "full_desc": "Contiguous load non-temporal of bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNT1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "NOT (vector)", "short_desc": "Bitwise invert vector (predicated)", "full_desc": "Bitwise invert each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["NOT     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = NOT element;\n\nZ[d] = result;"}, {"mnemonic": "RORV", "short_desc": "Rotate Right Variable", "full_desc": "Rotate Right Variable provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["RORV  <Wd>, <Wn>, <Wm>\t; 32-bit", "RORV  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);", "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"}, {"mnemonic": "SSHR", "short_desc": "Signed Shift Right (immediate)", "full_desc": "Signed Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see .", "syntax": ["SSHR  <V><d>, <V><n>, #<shift>\t; Scalar", "SSHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQRDMLAH (by element)", "short_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element)", "full_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.", "syntax": ["SQRDMLAH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar", "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "if !HaveQRDMLAHExt() then UNDEFINED;\n\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "CASP, CASPA, CASPAL, CASPL", "short_desc": "Compare and Swap Pair of words or doublewords in memory", "full_desc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes.", "syntax": ["CASP  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit CASP", "CASPA  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit CASPA", "CASPAL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit CASPAL", "CASPL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]\t; 32-bit CASPL", "CASP  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit CASP", "CASPA  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit CASPA", "CASPAL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit CASPAL", "CASPL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]\t; 64-bit CASPL"], "symbols": ["<Ws>\nIs the 32-bit name of the first general-purpose register to be compared and loaded, encoded in the \"Rs\" field. <Ws> must be an even-numbered register.", "<W(s+1)>\nIs the 32-bit name of the second general-purpose register to be compared and loaded.", "<Wt>\nIs the 32-bit name of the first general-purpose register to be conditionally stored, encoded in the \"Rt\" field. <Wt> must be an even-numbered register.", "<W(t+1)>\nIs the 32-bit name of the second general-purpose register to be conditionally stored.", "<Xs>\nIs the 64-bit name of the first general-purpose register to be compared and loaded, encoded in the \"Rs\" field. <Xs> must be an even-numbered register.", "<X(s+1)>\nIs the 64-bit name of the second general-purpose register to be compared and loaded.", "<Xt>\nIs the 64-bit name of the first general-purpose register to be conditionally stored, encoded in the \"Rt\" field. <Xt> must be an even-numbered register.", "<X(t+1)>\nIs the 64-bit name of the second general-purpose register to be conditionally stored.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\nif Rs<0> == '1' then UNDEFINED;\nif Rt<0> == '1' then UNDEFINED;\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 32 << UInt(sz);\ninteger regsize = datasize;\nAccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(2*datasize) comparevalue;\nbits(2*datasize) newvalue;\nbits(2*datasize) data;\n\nbits(datasize) s1 = X[s];\nbits(datasize) s2 = X[s+1];\nbits(datasize) t1 = X[t];\nbits(datasize) t2 = X[t+1];\ncomparevalue = if BigEndian() then s1:s2 else s2:s1;\nnewvalue     = if BigEndian() then t1:t2 else t2:t1;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);\n\nif BigEndian() then\n    X[s]   = ZeroExtend(data<2*datasize-1:datasize>, regsize);\n    X[s+1] = ZeroExtend(data<datasize-1:0>, regsize);\nelse\n    X[s]   = ZeroExtend(data<datasize-1:0>, regsize);\n    X[s+1] = ZeroExtend(data<2*datasize-1:datasize>, regsize);"}, {"mnemonic": "IRG", "short_desc": "Insert Random Tag", "full_desc": "Insert Random Tag inserts a random Logical Address Tag into the address in the first source register, and writes the result to the destination register. Any tags specified in the optional second source register or in GCR_EL1.Exclude are excluded from the selection of the random Logical Address Tag.", "syntax": ["IRG  <Xd|SP>, <Xn|SP>{, <Xm>}\t; Integer"], "symbols": ["<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Xd\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Xm\" field. Defaults to XZR if absent."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger d = UInt(Xd);\ninteger n = UInt(Xn);\ninteger m = UInt(Xm);", "operation": "bits(64) operand = if n == 31 then SP[] else X[n];\nbits(64) exclude_reg = X[m];\nbits(16) exclude = exclude_reg<15:0> OR GCR_EL1.Exclude;\n\nif AArch64.AllocationTagAccessIsEnabled(AccType_NORMAL) then\n    if GCR_EL1.RRND == '1' then\n        RGSR_EL1 = bits(32) UNKNOWN;\n        rtag = _ChooseRandomNonExcludedTag(exclude);\n    else\n        bits(4) start = RGSR_EL1.TAG;\n        bits(4) offset = AArch64.RandomTag();\n\n        rtag = AArch64.ChooseNonExcludedTag(start, offset, exclude);\n\n        RGSR_EL1.TAG = rtag;\nelse\n    rtag = '0000';\n\nbits(64) result = AArch64.AddressWithAllocationTag(operand, AccType_NORMAL, rtag);\n\nif d == 31 then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "CMPP", "short_desc": "Compare with Tag", "full_desc": "Compare with Tag subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, updates the condition flags based on the result of the subtraction, and discards the result.", "syntax": ["CMPP  <Xn|SP>, <Xm|SP>\t; Integer"], "symbols": ["<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xm|SP>\nIs the 64-bit name of the second general-purpose source register or stack pointer, encoded in the \"Xm\" field."]}, {"mnemonic": "CMP<cc> (vectors)", "short_desc": "Compare vectors", "full_desc": "Compare active integer elements in the first source vector with corresponding elements in the second source vector, and place the boolean results of the specified comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["CMPEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Equal", "CMPGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than", "CMPGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than or equal", "CMPHI   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Higher", "CMPHS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Higher or same", "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Not equal"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Pd);\nSVECmp op = Cmp_EQ;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        boolean cond;\n        case op of\n            when Cmp_EQ cond = element1 == element2;\n            when Cmp_NE cond = element1 != element2;\n            when Cmp_GE cond = element1 >= element2;\n            when Cmp_LT cond = element1 <  element2;\n            when Cmp_GT cond = element1 >  element2;\n            when Cmp_LE cond = element1 <= element2;\n        ElemP[result, e, esize] = if cond then '1' else '0';\n    else\n        ElemP[result, e, esize] = '0';\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "SQXTUN, SQXTUN2", "short_desc": "Signed saturating extract Unsigned Narrow", "full_desc": "Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.", "syntax": ["SQXTUN  <Vb><d>, <Va><n>\t; Scalar", "SQXTUN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "FCVTNU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTNU  <Hd>, <Hn>\t; Scalar half precision", "FCVTNU  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTNU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTNU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "STADD, STADDL", "short_desc": "Atomic add on word or doubleword in memory, without return", "full_desc": "Atomic add on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory.", "syntax": ["STADD  <Ws>, [<Xn|SP>]\t; 32-bit LDADD alias", "STADDL  <Ws>, [<Xn|SP>]\t; 32-bit LDADDL alias", "STADD  <Xs>, [<Xn|SP>]\t; 64-bit LDADD alias", "STADDL  <Xs>, [<Xn|SP>]\t; 64-bit LDADDL alias"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "STSETH, STSETLH", "short_desc": "Atomic bit set on halfword in memory, without return", "full_desc": "Atomic bit set on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.", "syntax": ["STSETH  <Ws>, [<Xn|SP>]\t; No memory ordering", "STSETLH  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "SQDMLAL, SQDMLAL2 (vector)", "short_desc": "Signed saturating Doubling Multiply-Add Long", "full_desc": "Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["SQDMLAL  <Va><d>, <Vb><n>, <Vb><m>\t; Scalar", "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Va>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vb>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "ST1H (scalar plus immediate)", "short_desc": "Contiguous store halfwords from vector (immediate index)", "full_desc": "Contiguous store of halfwords from elements of a vector register to the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements are not written to memory.", "syntax": ["ST1H    { <Zt>.<T> }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8 << UInt(size);\ninteger msize = 16;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) src = Z[t];\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;\n    addr = addr + mbytes;"}, {"mnemonic": "PRFH (scalar plus immediate)", "short_desc": "Contiguous prefetch halfwords (immediate index)", "full_desc": "Contiguous prefetch of halfword elements from the memory address generated by a 64-bit scalar base and immediate index in the range -32 to 31 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address.", "syntax": ["PRFH    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -32 to 31, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 1;\ninteger offset = SInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) addr;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\n\naddr = base + ((offset * elements) << scale);\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Hint_Prefetch(addr, pref_hint, level, stream);\n    addr = addr + (1 << scale);"}, {"mnemonic": "DC", "short_desc": "Data Cache operation", "full_desc": "Data Cache operation. For more information, see .", "syntax": ["DC  <dc_op>, <Xt>\t; System"], "symbols": ["<dc_op>\n", "<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Xt>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."]}, {"mnemonic": "ST2 (multiple structures)", "short_desc": "Store multiple 2-element structures from two registers", "full_desc": "Store multiple 2-element structures from two registers. This instruction stores multiple 2-element structures from two SIMD&FP registers to memory, with interleaving. Every element of each register is stored.", "syntax": ["ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; No offset", "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UNDEFINED;\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then UNDEFINED;"}, {"mnemonic": "FCMLA (indexed)", "short_desc": "Floating-point complex multiply-add by indexed values with rotate", "full_desc": "Multiply the duplicated real components for rotations 0 and 180, or imaginary components for rotations 90 and 270, of the floating-point complex numbers in each 128-bit segment of the first source vector by the specified complex number in the corresponding the second source vector segment rotated by 0, 90, 180 or 270 degrees in the direction from the positive real axis towards the positive imaginary axis, when considered in polar representation.", "syntax": ["FCMLA   <Zda>.H, <Zn>.H, <Zm>.H[<imm>], <const>\t; Half-precision", "FCMLA   <Zda>.S, <Zn>.S, <Zm>.S[<imm>], <const>\t; Single-precision"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nFor the half-precision variant: is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zm>\nFor the single-precision variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<imm>\nFor the half-precision variant: is the index of a Real and Imaginary pair, in the range 0 to 3, encoded in the \"i2\" field.", "<imm>\nFor the single-precision variant: is the index of a Real and Imaginary pair, in the range 0 to 1, encoded in the \"i1\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger index = UInt(i2);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\ninteger sel_a = UInt(rot<0>);\ninteger sel_b = UInt(NOT(rot<0>));\nboolean neg_i = (rot<1> == '1');\nboolean neg_r = (rot<0> != rot<1>);", "operation": "CheckSVEEnabled();\ninteger pairs = VL DIV (2 * esize);\ninteger pairspersegment = 128 DIV (2 * esize);\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor p = 0 to pairs-1\n    segmentbase = p - (p MOD pairspersegment);\n    s = segmentbase + index;\n    addend_r = Elem[operand3, 2 * p + 0, esize];\n    addend_i = Elem[operand3, 2 * p + 1, esize];\n    elt1_a   = Elem[operand1, 2 * p + sel_a, esize];\n    elt2_a   = Elem[operand2, 2 * s + sel_a, esize];\n    elt2_b   = Elem[operand2, 2 * s + sel_b, esize];\n    if neg_r then elt2_a = FPNeg(elt2_a);\n    if neg_i then elt2_b = FPNeg(elt2_b);\n    addend_r = FPMulAdd(addend_r, elt1_a, elt2_a, FPCR<31:0>);\n    addend_i = FPMulAdd(addend_i, elt1_a, elt2_b, FPCR<31:0>);\n    Elem[result, 2 * p + 0, esize] = addend_r;\n    Elem[result, 2 * p + 1, esize] = addend_i;\n\nZ[da] = result;"}, {"mnemonic": "FABD", "short_desc": "Floating-point absolute difference (predicated)", "full_desc": "Compute the absolute difference of active floating-point elements of the second source vector and corresponding floating-point elements of the first source vector and destructively place the result in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FABD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPAbs(FPSub(element1, element2, FPCR<31:0>));\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "FSUBR (vectors)", "short_desc": "Floating-point reversed subtract vectors (predicated)", "full_desc": "Reversed subtract active floating-point elements of the first source vector from corresponding floating-point elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FSUBR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPSub(element2, element1, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "INDEX (scalars)", "short_desc": "Create index starting from and incremented by general-purpose register", "full_desc": "Populates the destination vector by setting the first element to the first signed scalar integer operand and monotonically incrementing the value by the second signed scalar integer operand for each subsequent element. The scalar source operands are general-purpose registers in which only the least significant bits corresponding to the vector element size are used and any remaining bits are ignored. This instruction is unpredicated.", "syntax": ["INDEX   <Zd>.<T>, <R><n>, <R><m>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<R>\n", "<n>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field.", "<m>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(esize) operand1 = X[n];\ninteger element1 = SInt(operand1);\nbits(esize) operand2 = X[m];\ninteger element2 = SInt(operand2);\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer index = element1 + e * element2;\n    Elem[result, e, esize] = index<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "CMPLT (vectors)", "short_desc": "Compare signed less than vector, setting the condition flags", "full_desc": "Compare active signed integer elements in the first source vector being less than corresponding signed elements in the second source vector, and place the boolean results of the comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["CMPLT   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."]}, {"mnemonic": "LDNF1H", "short_desc": "Contiguous load non-fault unsigned halfwords to vector (immediate index)", "full_desc": "Contiguous load with non-faulting behavior of unsigned halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNF1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element", "LDNF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LDNF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 16;\nboolean unsigned = TRUE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif n == 31 then\n    if ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        // MemNF[] will return fault=TRUE if access is not performed for any reason\n        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "LDNP", "short_desc": "Load Pair of Registers, with non-temporal hint", "full_desc": "Load Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers.", "syntax": ["LDNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit", "LDNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit"], "symbols": ["<Wt1>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8."], "decode": "boolean wback  = FALSE;\nboolean postindex = FALSE;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_STREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc<0> == '1' then UNDEFINED;\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\nboolean tag_checked = wback || n != 31;"}, {"mnemonic": "SM4E", "short_desc": "SM4 Encode", "full_desc": "SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP register, and four iterations of the round key held as the elements of the 128-bit vector in the second source SIMD&FP register. It encrypts the data by four rounds, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&FP register.", "syntax": ["SM4E  <Vd>.4S, <Vn>.4S\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveSM4Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vn = V[n];\nbits(32) intval; \nbits(8) sboxout;\nbits(128) roundresult;\nbits(32) roundkey;\n\nroundresult=V[d];\nfor index = 0 to 3\n    roundkey = Elem[Vn,index,32];\n\n    intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR roundkey; \n\n    for i = 0 to 3  \n        Elem[intval,i,8]  = Sbox(Elem[intval,i,8]); \n\n    intval = intval EOR ROL(intval,2) EOR ROL(intval,10) EOR ROL(intval,18) EOR ROL(intval,24);\n    intval = intval EOR roundresult<31:0>; \n\n    roundresult<31:0> = roundresult<63:32>;\n    roundresult<63:32> = roundresult<95:64>;\n    roundresult<95:64> = roundresult<127:96>;\n    roundresult<127:96> = intval; \nV[d] = roundresult;"}, {"mnemonic": "LASTB (SIMD&FP scalar)", "short_desc": "Extract last element to SIMD&FP scalar register", "full_desc": "If there is an active element then extract the last active element from the final source vector register. If there are no active elements, extract the highest-numbered element. Then place the extracted element in the destination SIMD&FP register.", "syntax": ["LASTB   <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);\nboolean isBefore = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\ninteger last = LastActiveElement(mask, esize);\n\nif isBefore then\n    if last < 0 then last = elements - 1;\nelse\n    last = last + 1;\n    if last >= elements then last = 0;\nV[d] = Elem[operand, last, esize];"}, {"mnemonic": "ADC", "short_desc": "Add with Carry", "full_desc": "Add with Carry adds two register values and the Carry flag value, and writes the result to the destination register.", "syntax": ["ADC  <Wd>, <Wn>, <Wm>\t; 32-bit", "ADC  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "CMP (immediate)", "short_desc": "Compare (immediate)", "full_desc": "Compare (immediate) subtracts an optionally-shifted immediate value from a register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP  <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit", "CMP  <Xn|SP>, #<imm>{, <shift>}\t; 64-bit"], "symbols": ["<Wn|WSP>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<shift>\n"]}, {"mnemonic": "YIELD", "short_desc": "YIELD", "full_desc": "YIELD is a hint instruction. Software with a multithreading capability can use a  instruction to indicate to the PE that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system performance. The PE can use this hint to suspend and resume multiple software threads if it supports the capability.", "syntax": ["YIELD\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "FCVTZU", "short_desc": "Floating-point convert to unsigned integer, rounding toward zero (predicated)", "full_desc": "Convert to the unsigned integer nearer to zero from each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FCVTZU  <Zd>.H, <Pg>/M, <Zn>.H\t; Half-precision to 16-bit", "FCVTZU  <Zd>.S, <Pg>/M, <Zn>.H\t; Half-precision to 32-bit", "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.H\t; Half-precision to 64-bit", "FCVTZU  <Zd>.S, <Pg>/M, <Zn>.S\t; Single-precision to 32-bit", "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.S\t; Single-precision to 64-bit", "FCVTZU  <Zd>.S, <Pg>/M, <Zn>.D\t; Double-precision to 32-bit", "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.D\t; Double-precision to 64-bit"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\ninteger s_esize = 16;\ninteger d_esize = 16;\nboolean unsigned = TRUE;\nFPRounding rounding = FPRounding_ZERO;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        bits(d_esize) res = FPToFixed(element<s_esize-1:0>, 0, unsigned, FPCR<31:0>, rounding);\n        Elem[result, e, esize] = Extend(res, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "STG", "short_desc": "Store Allocation Tag", "full_desc": "Store Allocation Tag stores an Allocation Tag to memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.", "syntax": ["STG  <Xt|SP>, [<Xn|SP>], #<simm>\t; Post-index", "STG  <Xt|SP>, [<Xn|SP>, #<simm>]!\t; Pre-index", "STG  <Xt|SP>, [<Xn|SP>{, #<simm>}]\t; Signed offset"], "symbols": ["<Xt|SP>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<simm>\nIs the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "integer n = UInt(Xn);\ninteger t = UInt(Xt);\nbits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);\nboolean writeback = TRUE;\nboolean postindex = TRUE;\nboolean zero_data = FALSE;", "operation": "bits(64) address;\n\nSetTagCheckedInstruction(FALSE);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif !postindex then\n    address = address + offset;\n\nif zero_data then\n    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(TAG_GRANULE * 8);\n\nbits(64) data = if t == 31 then SP[] else X[t];\nbits(4) tag = AArch64.AllocationTagFromAddress(data);\nAArch64.MemTag[address, AccType_NORMAL] = tag;\n\nif writeback then\n    if postindex then\n        address = address + offset;\n\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "CPY (immediate, merging)", "short_desc": "Copy signed integer immediate to vector elements (merging)", "full_desc": "Copy a signed integer immediate to each active element in the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["CPY     <Zd>.<T>, <Pg>/M, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<imm>\nIs a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger d = UInt(Zd);\nboolean merging = TRUE;\ninteger imm = SInt(imm8);\nif sh == '1' then imm = imm << 8;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) dest = Z[d];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = imm<esize-1:0>;\n    elsif merging then\n        Elem[result, e, esize] = Elem[dest, e, esize];\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[d] = result;"}, {"mnemonic": "HLT", "short_desc": "Halt instruction", "full_desc": "Halt instruction. A instruction can generate a Halt Instruction debug event, which causes entry into Debug state.", "syntax": ["HLT  #<imm>\t; System"], "symbols": ["<imm>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;\nif HaveBTIExt() then\n    SetBTypeCompatible(TRUE);", "operation": "Halt(DebugHalt_HaltInstruction);"}, {"mnemonic": "SUB (vector)", "short_desc": "Subtract (vector)", "full_desc": "Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SUB  <V><d>, <V><n>, <V><m>\t; Scalar", "SUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;"}, {"mnemonic": "MOV (vector)", "short_desc": "Move vector", "full_desc": "Move vector. This instruction copies the vector in the source SIMD&FP register into the destination SIMD&FP register.", "syntax": ["MOV  <Vd>.<T>, <Vn>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field."]}, {"mnemonic": "CMP (extended register)", "short_desc": "Compare (extended register)", "full_desc": "Compare (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value. The argument that is extended from the  register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit", "CMP  <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit"], "symbols": ["<Wn|WSP>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<R>\n", "<m>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<extend>\n", "<extend>\n", "<amount>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."]}, {"mnemonic": "NEG (vector)", "short_desc": "Negate (vector)", "full_desc": "Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["NEG  <V><d>, <V><n>\t; Scalar", "NEG  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    Elem[result, e, esize] = element<esize-1:0>;                \n\nV[d] = result;"}, {"mnemonic": "STXRH", "short_desc": "Store Exclusive Register Halfword", "full_desc": "Store Exclusive Register Halfword stores a halfword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See . The memory access is atomic.", "syntax": ["STXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LD1H (vector plus immediate)", "short_desc": "Gather load unsigned halfwords to vector (immediate index)", "full_desc": "Gather load of unsigned halfwords to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 2 in the range 0 to 62. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1H    { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LD1H    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "LD1H (scalar plus scalar)", "short_desc": "Contiguous load unsigned halfwords to vector (scalar index)", "full_desc": "Contiguous load of unsigned halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 2 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1H    { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 16-bit element", "LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 32-bit element", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 16;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "BFDOT (vector)", "short_desc": "BFloat16 floating-point dot product (vector)", "full_desc": "BFloat16 floating-point dot product (vector). This instruction delimits the source vectors into pairs of 16-bit BF16 elements. Within each pair, the elements in the first source vector are multiplied by the corresponding elements in the second source vector. The resulting single-precision products are then summed and added destructively to the single-precision element of the destination vector that aligns with the pair of BF16 values in the first source vector. The instruction ignores the  and does not update the  exception status.", "syntax": ["BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 32;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];\n    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];\n    bits(16) elt2_a = Elem[operand2, 2 * e + 0, 16];\n    bits(16) elt2_b = Elem[operand2, 2 * e + 1, 16];\n\n    bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));\n    Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);\n\nV[d] = result;"}, {"mnemonic": "CNOT", "short_desc": "Logically invert boolean condition in vector (predicated)", "full_desc": "Logically invert the boolean value in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["CNOT    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = ZeroExtend(IsZeroBit(element), esize);\n\nZ[d] = result;"}, {"mnemonic": "FRECPX", "short_desc": "Floating-point Reciprocal exponent (scalar)", "full_desc": "Floating-point Reciprocal exponent (scalar). This instruction finds an approximate reciprocal exponent for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FRECPX  <Hd>, <Hn>\t; Half-precision", "FRECPX  <V><d>, <V><n>\t; Single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;           \n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecpX(element, FPCR);\n\nV[d] = result;"}, {"mnemonic": "CBNZ", "short_desc": "Compare and Branch on Nonzero", "full_desc": "Compare and Branch on Nonzero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.", "syntax": ["CBNZ  <Wt>, <label>\t; 32-bit", "CBNZ  <Xt>, <label>\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<label>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean iszero = (op == '0');\nbits(64) offset = SignExtend(imm19:'00', 64);", "operation": "bits(datasize) operand1 = X[t];\n\nif IsZero(operand1) == iszero then\n    BranchTo(PC[] + offset, BranchType_DIR);"}, {"mnemonic": "B", "short_desc": "Branch", "full_desc": "Branch causes an unconditional branch to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.", "syntax": ["B  <label>\t; 26-bit signed PC-relative branch offset"], "symbols": ["<label>\nIs the program label to be unconditionally branched to. Its offset from the address of this instruction, in the range +/-128MB, is encoded as \"imm26\" times 4."], "decode": "BranchType branch_type = if op == '1' then BranchType_DIRCALL else BranchType_DIR;\nbits(64) offset = SignExtend(imm26:'00', 64);", "operation": "if branch_type == BranchType_DIRCALL then X[30] = PC[] + 4;\n\nBranchTo(PC[] + offset, branch_type);"}, {"mnemonic": "ORR (shifted register)", "short_desc": "Bitwise OR (shifted register)", "full_desc": "Bitwise OR (shifted register) performs a bitwise (inclusive) OR of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ORR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "ORR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "UQSUB (vectors)", "short_desc": "Unsigned saturating subtract vectors (unpredicated)", "full_desc": "Unsigned saturating subtract all elements of the second source vector from corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. Each result element is saturated to the N-bit element's unsigned integer range 0 to (2)-1. This instruction is unpredicated.", "syntax": ["UQSUB   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - element2, esize, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "SABDL, SABDL2", "short_desc": "Signed Absolute Difference Long", "full_desc": "Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.", "syntax": ["SABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "LSR (wide elements, predicated)", "short_desc": "Logical shift right by 64-bit wide elements (predicated)", "full_desc": "Shift right, inserting zeroes, active elements of the first source vector by corresponding overlapping 64-bit elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. The shift amount is a vector of unsigned 64-bit doubleword elements in which all bits are significant, and not used modulo the destination element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];\n    integer shift = Min(UInt(element2), esize);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = LSR(element1, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "FMIN (vector)", "short_desc": "Floating-point minimum (vector)", "full_desc": "Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "CLS", "short_desc": "Count leading sign bits (predicated)", "full_desc": "Count leading sign bits in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["CLS     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = CountLeadingSignBits(element)<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "SABD", "short_desc": "Signed absolute difference (predicated)", "full_desc": "Compute the absolute difference between signed integer values in active elements of the second source vector and corresponding elements of the first source vector and destructively place the difference in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SABD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer absdiff = Abs(element1 - element2);\n        Elem[result, e, esize] = absdiff<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "ST1 (single structure)", "short_desc": "Store a single-element structure from one lane of one register", "full_desc": "Store a single-element structure from one lane of one register. This instruction stores the specified element of a SIMD&FP register to memory.", "syntax": ["ST1  { <Vt>.B }[<index>], [<Xn|SP>]\t; 8-bit", "ST1  { <Vt>.H }[<index>], [<Xn|SP>]\t; 16-bit", "ST1  { <Vt>.S }[<index>], [<Xn|SP>]\t; 32-bit", "ST1  { <Vt>.D }[<index>], [<Xn|SP>]\t; 64-bit", "ST1  { <Vt>.B }[<index>], [<Xn|SP>], #1\t; 8-bit, immediate offset", "ST1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset", "ST1  { <Vt>.H }[<index>], [<Xn|SP>], #2\t; 16-bit, immediate offset", "ST1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset", "ST1  { <Vt>.S }[<index>], [<Xn|SP>], #4\t; 32-bit, immediate offset", "ST1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset", "ST1  { <Vt>.D }[<index>], [<Xn|SP>], #8\t; 64-bit, immediate offset", "ST1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<index>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<index>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<index>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<index>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB", "short_desc": "Atomic unsigned maximum on byte in memory", "full_desc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDUMAXAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXAB", "LDUMAXALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXALB", "LDUMAXB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXB", "LDUMAXLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FCVTL, FCVTL2", "short_desc": "Floating-point Convert to higher precision Long (vector)", "full_desc": "Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the SIMD&FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the , and writes each result to the equivalent element of the vector in the SIMD&FP destination register.", "syntax": ["FCVTL{2}  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector single-precision and double-precision"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16 << UInt(sz);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);\n\nV[d] = result;"}, {"mnemonic": "RAX1", "short_desc": "Rotate and Exclusive OR", "full_desc": "Rotate and Exclusive OR rotates each 64-bit element of the 128-bit vector in a source SIMD&FP register left by 1, performs a bitwise exclusive OR of the resulting 128-bit vector and the vector in another source SIMD&FP register, and writes the result to the destination SIMD&FP register.", "syntax": ["RAX1  <Vd>.2D, <Vn>.2D, <Vm>.2D\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveSHA3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nV[d] = Vn EOR (ROL(Vm<127:64>,1):ROL(Vm<63:0>, 1));"}, {"mnemonic": "CMGT (zero)", "short_desc": "Compare signed Greater than zero (vector)", "full_desc": "Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMGT  <V><d>, <V><n>, #0\t; Scalar", "CMGT  <Vd>.<T>, <Vn>.<T>, #0\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "MUL", "short_desc": "Multiply", "syntax": ["MUL  <Wd>, <Wn>, <Wm>\t; 32-bit", "MUL  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "STCLRB, STCLRLB", "short_desc": "Atomic bit clear on byte in memory, without return", "full_desc": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.", "syntax": ["STCLRB  <Ws>, [<Xn|SP>]\t; No memory ordering", "STCLRLB  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "UQDECH (vector)", "short_desc": "Unsigned saturating decrement vector by multiple of 16-bit predicate constraint element count", "full_desc": "Determines the number of active 16-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement all destination vector elements. The results are saturated to the 16-bit unsigned integer range.", "syntax": ["UQDECH  <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "LD1SH (vector plus immediate)", "short_desc": "Gather load signed halfwords to vector (immediate index)", "full_desc": "Gather load of signed halfwords to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 2 in the range 0 to 62. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\nboolean unsigned = FALSE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "LD1SH (scalar plus scalar)", "short_desc": "Contiguous load signed halfwords to vector (scalar index)", "full_desc": "Contiguous load of signed halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 2 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 32-bit element", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "MLS (vector)", "short_desc": "Multiply-Subtract from accumulator (vector)", "full_desc": "Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.", "syntax": ["MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n\nV[d] = result;"}, {"mnemonic": "SMINV", "short_desc": "Signed minimum reduction to scalar", "full_desc": "Signed minimum horizontally across all lanes of a vector, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as the maximum signed integer for the element size.", "syntax": ["SMINV   <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\ninteger minimum = if unsigned then (2^esize - 1) else (2^(esize-1) - 1);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer element = Int(Elem[operand, e, esize], unsigned);\n        minimum = Min(minimum, element);\n\nV[d] = minimum<esize-1:0>;"}, {"mnemonic": "FRINT64Z (scalar)", "short_desc": "Floating-point Round to 64-bit Integer toward Zero (scalar)", "full_desc": "Floating-point Round to 64-bit Integer toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINT64Z  <Sd>, <Sn>\t; Single-precision", "FRINT64Z  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFrintExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '1x' UNDEFINED;\n\ninteger intsize = if op<1> == '0' then 32 else 64;\n\nFPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundIntN(operand, FPCR, rounding, intsize);\n\nV[d] = result;"}, {"mnemonic": "CMGE (register)", "short_desc": "Compare signed Greater than or Equal (vector)", "full_desc": "Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMGE  <V><d>, <V><n>, <V><m>\t; Scalar", "CMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "BIC (vector, register)", "short_desc": "Bitwise bit Clear (vector, register)", "full_desc": "Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.", "syntax": ["BIC  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"}, {"mnemonic": "CFINV", "short_desc": "Invert Carry Flag", "full_desc": "Invert Carry Flag. This instruction inverts the value of the PSTATE.C flag.", "syntax": ["CFINV\t; System"], "symbols": [], "decode": "if !HaveFlagManipulateExt() then UNDEFINED;", "operation": "PSTATE.C = NOT(PSTATE.C);"}, {"mnemonic": "PACGA", "short_desc": "Pointer Authentication Code, using Generic key", "full_desc": "Pointer Authentication Code, using Generic key. This instruction computes the pointer authentication code for an address in the first source register, using a modifier in the second source register, and the Generic key. The computed pointer authentication code is returned in the upper 32 bits of the destination register.", "syntax": ["PACGA  <Xd>, <Xn>, <Xm|SP>\t; Integer"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm|SP>\nIs the 64-bit name of the second general-purpose source register or stack pointer, encoded in the \"Rm\" field."], "decode": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif m == 31 then source_is_sp = TRUE;", "operation": "if source_is_sp then\n    X[d] = AddPACGA(X[n], SP[]);\nelse\n    X[d] = AddPACGA(X[n], X[m]);"}, {"mnemonic": "LDRSH (immediate)", "short_desc": "Load Register Signed Halfword (immediate)", "full_desc": "Load Register Signed Halfword (immediate) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see .", "syntax": ["LDRSH  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit", "LDRSH  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit", "LDRSH  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit", "LDRSH  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit", "LDRSH  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit", "LDRSH  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nIs the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "MOV (immediate, predicated, zeroing)", "short_desc": "Move signed integer immediate to vector elements (zeroing)", "full_desc": "Move a signed integer immediate to each active element in the destination vector. Inactive elements in the destination vector register are set to zero.", "syntax": ["MOV     <Zd>.<T>, <Pg>/Z, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<imm>\nIs a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<shift>\n"]}, {"mnemonic": "FCVT", "short_desc": "Floating-point convert precision (predicated)", "full_desc": "Convert the size and precision of each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FCVT    <Zd>.S, <Pg>/M, <Zn>.H\t; Half-precision to single-precision", "FCVT    <Zd>.D, <Pg>/M, <Zn>.H\t; Half-precision to double-precision", "FCVT    <Zd>.H, <Pg>/M, <Zn>.S\t; Single-precision to half-precision", "FCVT    <Zd>.D, <Pg>/M, <Zn>.S\t; Single-precision to double-precision", "FCVT    <Zd>.H, <Pg>/M, <Zn>.D\t; Double-precision to half-precision", "FCVT    <Zd>.S, <Pg>/M, <Zn>.D\t; Double-precision to single-precision"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\ninteger s_esize = 16;\ninteger d_esize = 32;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        bits(d_esize) res = FPConvertSVE(element<s_esize-1:0>, FPCR<31:0>);\n        Elem[result, e, esize] = ZeroExtend(res);\n\nZ[d] = result;"}, {"mnemonic": "FCSEL", "short_desc": "Floating-point Conditional Select (scalar)", "full_desc": "Floating-point Conditional Select (scalar). This instruction allows the SIMD&FP destination register to take the value from either one or the other of two SIMD&FP source registers. If the condition passes, the first SIMD&FP source register value is taken, otherwise the second SIMD&FP source register value is taken.", "syntax": ["FCSEL  <Hd>, <Hn>, <Hm>, <cond>\t; Half-precision", "FCSEL  <Sd>, <Sn>, <Sm>, <cond>\t; Single-precision", "FCSEL  <Dd>, <Dn>, <Dm>, <cond>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nbits(4) condition = cond;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\n\nresult = if ConditionHolds(condition) then V[n] else V[m];\n\nV[d] = result;"}, {"mnemonic": "USDOT (indexed)", "short_desc": "Unsigned by signed integer indexed dot product", "full_desc": "The unsigned by signed integer indexed dot product instruction computes the dot product of a group of four unsigned 8-bit integer values held in each 32-bit element of the first source vector multiplied by a group of four signed 8-bit integer values in an indexed 32-bit element of the second source vector, and then destructively adds the widened dot product to the corresponding 32-bit element of the destination vector.", "syntax": ["USDOT   <Zda>.S, <Zn>.B, <Zm>.B[<imm>]\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<imm>\nIs the immediate index of a quadtuplet of four 8-bit elements within each 128-bit vector segment, in the range 0 to 3, encoded in the \"i2\" field."], "decode": "if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;\ninteger esize = 32;\ninteger index = UInt(i2);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger eltspersegment = 128 DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = segmentbase + index;\n    bits(esize) res = Elem[operand3, e, esize];\n    for i = 0 to 3\n        integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n        integer element2 = SInt(Elem[operand2, 4 * s + i, esize DIV 4]);\n        res = res + element1 * element2;\n    Elem[result, e, esize] = res;\n\nZ[da] = result;"}, {"mnemonic": "CLASTB (SIMD&FP scalar)", "short_desc": "Conditionally extract last element to SIMD&FP scalar register", "full_desc": "From the source vector register extract the last active element, and then zero-extend that element to destructively place in the destination and first source SIMD & floating-point scalar register. If there are no active elements then destructively zero-extend the least significant element-size bits of the destination and first source SIMD & floating-point scalar register.", "syntax": ["CLASTB  <V><dn>, <Pg>, <V><dn>, <Zm>.<T>\t; SVE"], "symbols": ["<V>\n", "<dn>\nIs the number [0-31] of the source and destination SIMD&FP register, encoded in the \"Vdn\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the source scalable vector register, encoded in the \"Zm\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Vdn);\ninteger m = UInt(Zm);\nboolean isBefore = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(esize) operand1 = V[dn];\nbits(VL) operand2 = Z[m];\nbits(esize) result;\ninteger last = LastActiveElement(mask, esize);\n\nif last < 0 then\n    result = ZeroExtend(operand1);\nelse\n    if !isBefore then\n        last = last + 1;\n        if last >= elements then last = 0;\n    result = Elem[operand2, last, esize];\n\nV[dn] = result;"}, {"mnemonic": "FCMLT (vectors)", "short_desc": "Floating-point compare less than vector", "full_desc": "Compare active floating-point elements in the first source vector being less than corresponding elements in the second source vector, and place the boolean results of the comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Does not set the condition flags.", "syntax": ["FCMLT   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."]}, {"mnemonic": "FSUB (vectors, predicated)", "short_desc": "Floating-point subtract vectors (predicated)", "full_desc": "Subtract active floating-point elements of the second source vector from corresponding floating-point elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FSUB    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPSub(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "SQSHRN, SQSHRN2", "short_desc": "Signed saturating Shift Right Narrow (immediate)", "full_desc": "Signed saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts and truncates each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. For rounded results, see .", "syntax": ["SQSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar", "SQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then UNDEFINED;\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "ADD (vectors, predicated)", "short_desc": "Add vectors (predicated)", "full_desc": "Add active elements of the second source vector to corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["ADD     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = element1 + element2;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "STLXR", "short_desc": "Store-Release Exclusive Register", "full_desc": "Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See . The memory access is atomic. The instruction also has memory ordering semantics as described in . For information about memory accesses see .", "syntax": ["STLXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit", "STLXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "PSB CSYNC", "short_desc": "Profiling Synchronization Barrier", "full_desc": "Profiling Synchronization Barrier. This instruction is a barrier that ensures that all existing profiling data for the current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the profiling buffer have been initiated.  A following  instruction completes when the writes to the profiling buffer have completed.", "syntax": ["PSB CSYNC\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "MOV (predicate, predicated, zeroing)", "short_desc": "Move predicates (zeroing)", "full_desc": "Read active elements from the source predicate and place in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Does not set the condition flags.", "syntax": ["MOV     <Pd>.B, <Pg>/Z, <Pn>.B\t; Not setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field."]}, {"mnemonic": "UADDW, UADDW2", "short_desc": "Unsigned Add Wide", "full_desc": "Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.", "syntax": ["UADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Tb>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LDAPURSW", "short_desc": "Load-Acquire RCpc Register Signed Word (unscaled)", "full_desc": "Load-Acquire RCpc Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register.", "syntax": ["LDAPURSW  <Xt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_ORDERED;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "CLASTA (scalar)", "short_desc": "Conditionally extract element after last to general-purpose register", "full_desc": "From the source vector register extract the element after the last active element, or if the last active element is the final element extract element zero, and then zero-extend that element to destructively place in the destination and first source general-purpose register. If there are no active elements then destructively zero-extend the least significant element-size bits of the destination and first source general-purpose register.", "syntax": ["CLASTA  <R><dn>, <Pg>, <R><dn>, <Zm>.<T>\t; SVE"], "symbols": ["<R>\n", "<dn>\nIs the number [0-30] of the source and destination general-purpose register or the name ZR (31), encoded in the \"Rdn\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the source scalable vector register, encoded in the \"Zm\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Rdn);\ninteger m = UInt(Zm);\ninteger csize = if esize < 64 then 32 else 64;\nboolean isBefore = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(esize) operand1 = X[dn];\nbits(VL) operand2 = Z[m];\nbits(csize) result;\ninteger last = LastActiveElement(mask, esize);\n\nif last < 0 then\n    result = ZeroExtend(operand1);\nelse\n    if !isBefore then\n        last = last + 1;\n        if last >= elements then last = 0;\n    result = ZeroExtend(Elem[operand2, last, esize]);\n\nX[dn] = result;"}, {"mnemonic": "UMULH", "short_desc": "Unsigned multiply returning high half (predicated)", "full_desc": "Widening multiply unsigned integer values in active elements of the first source vector by corresponding elements of the second source vector and destructively place the high half of the result in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["UMULH   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer product = (element1 * element2) >> esize;\n        Elem[result, e, esize] = product<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "STR (vector)", "short_desc": "Store vector register", "full_desc": "Store a vector register to a memory address generated by a 64-bit scalar base, plus an immediate offset in the range -256 to 255 which is multiplied by the current vector register size in bytes. This instruction is unpredicated.", "syntax": ["STR     <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -256 to 255, defaulting to 0, encoded in the \"imm9h:imm9l\" fields."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger imm = SInt(imm9h:imm9l);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 8;\nbits(VL) src;\nbits(64) base;\ninteger offset = imm * elements;\n\nif n == 31 then\n    CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nsrc = Z[t];\nboolean aligned = AArch64.CheckAlignment(base + offset, 16, AccType_NORMAL, TRUE);\nfor e = 0 to elements-1\n    AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned] = Elem[src, e, 8];\n    offset = offset + 1;"}, {"mnemonic": "STEORB, STEORLB", "short_desc": "Atomic exclusive OR on byte in memory, without return", "full_desc": "Atomic exclusive OR on byte in memory, without return, atomically loads an 8-bit byte from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory.", "syntax": ["STEORB  <Ws>, [<Xn|SP>]\t; No memory ordering", "STEORLB  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "SQDECW (scalar)", "short_desc": "Signed saturating decrement scalar by multiple of 32-bit predicate constraint element count", "full_desc": "Determines the number of active 32-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQDECW  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "SQDECW  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "STP", "short_desc": "Store Pair of Registers", "full_desc": "Store Pair of Registers calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about memory accesses, see .", "syntax": ["STP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>\t; 32-bit", "STP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; 64-bit", "STP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!\t; 32-bit", "STP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; 64-bit", "STP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit", "STP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit"], "symbols": ["<Wt1>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the \"imm7\" field as <imm>/8.", "<imm>\nFor the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_NORMAL;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif L:opc<0> == '01' || opc == '11' then UNDEFINED;\nboolean signed = (opc<0> != '0');\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\nboolean tag_checked = wback || n != 31;"}, {"mnemonic": "ORR, ORRS (predicates)", "short_desc": "Bitwise inclusive OR predicate", "full_desc": "Bitwise inclusive OR active elements of the second source predicate with corresponding elements of the first source predicate and place the results in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["ORR     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags", "ORRS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bit element1 = ElemP[operand1, e, esize];\n    bit element2 = ElemP[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        ElemP[result, e, esize] = element1 OR element2;\n    else\n        ElemP[result, e, esize] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "FMUL (immediate)", "short_desc": "Floating-point multiply by immediate (predicated)", "full_desc": "Multiply by an immediate each active floating-point element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate may take the value +0.5 or +2.0 only. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMUL    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\nbits(esize) imm = if i1 == '0' then FPPointFive('0') else FPTwo('0');", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMul(element1, imm, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "ST2B (scalar plus immediate)", "short_desc": "Contiguous store two-byte structures from two vectors (immediate index)", "full_desc": "Contiguous store two-byte structures, each from the same element number in two vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 2 in the range -16 to 14 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST2B    { <Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "LDTRB", "short_desc": "Load Register Byte (unprivileged)", "full_desc": "Load Register Byte (unprivileged) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.", "syntax": ["LDTRB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\n\nunpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');\nunpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';\n\nuser_access_override = HaveUAOExt() && PSTATE.UAO == '1';\nif !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then\n    acctype = AccType_UNPRIV;\nelse\n    acctype = AccType_NORMAL;\n\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "SM4EKEY", "short_desc": "SM4 Key", "full_desc": "SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP register and a 128-bit constant from the second SIMD&FP register. It derives four iterations of the output key, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&FP register.", "syntax": ["SM4EKEY  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveSM4Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(32) intval; \nbits(8) sboxout;\nbits(128) result;\nbits(32) const;\nbits(128) roundresult;\n\nroundresult = V[n];\nfor index = 0 to 3 \n    const = Elem[Vm,index,32];\n\n    intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR const; \n\n    for i = 0 to 3  \n        Elem[intval,i,8] = Sbox(Elem[intval,i,8]); \n\n    intval = intval EOR ROL(intval,13) EOR ROL(intval,23);\n    intval = intval EOR roundresult<31:0>; \n\n    roundresult<31:0> = roundresult<63:32>;\n    roundresult<63:32> = roundresult<95:64>;\n    roundresult<95:64> = roundresult<127:96>;\n    roundresult<127:96> = intval; \nV[d] = roundresult;"}, {"mnemonic": "FMAXP (vector)", "short_desc": "Floating-point Maximum Pairwise (vector)", "full_desc": "Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SQDECP (scalar)", "short_desc": "Signed saturating decrement scalar by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to decrement the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQDECP  <Xdn>, <Pm>.<T>, <Wdn>\t; 32-bit", "SQDECP  <Xdn>, <Pm>.<T>\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<T>\n", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Rdn);\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(ssize) operand1 = X[dn];\nbits(PL) operand2 = P[m];\nbits(ssize) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\ninteger element = Int(operand1, unsigned);\n(result, -) = SatQ(element - count, ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "BFXIL", "short_desc": "Bitfield extract and insert at low end", "full_desc": "Bitfield Extract and Insert Low copies a bitfield of  bits starting from bit position  in the source register to the least significant bits of the destination register, leaving the other destination bits unchanged.", "syntax": ["BFXIL  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit", "BFXIL  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<lsb>\nFor the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.", "<lsb>\nFor the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.", "<width>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<width>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "LDAXRH", "short_desc": "Load-Acquire Exclusive Register Halfword", "full_desc": "Load-Acquire Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See . The instruction also has memory ordering semantics as described in . For information about memory accesses see .", "syntax": ["LDAXRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDAPR", "short_desc": "Load-Acquire RCpc Register", "full_desc": "Load-Acquire RCpc Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from the derived address in memory, and writes it to a register.", "syntax": ["LDAPR  <Wt>, [<Xn|SP> {,#0}]\t; 32-bit", "LDAPR  <Xt>, [<Xn|SP> {,#0}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = AccType_ORDERED;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = Mem[address, dbytes, acctype];\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SHLL, SHLL2", "short_desc": "Shift Left Long (by element size)", "full_desc": "Shift Left Long (by element size). This instruction reads each vector element in the lower or upper half of the source SIMD&FP register, left shifts each result by the element size, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.", "syntax": ["SHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = esize;\nboolean unsigned = FALSE; // Or TRUE without change of functionality", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LSL (wide elements, predicated)", "short_desc": "Logical shift left by 64-bit wide elements (predicated)", "full_desc": "Shift left active elements of the first source vector by corresponding overlapping 64-bit elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. The shift amount is a vector of unsigned 64-bit doubleword elements in which all bits are significant, and not used modulo the destination element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];\n    integer shift = Min(UInt(element2), esize);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = LSL(element1, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "PFIRST", "short_desc": "Set the first active predicate element to true", "full_desc": "Sets the first active element in the destination predicate to true, otherwise elements from the source predicate are passed through unchanged. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["PFIRST  <Pdn>.B, <Pg>, <Pdn>.B\t; SVE"], "symbols": ["<Pdn>\nIs the name of the source and destination scalable predicate register, encoded in the \"Pdn\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger dn = UInt(Pdn);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) result = P[dn];\ninteger first = -1;\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' && first == -1 then\n        first = e;\n\nif first >= 0 then\n    ElemP[result, first, esize] = '1';\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[dn] = result;"}, {"mnemonic": "DUP (scalar)", "short_desc": "Broadcast general-purpose register to vector elements (unpredicated)", "full_desc": "Unconditionally broadcast the general-purpose scalar source register into each element of the destination vector. This instruction is unpredicated.", "syntax": ["DUP     <Zd>.<T>, <R><n|SP>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<R>\n", "<n|SP>\nIs the number [0-30] of the general-purpose source register or the name SP (31), encoded in the \"Rn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Rn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) operand;\nif n == 31 then\n    operand = SP[];\nelse\n    operand = X[n];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = operand<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "ST4 (single structure)", "short_desc": "Store single 4-element structure from one lane of four registers", "full_desc": "Store single 4-element structure from one lane of four registers. This instruction stores a 4-element structure to memory from corresponding elements of four SIMD&FP registers.", "syntax": ["ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]\t; 8-bit", "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]\t; 16-bit", "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]\t; 32-bit", "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]\t; 64-bit", "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4\t; 8-bit, immediate offset", "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset", "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8\t; 16-bit, immediate offset", "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset", "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16\t; 32-bit, immediate offset", "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset", "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32\t; 64-bit, immediate offset", "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Vt4>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<index>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<index>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<index>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<index>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "ST1B (scalar plus immediate)", "short_desc": "Contiguous store bytes from vector (immediate index)", "full_desc": "Contiguous store of bytes from elements of a vector register to the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements are not written to memory.", "syntax": ["ST1B    { <Zt>.<T> }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8 << UInt(size);\ninteger msize = 8;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) src = Z[t];\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;\n    addr = addr + mbytes;"}, {"mnemonic": "LDRB (immediate)", "short_desc": "Load Register Byte (immediate)", "full_desc": "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see .", "syntax": ["LDRB  <Wt>, [<Xn|SP>], #<simm>\t; Post-index", "LDRB  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index", "LDRB  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nIs the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "FMINNM (immediate)", "short_desc": "Floating-point minimum number with immediate (predicated)", "full_desc": "Determine the minimum number value of an immediate and each active floating-point element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate may take the value +0.0 or +1.0 only. If the element value is NaN then the result is the immediate. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMINNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\nbits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMinNum(element1, imm, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "FNEG (vector)", "short_desc": "Floating-point Negate (vector)", "full_desc": "Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FNEG  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FNEG  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    if neg then\n        element = FPNeg(element);\n    else\n        element = FPAbs(element);\n    Elem[result, e, esize] = element;\n\nV[d] = result;"}, {"mnemonic": "ORR (immediate)", "short_desc": "Bitwise OR (immediate)", "full_desc": "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and an immediate register value, and writes the result to the destination register.", "syntax": ["ORR  <Wd|WSP>, <Wn>, #<imm>\t; 32-bit", "ORR  <Xd|SP>, <Xn>, #<imm>\t; 64-bit"], "symbols": ["<Wd|WSP>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<imm>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then UNDEFINED;\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "FSUB (vector)", "short_desc": "Floating-point Subtract (vector)", "full_desc": "Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&FP register, from the corresponding elements in the vector in the first source SIMD&FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, FPCR);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\n\nV[d] = result;"}, {"mnemonic": "UABD", "short_desc": "Unsigned Absolute Difference (vector)", "full_desc": "Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "MLS (by element)", "short_desc": "Multiply-Subtract from accumulator (vector, by element)", "full_desc": "Multiply-Subtract from accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and subtracts the results from the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values.", "syntax": ["MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\n\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\nV[d] = result;"}, {"mnemonic": "LDNT1H (scalar plus immediate)", "short_desc": "Contiguous load non-temporal halfwords to vector (immediate index)", "full_desc": "Contiguous load non-temporal of halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNT1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "SQINCB", "short_desc": "Signed saturating increment scalar by multiple of 8-bit predicate constraint element count", "full_desc": "Determines the number of active 8-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQINCB  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "SQINCB  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "ST2G", "short_desc": "Store Allocation Tags", "full_desc": "Store Allocation Tags stores an Allocation Tag to two Tag granules of memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.", "syntax": ["ST2G  <Xt|SP>, [<Xn|SP>], #<simm>\t; Post-index", "ST2G  <Xt|SP>, [<Xn|SP>, #<simm>]!\t; Pre-index", "ST2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]\t; Signed offset"], "symbols": ["<Xt|SP>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<simm>\nIs the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger n = UInt(Xn);\ninteger t = UInt(Xt);\nbits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);\nboolean writeback = TRUE;\nboolean postindex = TRUE;\nboolean zero_data = FALSE;", "operation": "bits(64) address;\nbits(64) data = if t == 31 then SP[] else X[t];\nbits(4) tag = AArch64.AllocationTagFromAddress(data);\n\nSetTagCheckedInstruction(FALSE);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif !postindex then\n    address = address + offset;\n\nif zero_data then\n    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);\n    Mem[address+TAG_GRANULE, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);\n\nAArch64.MemTag[address, AccType_NORMAL] = tag;\nAArch64.MemTag[address+TAG_GRANULE, AccType_NORMAL] = tag;\n\nif writeback then\n    if postindex then\n        address = address + offset;\n\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "UQDECD (vector)", "short_desc": "Unsigned saturating decrement vector by multiple of 64-bit predicate constraint element count", "full_desc": "Determines the number of active 64-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement all destination vector elements. The results are saturated to the 64-bit unsigned integer range.", "syntax": ["UQDECD  <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "ST4W (scalar plus scalar)", "short_desc": "Contiguous store four-word structures from four vectors (scalar index)", "full_desc": "Contiguous store four-word structures, each from the same element number in four vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by four. The index register is not updated by the instruction.", "syntax": ["ST4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "SUB (extended register)", "short_desc": "Subtract (extended register)", "full_desc": "Subtract (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the  register can be a byte, halfword, word, or doubleword.", "syntax": ["SUB  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit", "SUB  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit"], "symbols": ["<Wd|WSP>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wn|WSP>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<R>\n", "<m>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<extend>\n", "<extend>\n", "<amount>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then UNDEFINED;", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LD4D (scalar plus immediate)", "short_desc": "Contiguous load four-doubleword structures to four vectors (immediate index)", "full_desc": "Contiguous load four-doubleword structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 4 in the range -32 to 28 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "BFM", "short_desc": "Bitfield Move", "full_desc": "Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly.", "syntax": ["BFM  <Wd>, <Wn>, #<immr>, #<imms>\t; 32-bit", "BFM  <Xd>, <Xn>, #<immr>, #<imms>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr>\nFor the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the \"immr\" field.", "<immr>\nFor the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the \"immr\" field.", "<imms>\nFor the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31, encoded in the \"imms\" field.", "<imms>\nFor the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the \"imms\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\n\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    // SBFM\n    when '01' inzero = FALSE; extend = FALSE;   // BFM\n    when '10' inzero = TRUE;  extend = FALSE;   // UBFM\n    when '11' UNDEFINED;\n\nif sf == '1' && N != '1' then UNDEFINED;\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;\n\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);", "operation": "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\n\n// perform bitfield move on low bits\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\n\n// determine extension bits (sign, zero or dest register)\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\n\n// combine extension bits and result bits\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);"}, {"mnemonic": "CFP", "short_desc": "Control Flow Prediction Restriction by Context", "full_desc": "Control Flow Prediction Restriction by Context prevents control flow predictions that predict execution addresses, based on information gathered from earlier execution within a particular execution context, from allowing later speculative execution within that context to be observable through side-channels.", "syntax": ["CFP  RCTX, <Xt>\t; System"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."]}, {"mnemonic": "EOR3", "short_desc": "Three-way Exclusive OR", "full_desc": "Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.", "syntax": ["EOR3  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Va>\nIs the name of the third SIMD&FP source register, encoded in the \"Ra\" field."], "decode": "if !HaveSHA3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger a = UInt(Ra);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Va = V[a];\nV[d] = Vn EOR Vm EOR Va;"}, {"mnemonic": "FCVTZS (scalar, integer)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTZS  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTZS  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTZS  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTZS  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTZS  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTZS  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "ST3W (scalar plus immediate)", "short_desc": "Contiguous store three-word structures from three vectors (immediate index)", "full_desc": "Contiguous store three-word structures, each from the same element number in three vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 3 in the range -24 to 21 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "TST (immediate)", "short_desc": "Test bits (immediate)", "syntax": ["TST  <Wn>, #<imm>\t; 32-bit", "TST  <Xn>, #<imm>\t; 64-bit"], "symbols": ["<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<imm>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."]}, {"mnemonic": "CMGE (zero)", "short_desc": "Compare signed Greater than or Equal to zero (vector)", "full_desc": "Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMGE  <V><d>, <V><n>, #0\t; Scalar", "CMGE  <Vd>.<T>, <Vn>.<T>, #0\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "LD3D (scalar plus scalar)", "short_desc": "Contiguous load three-doubleword structures to three vectors (scalar index)", "full_desc": "Contiguous load three-doubleword structures, each to the same element number in three vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by three. The index register is not updated by the instruction.", "syntax": ["LD3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "STRH (immediate)", "short_desc": "Store Register Halfword (immediate)", "full_desc": "Store Register Halfword (immediate) stores the least significant halfword of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see .", "syntax": ["STRH  <Wt>, [<Xn|SP>], #<simm>\t; Post-index", "STRH  <Wt>, [<Xn|SP>, #<simm>]!\t; Pre-index", "STRH  <Wt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nIs the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "FMAX (vectors)", "short_desc": "Floating-point maximum (predicated)", "full_desc": "Determine the maximum of active floating-point elements of the second source vector and corresponding floating-point elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. If either element value is NaN then the result is NaN. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "LDNF1B", "short_desc": "Contiguous load non-fault unsigned bytes to vector (immediate index)", "full_desc": "Contiguous load with non-faulting behavior of unsigned bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNF1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 8-bit element", "LDNF1B  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element", "LDNF1B  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LDNF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger msize = 8;\nboolean unsigned = TRUE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif n == 31 then\n    if ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        // MemNF[] will return fault=TRUE if access is not performed for any reason\n        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "ORN (vector)", "short_desc": "Bitwise inclusive OR NOT (vector)", "full_desc": "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.", "syntax": ["ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"}, {"mnemonic": "UQADD (vectors)", "short_desc": "Unsigned saturating add vectors (unpredicated)", "full_desc": "Unsigned saturating add all elements of the second source vector to corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. Each result element is saturated to the N-bit element's unsigned integer range 0 to (2)-1. This instruction is unpredicated.", "syntax": ["UQADD   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + element2, esize, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "FMAXNM (immediate)", "short_desc": "Floating-point maximum number with immediate (predicated)", "full_desc": "Determine the maximum number value of an immediate and each active floating-point element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate may take the value +0.0 or +1.0 only. If the element value is NaN then the result is the immediate. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMAXNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\nbits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMaxNum(element1, imm, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "LSRR", "short_desc": "Reversed logical shift right by vector (predicated)", "full_desc": "Reversed shift right, inserting zeroes, active elements of the second source vector by corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. The shift amount operand is a vector of unsigned elements in which all bits are significant, and not used modulo the element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["LSRR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    integer shift = Min(UInt(element1), esize);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = LSR(element2, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "LSR (register)", "short_desc": "Logical Shift Right (register)", "full_desc": "Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["LSR  <Wd>, <Wn>, <Wm>\t; 32-bit", "LSR  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."]}, {"mnemonic": "SDOT (vectors)", "short_desc": "Signed integer dot product", "full_desc": "The signed integer dot product instruction computes the dot product of a group of four signed 8-bit or 16-bit integer values held in each 32-bit or 64-bit element of the first source vector multiplied by a group of four signed 8-bit or 16-bit integer values in the corresponding 32-bit or 64-bit element of the second source vector, and then destructively adds the widened dot product to the corresponding 32-bit or 64-bit element of the destination vector.", "syntax": ["SDOT    <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Tb>\n", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '0x' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) res = Elem[operand3, e, esize];\n    for i = 0 to 3\n        integer element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n        integer element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        res = res + element1 * element2;\n    Elem[result, e, esize] = res;\n\nZ[da] = result;"}, {"mnemonic": "FRINTP (vector)", "short_desc": "Floating-point Round to Integral, toward Plus infinity (vector)", "full_desc": "Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTP  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FRINTP  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "BFDOT (by element)", "short_desc": "BFloat16 floating-point dot product (vector, by element)", "full_desc": "BFloat16 floating-point dot product (vector, by element). This instruction delimits the source vectors into pairs of 16-bit BF16 elements. Each pair of elements in the first source vector is multiplied by the specified pair of elements in the second source vector. The resulting single-precision products are then summed and added destructively to the single-precision element of the destination vector that aligns with the pair of BF16 values in the first source vector. The instruction ignores the  and does not update the  exception status.", "syntax": ["BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2H[<index>]\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<index>\nIs the immediate index of a pair of 16-bit elements in the range 0 to 3, encoded in the \"H:L\" fields."], "decode": "if !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\ninteger d = UInt(Rd);\ninteger i = UInt(H:L);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 32;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128)      operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];\n    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];\n    bits(16) elt2_a = Elem[operand2, 2 * i + 0, 16];\n    bits(16) elt2_b = Elem[operand2, 2 * i + 1, 16];\n\n    bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));\n    Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);\n\nV[d] = result;"}, {"mnemonic": "FADD (scalar)", "short_desc": "Floating-point Add (scalar)", "full_desc": "Floating-point Add (scalar). This instruction adds the floating-point values of the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.", "syntax": ["FADD  <Hd>, <Hn>, <Hm>\t; Half-precision", "FADD  <Sd>, <Sn>, <Sm>\t; Single-precision", "FADD  <Dd>, <Dn>, <Dm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean sub_op = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif sub_op then\n    result = FPSub(operand1, operand2, FPCR);\nelse\n    result = FPAdd(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "PRFB (scalar plus immediate)", "short_desc": "Contiguous prefetch bytes (immediate index)", "full_desc": "Contiguous prefetch of byte elements from the memory address generated by a 64-bit scalar base and immediate index in the range -32 to 31 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address.", "syntax": ["PRFB    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -32 to 31, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 0;\ninteger offset = SInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) addr;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\n\naddr = base + ((offset * elements) << scale);\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Hint_Prefetch(addr, pref_hint, level, stream);\n    addr = addr + (1 << scale);"}, {"mnemonic": "BRKPB, BRKPBS", "short_desc": "Break before first true condition, propagating from previous partition", "full_desc": "If the last active element of the first source predicate is false then set the destination predicate to all-false. Otherwise sets destination predicate elements up to but not including the first active and true source element to true, then sets subsequent elements to false. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["BRKPB   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags", "BRKPBS  <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\nboolean last = (LastActive(mask, operand1, 8) == '1');\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, 8] == '1' then\n        last = last && (ElemP[operand2, e, 8] == '0');\n        ElemP[result, e, 8] = if last then '1' else '0';\n    else\n        ElemP[result, e, 8] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "LD1ROD (scalar plus scalar)", "short_desc": "Contiguous load and replicate four doublewords (scalar index)", "full_desc": "Load four contiguous doublewords to elements of a 256-bit (octaword) vector from the memory address generated by a 64-bit scalar base address and scalar index which is multiplied by 8 and added to the base address.", "syntax": ["LD1ROD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVEFP64MatMulExt() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;", "operation": "CheckSVEEnabled();\nif VL < 256 then UNDEFINED;\ninteger elements = 256 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low bits only\nbits(64) offset;\nbits(256) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\noffset = X[m];\n\naddr = base + UInt(offset) * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);"}, {"mnemonic": "FCMP", "short_desc": "Floating-point quiet Compare (scalar)", "full_desc": "Floating-point quiet Compare (scalar). This instruction compares the two SIMD&FP source register values, or the first SIMD&FP source register value and zero. It writes the result to the .{N, Z, C, V} flags.", "syntax": ["FCMP  <Hn>, <Hm>\t; Half-precision", "FCMP  <Hn>, #0.0\t; Half-precision, zero", "FCMP  <Sn>, <Sm>\t; Single-precision", "FCMP  <Sn>, #0.0\t; Single-precision, zero", "FCMP  <Dn>, <Dm>\t; Double-precision", "FCMP  <Dn>, #0.0\t; Double-precision, zero"], "symbols": ["<Dn>\nFor the double-precision variant: is the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nFor the double-precision, zero variant: is the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hn>\nFor the half-precision variant: is the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nFor the half-precision, zero variant: is the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sn>\nFor the single-precision variant: is the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sn>\nFor the single-precision, zero variant: is the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);   // ignored when opc<0> == '1'\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean signal_all_nans = (opc<1> == '1');\nboolean cmp_with_zero = (opc<0> == '1');", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = if cmp_with_zero then FPZero('0') else V[m];\n\nPSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);"}, {"mnemonic": "UADDV", "short_desc": "Unsigned add reduction to scalar", "full_desc": "Unsigned add horizontally across all lanes of a vector, and place the result in the SIMD&FP scalar destination register. Narrow elements are first zero-extended to 64 bits. Inactive elements in the source vector are treated as zero.", "syntax": ["UADDV   <Dd>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<Dd>\nIs the 64-bit name of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\ninteger sum = 0;\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer element = UInt(Elem[operand, e, esize]);\n        sum = sum + element;\n\nV[d] = sum<63:0>;"}, {"mnemonic": "LD1RQH (scalar plus scalar)", "short_desc": "Contiguous load and replicate eight halfwords (scalar index)", "full_desc": "Load eight contiguous halfwords to elements of a short, 128-bit (quadword) vector from the memory address generated by a 64-bit scalar base address and scalar index which is multiplied by 2 and added to the base address.", "syntax": ["LD1RQH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;", "operation": "CheckSVEEnabled();\ninteger elements = 128 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low 16 bits only\nbits(64) offset;\nbits(128) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = X[m];\n\naddr = base + UInt(offset) * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = Replicate(result, VL DIV 128);"}, {"mnemonic": "INSR (SIMD&FP scalar)", "short_desc": "Insert SIMD&FP scalar register in shifted vector", "full_desc": "Shift the destination vector left by one element, and then place a copy of the SIMD&FP scalar register in element 0 of the destination vector. This instruction is unpredicated.", "syntax": ["INSR    <Zdn>.<T>, <V><m>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<V>\n", "<m>\nIs the number [0-31] of the source SIMD&FP register, encoded in the \"Vm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Vm);", "operation": "CheckSVEEnabled();\nbits(VL) dest = Z[dn];\nbits(esize) src = V[m];\nZ[dn] = dest<VL-esize-1:0> : src;"}, {"mnemonic": "LDEOR, LDEORA, LDEORAL, LDEORL", "short_desc": "Atomic exclusive OR on word or doubleword in memory", "full_desc": "Atomic exclusive OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDEOR  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDEOR", "LDEORA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDEORA", "LDEORAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDEORAL", "LDEORL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDEORL", "LDEOR  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDEOR", "LDEORA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDEORA", "LDEORAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDEORAL", "LDEORL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDEORL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "TLBI", "short_desc": "TLB Invalidate operation", "full_desc": "TLB Invalidate operation. For more information, see .", "syntax": ["TLBI  <tlbi_op>{, <Xt>}\t; System"], "symbols": ["<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<tlbi_op>\n", "<Xt>\nIs the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the \"Rt\" field."]}, {"mnemonic": "STUMIN, STUMINL", "short_desc": "Atomic unsigned minimum on word or doubleword in memory, without return", "full_desc": "Atomic unsigned minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.", "syntax": ["STUMIN  <Ws>, [<Xn|SP>]\t; 32-bit LDUMIN alias", "STUMINL  <Ws>, [<Xn|SP>]\t; 32-bit LDUMINL alias", "STUMIN  <Xs>, [<Xn|SP>]\t; 64-bit LDUMIN alias", "STUMINL  <Xs>, [<Xn|SP>]\t; 64-bit LDUMINL alias"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "LD3 (single structure)", "short_desc": "Load single 3-element structure to one lane of three registers)", "full_desc": "Load single 3-element structure to one lane of three registers). This instruction loads a 3-element structure from memory and writes the result to the corresponding elements of the three SIMD&FP registers without affecting the other bits of the registers.", "syntax": ["LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]\t; 8-bit", "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]\t; 16-bit", "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]\t; 32-bit", "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]\t; 64-bit", "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3\t; 8-bit, immediate offset", "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset", "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6\t; 16-bit, immediate offset", "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset", "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12\t; 32-bit, immediate offset", "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset", "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24\t; 64-bit, immediate offset", "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<index>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<index>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<index>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<index>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "ORR (vector, register)", "short_desc": "Bitwise inclusive OR (vector, register)", "full_desc": "Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.", "syntax": ["ORR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"}, {"mnemonic": "CNTB, CNTD, CNTH, CNTW", "short_desc": "Set scalar to multiple of predicate constraint element count", "full_desc": "Determines the number of active elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then places the result in the scalar destination.", "syntax": ["CNTB    <Xd>{, <pattern>{, MUL #<imm>}}\t; Byte", "CNTD    <Xd>{, <pattern>{, MUL #<imm>}}\t; Doubleword", "CNTH    <Xd>{, <pattern>{, MUL #<imm>}}\t; Halfword", "CNTW    <Xd>{, <pattern>{, MUL #<imm>}}\t; Word"], "symbols": ["<Xd>\nIs the 64-bit name of the destination general-purpose register, encoded in the \"Rd\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger d = UInt(Rd);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\n\nX[d] = (count * imm)<63:0>;"}, {"mnemonic": "ASR (wide elements, predicated)", "short_desc": "Arithmetic shift right by 64-bit wide elements (predicated)", "full_desc": "Shift right, preserving the sign bit, active elements of the first source vector by corresponding overlapping 64-bit elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. The shift amount is a vector of unsigned 64-bit doubleword elements in which all bits are significant, and not used modulo the destination element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];\n    integer shift = Min(UInt(element2), esize);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = ASR(element1, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "ADDVL", "short_desc": "Add multiple of vector register size to scalar register", "full_desc": "Add the current vector register size in bytes multiplied by an immediate in the range -32 to 31 to the 64-bit source general-purpose register or current stack pointer, and place the result in the 64-bit destination general-purpose register or current stack pointer.", "syntax": ["ADDVL   <Xd|SP>, <Xn|SP>, #<imm>\t; SVE"], "symbols": ["<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the signed immediate operand, in the range -32 to 31, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger n = UInt(Rn);\ninteger d = UInt(Rd);\ninteger imm = SInt(imm6);", "operation": "CheckSVEEnabled();\nbits(64) operand1 = if n == 31 then SP[] else X[n];\nbits(64) result = operand1 + (imm * (VL DIV 8));\n\nif d == 31 then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "MOVI", "short_desc": "Move Immediate (vector)", "full_desc": "Move Immediate (vector). This instruction places an immediate constant into every vector element of the destination SIMD&FP register.", "syntax": ["MOVI  <Vd>.<T>, #<imm8>{, LSL #0}\t; 8-bit", "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit shifted immediate", "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit shifted immediate", "MOVI  <Vd>.<T>, #<imm8>, MSL #<amount>\t; 32-bit shifting ones", "MOVI  <Dd>, #<imm>\t; 64-bit scalar", "MOVI  <Vd>.2D, #<imm>\t; 64-bit vector"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<imm>\nIs a 64-bit immediate 'aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh', encoded in \"a:b:c:d:e:f:g:h\".", "<T>\n", "<T>\n", "<T>\n", "<imm8>\nIs an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\".", "<amount>\n", "<amount>\n", "<amount>\n"], "decode": "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UNDEFINED;\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"}, {"mnemonic": "FCMLE (vectors)", "short_desc": "Floating-point compare less than or equal to vector", "full_desc": "Compare active floating-point elements in the first source vector being less than or equal to corresponding elements in the second source vector, and place the boolean results of the comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Does not set the condition flags.", "syntax": ["FCMLE   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than or equal"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."]}, {"mnemonic": "SEL (predicates)", "short_desc": "Conditionally select elements from two predicates", "full_desc": "Read active elements from the first source predicate and inactive elements from the second source predicate and place in the corresponding elements of the destination predicate. Does not set the condition flags.", "syntax": ["SEL     <Pd>.B, <Pg>, <Pn>.B, <Pm>.B\t; SVE"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bit element1 = ElemP[operand1, e, esize];\n    bit element2 = ElemP[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        ElemP[result, e, esize] = element1;\n    else\n        ElemP[result, e, esize] = element2;\n\nP[d] = result;"}, {"mnemonic": "PRFM (literal)", "short_desc": "Prefetch Memory (literal)", "full_desc": "Prefetch Memory (literal) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.", "syntax": ["PRFM  (<prfop>|#<imm5>), <label>\t; Literal"], "symbols": ["<prfop>\nIs the prefetch operation, defined as .", "<imm5>\nIs the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<label>\nIs the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\n\noffset = SignExtend(imm19:'00', 64);\nboolean tag_checked = FALSE;", "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);"}, {"mnemonic": "FRINTA (scalar)", "short_desc": "Floating-point Round to Integral, to nearest with ties to Away (scalar)", "full_desc": "Floating-point Round to Integral, to nearest with ties to Away (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTA  <Hd>, <Hn>\t; Half-precision", "FRINTA  <Sd>, <Sn>\t; Single-precision", "FRINTA  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "FTSMUL", "short_desc": "Floating-point trigonometric starting value", "full_desc": "The  instruction calculates the initial value for the  instruction. The instruction squares each element in the first source vector and then sets the sign bit to a copy of bit 0 of the corresponding element in the second source register, and places the results in the destination vector. This instruction is unpredicated.", "syntax": ["FTSMUL  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPTrigSMul(element1, element2, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "LDTRSH", "short_desc": "Load Register Signed Halfword (unprivileged)", "full_desc": "Load Register Signed Halfword (unprivileged) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.", "syntax": ["LDTRSH  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDTRSH  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\n\nunpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');\nunpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';\n\nuser_access_override = HaveUAOExt() && PSTATE.UAO == '1';\nif !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then\n    acctype = AccType_UNPRIV;\nelse\n    acctype = AccType_NORMAL;\n\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "FMADD", "short_desc": "Floating-point fused Multiply-Add (scalar)", "full_desc": "Floating-point fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, adds the product to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.", "syntax": ["FMADD  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision", "FMADD  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision", "FMADD  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Da>\nIs the 64-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ha>\nIs the 16-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Sa>\nIs the 32-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "CSDB", "short_desc": "Consumption of Speculative Data Barrier", "full_desc": "Consumption of Speculative Data Barrier is a memory barrier that controls speculative execution and data value prediction.", "syntax": ["CSDB\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "UXTL, UXTL2", "short_desc": "Unsigned extend Long", "full_desc": "Unsigned extend Long. This instruction copies each vector element from the lower or upper half of the source SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.", "syntax": ["UXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n"]}, {"mnemonic": "STURB", "short_desc": "Store Register Byte (unscaled)", "full_desc": "Store Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register. For information about memory accesses, see .", "syntax": ["STURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "FMINNMP (scalar)", "short_desc": "Floating-point Minimum Number of Pair of elements (scalar)", "full_desc": "Floating-point Minimum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&FP register.", "syntax": ["FMINNMP  <V><d>, <Vn>.<T>\t; Half-precision", "FMINNMP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<V>\n", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<T>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then UNDEFINED;\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH", "short_desc": "Atomic signed maximum on halfword in memory", "full_desc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDSMAXAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXAH", "LDSMAXALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXALH", "LDSMAXH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXH", "LDSMAXLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LD2H (scalar plus scalar)", "short_desc": "Contiguous load two-halfword structures to two vectors (scalar index)", "full_desc": "Contiguous load two-halfword structures, each to the same element number in two vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by two. The index register is not updated by the instruction.", "syntax": ["LD2H    { <Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "FADDV", "short_desc": "Floating-point add recursive reduction to scalar", "full_desc": "Floating-point add horizontally over all lanes of a vector using a recursive pairwise reduction, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as +0.0.", "syntax": ["FADDV   <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(esize) identity = FPZero('0');\n\nV[d] = ReducePredicated(ReduceOp_FADD, operand, mask, identity);"}, {"mnemonic": "ADD (immediate)", "short_desc": "Add (immediate)", "full_desc": "Add (immediate) adds a register value and an optionally-shifted immediate value, and writes the result to the destination register.", "syntax": ["ADD  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit", "ADD  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit"], "symbols": ["<Wd|WSP>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wn|WSP>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase sh of\n    when '0' imm = ZeroExtend(imm12, datasize);\n    when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "ZIP1, ZIP2 (vectors)", "short_desc": "Interleave elements from two half vectors", "full_desc": "Interleave alternating elements from the lowest or highest halves of the first and second source vectors and place in elements of the destination vector. This instruction is unpredicated. The 128-bit element variant of this instruction requires that the current vector length is at least 256 bits, and if the current vector length is not an integer multiple of 256 bits then the trailing bits are set to zero.", "syntax": ["ZIP2    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; High halves", "ZIP2    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; High halves (quadwords)", "ZIP1    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Low halves", "ZIP1    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Low halves (quadwords)"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);\ninteger part = 1;", "operation": "CheckSVEEnabled();\nif VL < esize * 2 then UNDEFINED;\ninteger pairs = VL DIV (esize * 2);\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result = Zeros();\n\ninteger base = part * pairs;\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\n\nZ[d] = result;"}, {"mnemonic": "LD1D (scalar plus vector)", "short_desc": "Gather load doublewords to vector (vector index)", "full_desc": "Gather load of doublewords to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 8. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]\t; 32-bit unpacked scaled offset", "LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]\t; 64-bit scaled offset", "LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\ninteger offs_size = 32;\nboolean unsigned = TRUE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset = Z[m];\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "STGM", "short_desc": "Store Tag Multiple", "full_desc": "Store Tag Multiple writes a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID_EL1.BS, and the Allocation Tag written to address A is taken from the source register at 4*A<7:4>+3:4*A<7:4>.", "syntax": ["STGM  <Xt>, [<Xn|SP>]\t; Integer"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger t = UInt(Xt);\ninteger n = UInt(Xn);", "operation": "if PSTATE.EL == EL0 then\n    UNDEFINED;\n\nbits(64) data = X[t];\nbits(64) address;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ninteger size = 4*(2^(UInt(GMID_EL1.BS)));\naddress = Align(address,size);\ninteger count = size >> LOG2_TAG_GRANULE;\ninteger index = UInt(address<LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE>);\n\nfor i = 0 to count-1\n    bits(4) tag = data<(index*4)+3:index*4>;\n    AArch64.MemTag[address, AccType_NORMAL] = tag;\n    address = address + TAG_GRANULE;\n    index = index + 1;"}, {"mnemonic": "STNT1D (scalar plus scalar)", "short_desc": "Contiguous store non-temporal doublewords from vector (scalar index)", "full_desc": "Contiguous store non-temporal of doublewords from elements of a vector register to the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 8 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements are not written to memory.", "syntax": ["STNT1D  { <Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(64) offset = X[m];\nbits(VL) src;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nsrc = Z[t];\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];\n    offset = offset + 1;"}, {"mnemonic": "MOV (vector, unpredicated)", "short_desc": "Move vector register (unpredicated)", "full_desc": "Move vector register. This instruction is unpredicated.", "syntax": ["MOV     <Zd>.D, <Zn>.D\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field."]}, {"mnemonic": "ADRP", "short_desc": "Form PC-relative address to 4KB page", "full_desc": "Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register.", "syntax": ["ADRP  <Xd>, <label>\t; Literal"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<label>\nIs the program label whose 4KB page address is to be calculated. Its offset from the page address of this instruction, in the range +/-4GB, is encoded as \"immhi:immlo\" times 4096."], "decode": "integer d = UInt(Rd);\nboolean page = (op == '1');\nbits(64) imm;\n\nif page then\n    imm = SignExtend(immhi:immlo:Zeros(12), 64);\nelse\n    imm = SignExtend(immhi:immlo, 64);", "operation": "bits(64) base = PC[];\n\nif page then\n    base<11:0> = Zeros(12);\n\nX[d] = base + imm;"}, {"mnemonic": "FNMLS", "short_desc": "Floating-point negated fused multiply-subtract vectors (predicated), writing addend [Zda = -Zda + Zn * Zm]", "full_desc": "Multiply the corresponding active floating-point elements of the first and second source vectors and subtract from elements of the third source (addend) vector without intermediate rounding. Destructively place the negated results in the destination and third source (addend) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FNMLS   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean op1_neg = FALSE;\nboolean op3_neg = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    bits(esize) element3 = Elem[operand3, e, esize];\n\n    if ElemP[mask, e, esize] == '1' then\n        if op1_neg then element1 = FPNeg(element1);\n        if op3_neg then element3 = FPNeg(element3);\n        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element3;\n\nZ[da] = result;"}, {"mnemonic": "FCVTMU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTMU  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTMU  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTMU  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTMU  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTMU  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTMU  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "FMOV (zero, predicated)", "short_desc": "Move floating-point +0.0 to vector elements (predicated)", "full_desc": "Move floating-point constant +0.0 to to each active element in the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMOV    <Zd>.<T>, <Pg>/M, #0.0\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field."]}, {"mnemonic": "STUMAX, STUMAXL", "short_desc": "Atomic unsigned maximum on word or doubleword in memory, without return", "full_desc": "Atomic unsigned maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.", "syntax": ["STUMAX  <Ws>, [<Xn|SP>]\t; 32-bit LDUMAX alias", "STUMAXL  <Ws>, [<Xn|SP>]\t; 32-bit LDUMAXL alias", "STUMAX  <Xs>, [<Xn|SP>]\t; 64-bit LDUMAX alias", "STUMAXL  <Xs>, [<Xn|SP>]\t; 64-bit LDUMAXL alias"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "ORR (vectors, unpredicated)", "short_desc": "Bitwise inclusive OR vectors (unpredicated)", "full_desc": "Bitwise inclusive OR all elements of the second source vector with corresponding elements of the first source vector and place the first in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["ORR     <Zd>.D, <Zn>.D, <Zm>.D\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\n\nZ[d] = operand1 OR operand2;"}, {"mnemonic": "SQADD (immediate)", "short_desc": "Signed saturating add immediate (unpredicated)", "full_desc": "Signed saturating add of an unsigned immediate to each element of the source vector, and destructively place the results in the corresponding elements of the source vector. Each result element is saturated to the N-bit element's signed integer range -2 to (2)-1. This instruction is unpredicated.", "syntax": ["SQADD   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger imm = UInt(imm8);\nif sh == '1' then imm = imm << 8;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + imm, esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "CNEG", "short_desc": "Conditional Negate", "full_desc": "Conditional Negate returns, in the destination register, the negated value of the source register if the condition is TRUE, and otherwise returns the value of the source register.", "syntax": ["CNEG  <Wd>, <Wn>, <cond>\t; 32-bit", "CNEG  <Xd>, <Xn>, <cond>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "LD1SW (scalar plus vector)", "short_desc": "Gather load signed words to vector (vector index)", "full_desc": "Gather load of signed words to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 4. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset", "LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset", "LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 32;\ninteger offs_size = 32;\nboolean unsigned = FALSE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset = Z[m];\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "SHA256H", "short_desc": "SHA256 hash update (part 1)", "full_desc": "SHA256 hash update (part 1).", "syntax": ["SHA256H  <Qd>, <Qn>, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Qn>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif !HaveSHA256Ext() then UNDEFINED;\nboolean part1 = (P == '0');", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) result;\nif part1 then\n    result = SHA256hash(V[d], V[n], V[m], TRUE);\nelse\n    result = SHA256hash(V[n], V[d], V[m], FALSE);\nV[d] = result;"}, {"mnemonic": "FMINNMP (vector)", "short_desc": "Floating-point Minimum Number Pairwise (vector)", "full_desc": "Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "LD1ROW (scalar plus scalar)", "short_desc": "Contiguous load and replicate eight words (scalar index)", "full_desc": "Load eight contiguous words to elements of a 256-bit (octaword) vector from the memory address generated by a 64-bit scalar base address and scalar index which is multiplied by 4 and added to the base address.", "syntax": ["LD1ROW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVEFP64MatMulExt() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;", "operation": "CheckSVEEnabled();\nif VL < 256 then UNDEFINED;\ninteger elements = 256 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low bits only\nbits(64) offset;\nbits(256) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\noffset = X[m];\n\naddr = base + UInt(offset) * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);"}, {"mnemonic": "UQINCP (vector)", "short_desc": "Unsigned saturating increment vector by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to increment all destination vector elements. The results are saturated to the element unsigned integer range.", "syntax": ["UQINCP  <Zdn>.<T>, <Pm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Zdn);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(PL) operand2 = P[m];\nbits(VL) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\nfor e = 0 to elements-1\n    integer element = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element + count, esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "PTRUE, PTRUES", "short_desc": "Initialise predicate from named constraint", "full_desc": "Set elements of the destination predicate to true if the element number satisfies the named predicate constraint, or to false otherwise. If the constraint specifies more elements than are available at the current vector length then all elements of the destination predicate are set to false.", "syntax": ["PTRUE   <Pd>.<T>{, <pattern>}\t; Not setting the condition flags", "PTRUES  <Pd>.<T>{, <pattern>}\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<pattern>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;\nbits(5) pat = pattern;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(PL) result;\n\nfor e = 0 to elements-1\n    ElemP[result, e, esize] = if e < count then '1' else '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(result, result, esize);\nP[d] = result;"}, {"mnemonic": "STSMINH, STSMINLH", "short_desc": "Atomic signed minimum on halfword in memory, without return", "full_desc": "Atomic signed minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.", "syntax": ["STSMINH  <Ws>, [<Xn|SP>]\t; No memory ordering", "STSMINLH  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "ADD (extended register)", "short_desc": "Add (extended register)", "full_desc": "Add (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the  register can be a byte, halfword, word, or doubleword.", "syntax": ["ADD  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit", "ADD  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit"], "symbols": ["<Wd|WSP>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wn|WSP>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<R>\n", "<m>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<extend>\n", "<extend>\n", "<amount>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then UNDEFINED;", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "STR (immediate)", "short_desc": "Store Register (immediate)", "full_desc": "Store Register (immediate) stores a word or a doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see .", "syntax": ["STR  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit", "STR  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit", "STR  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit", "STR  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit", "STR  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit", "STR  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nFor the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4.", "<pimm>\nFor the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "SMLAL, SMLAL2 (by element)", "short_desc": "Signed Multiply-Add Long (vector, by element)", "full_desc": "Signed Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element in the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values.", "syntax": ["SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"}, {"mnemonic": "SQXTN, SQXTN2", "short_desc": "Signed saturating extract Narrow", "full_desc": "Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.", "syntax": ["SQXTN  <Vb><d>, <Va><n>\t; Scalar", "SQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "SHSUB", "short_desc": "Signed Halving Subtract", "full_desc": "Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    Elem[result, e, esize] = diff<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "STLUR", "short_desc": "Store-Release Register (unscaled)", "full_desc": "Store-Release Register (unscaled) calculates an address from a base register value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register.", "syntax": ["STLUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "STLUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_ORDERED;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "SQDMULH (vector)", "short_desc": "Signed saturating Doubling Multiply returning High half", "full_desc": "Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SQDMULH  <V><d>, <V><n>, <V><m>\t; Scalar", "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "AND (vectors, predicated)", "short_desc": "Bitwise AND vectors (predicated)", "full_desc": "Bitwise AND active elements of the second source vector with corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["AND     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = element1 AND element2;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "SHA512SU1", "short_desc": "SHA512 Schedule Update 1", "full_desc": "SHA512 Schedule Update 1 takes the values from the three source SIMD&FP registers and produces a 128-bit output value that combines the gamma1 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register.", "syntax": ["SHA512SU1  <Vd>.2D, <Vn>.2D, <Vm>.2D\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveSHA512Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(64) sig1;\nbits(128) Vtmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\n\nsig1 = ROR(X<127:64>, 19) EOR ROR(X<127:64>,61) EOR ('000000':X<127:70>);\nVtmp<127:64> = W<127:64> + sig1 + Y<127:64>;\nsig1 = ROR(X<63:0>, 19) EOR ROR(X<63:0>,61) EOR ('000000':X<63:6>);\nVtmp<63:0> = W<63:0> + sig1 + Y<63:0>;\nV[d] = Vtmp;"}, {"mnemonic": "SQINCH (scalar)", "short_desc": "Signed saturating increment scalar by multiple of 16-bit predicate constraint element count", "full_desc": "Determines the number of active 16-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQINCH  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "SQINCH  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "STLRB", "short_desc": "Store-Release Register Byte", "full_desc": "Store-Release Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["STLRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "ST2H (scalar plus immediate)", "short_desc": "Contiguous store two-halfword structures from two vectors (immediate index)", "full_desc": "Contiguous store two-halfword structures, each from the same element number in two vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 2 in the range -16 to 14 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST2H    { <Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "USHLL, USHLL2", "short_desc": "Unsigned Shift Left Long (immediate)", "full_desc": "Unsigned Shift Left Long (immediate). This instruction reads each vector element in the lower or upper half of the source SIMD&FP register, shifts the unsigned integer value left by the specified number of bits, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.", "syntax": ["USHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(datasize*2) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "BRK", "short_desc": "Breakpoint instruction", "full_desc": "Breakpoint instruction. A  instruction generates a Breakpoint Instruction exception. The PE records the exception in , using the EC value , and captures the value of the immediate argument in .ISS.", "syntax": ["BRK  #<imm>\t; System"], "symbols": ["<imm>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "bits(16) comment = imm16;\nif HaveBTIExt() then\n    SetBTypeCompatible(TRUE);", "operation": "AArch64.SoftwareBreakpoint(comment);"}, {"mnemonic": "LD1W (scalar plus vector)", "short_desc": "Gather load unsigned words to vector (vector index)", "full_desc": "Gather load of unsigned words to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 4. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]\t; 32-bit scaled offset", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\ninteger offs_size = 32;\nboolean unsigned = TRUE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset = Z[m];\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "PSSBB", "short_desc": "Physical Speculative Store Bypass Barrier", "full_desc": "Physical Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing earlier stores to the same physical address.", "syntax": ["PSSBB\t; System"], "symbols": [], "decode": "// No additional decoding required", "operation": "SpeculativeStoreBypassBarrierToPA();"}, {"mnemonic": "SUBHN, SUBHN2", "short_desc": "Subtract returning High Narrow", "full_desc": "Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.", "syntax": ["SUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"}, {"mnemonic": "STNT1W (scalar plus scalar)", "short_desc": "Contiguous store non-temporal words from vector (scalar index)", "full_desc": "Contiguous store non-temporal of words from elements of a vector register to the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 4 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements are not written to memory.", "syntax": ["STNT1W  { <Zt>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(64) offset = X[m];\nbits(VL) src;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nsrc = Z[t];\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];\n    offset = offset + 1;"}, {"mnemonic": "PRFM (immediate)", "short_desc": "Prefetch Memory (immediate)", "full_desc": "Prefetch Memory (immediate) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches.", "syntax": ["PRFM  (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]\t; Unsigned offset"], "symbols": ["<prfop>\nIs the prefetch operation, defined as .", "<imm5>\nIs the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<pimm>\nIs the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "UMAX", "short_desc": "Unsigned Maximum (vector)", "full_desc": "Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FRECPE", "short_desc": "Floating-point reciprocal estimate (unpredicated)", "full_desc": "Find the approximate reciprocal of each floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["FRECPE  <Zd>.<T>, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand = Z[n];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecipEstimate(element, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "INCP (vector)", "short_desc": "Increment vector by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to increment all destination vector elements.", "syntax": ["INCP    <Zdn>.<T>, <Pm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Zdn);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(PL) operand2 = P[m];\nbits(VL) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[operand1, e, esize] + count;\n\nZ[dn] = result;"}, {"mnemonic": "SUQADD", "short_desc": "Signed saturating Accumulate of Unsigned value", "full_desc": "Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.", "syntax": ["SUQADD  <V><d>, <V><n>\t; Scalar", "SUQADD  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(datasize) operand2 = V[d];\ninteger op1;\ninteger op2;\nboolean sat;\n\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, e, esize], !unsigned);\n    op2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);\n    if sat then FPSR.QC = '1';\nV[d] = result;"}, {"mnemonic": "STRB (register)", "short_desc": "Store Register Byte (register)", "full_desc": "Store Register Byte (register) calculates an address from a base register value and an offset register value, and stores a byte from a 32-bit register to the calculated address. For information about memory accesses, see .", "syntax": ["STRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; Extended register", "STRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; Shifted register"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\nIs the index shift amount, it must be , encoded in \"S\" as  if omitted, or as  if present."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "USMMLA", "short_desc": "Unsigned by signed integer matrix multiply-accumulate", "full_desc": "The unsigned by signed integer matrix multiply-accumulate instruction multiplies the 2\u00d78 matrix of unsigned 8-bit integer values held in each 128-bit segment of the first source vector by the 8\u00d72 matrix of signed 8-bit integer values in the corresponding segment of the second source vector. The resulting 2\u00d72 widened 32-bit integer matrix product is then destructively added to the 32-bit integer matrix accumulator held in the corresponding segment of the addend and destination vector. This is equivalent to performing an 8-way dot product per destination element.", "syntax": ["USMMLA  <Zda>.S, <Zn>.B, <Zm>.B\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean op1_unsigned = TRUE;\nboolean op2_unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger segments = VL DIV 128;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result = Zeros();\nbits(128) op1, op2;\nbits(128) res, addend;\n\nfor s = 0 to segments-1\n    op1    = Elem[operand1, s, 128];\n    op2    = Elem[operand2, s, 128];\n    addend = Elem[operand3, s, 128];\n    res    = MatMulAdd(addend, op1, op2, op1_unsigned, op2_unsigned);\n    Elem[result, s, 128] = res;\n\nZ[da] = result;"}, {"mnemonic": "IC", "short_desc": "Instruction Cache operation", "full_desc": "Instruction Cache operation. For more information, see .", "syntax": ["IC  <ic_op>{, <Xt>}\t; System"], "symbols": ["<ic_op>\n", "<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Xt>\nIs the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the \"Rt\" field."]}, {"mnemonic": "UMMLA (vector)", "short_desc": "Unsigned 8-bit integer matrix multiply-accumulate (vector)", "full_desc": "Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of unsigned 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element.", "syntax": ["UMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveInt8MatMulExt() then UNDEFINED;\ncase B:U of\n    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;\n    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;\n    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;\n    when '11' UNDEFINED;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(128) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(128) addend   = V[d];\n\nV[d] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);"}, {"mnemonic": "BFMLALB (vectors)", "short_desc": "BFloat16 floating-point multiply-add long to single-precision (bottom)", "full_desc": "This BFloat16 floating-point multiply-add long instruction widens the even-numbered 16-bit BFloat16 elements in the first source vector and the corresponding elements in the second source vector to single-precision format and then destructively multiplies and adds these values without intermediate rounding to the overlapping 32-bit single-precision elements of the addend and destination vector. This instruction is unpredicated.", "syntax": ["BFMLALB <Zda>.S, <Zn>.H, <Zm>.H\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 32;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(32) element1 = Elem[operand1, 2 * e + 0, 16] : Zeros(16);\n    bits(32) element2 = Elem[operand2, 2 * e + 0, 16] : Zeros(16);\n    bits(32) element3 = Elem[operand3, e, 32];\n    Elem[result, e, 32] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n\nZ[da] = result;"}, {"mnemonic": "LD1B (scalar plus scalar)", "short_desc": "Contiguous load unsigned bytes to vector (scalar index)", "full_desc": "Contiguous load of unsigned bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1B    { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 8-bit element", "LD1B    { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 16-bit element", "LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 32-bit element", "LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger msize = 8;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "LD1B (vector plus immediate)", "short_desc": "Gather load unsigned bytes to vector (immediate index)", "full_desc": "Gather load of unsigned bytes to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is in the range 0 to 31. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1B    { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LD1B    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 8;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "SUB (immediate)", "short_desc": "Subtract (immediate)", "full_desc": "Subtract (immediate) subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register.", "syntax": ["SUB  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit", "SUB  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit"], "symbols": ["<Wd|WSP>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wn|WSP>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase sh of\n    when '0' imm = ZeroExtend(imm12, datasize);\n    when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "URHADD", "short_desc": "Unsigned Rounding Halving Add", "full_desc": "Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["URHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "FCMLE (zero)", "short_desc": "Floating-point Compare Less than or Equal to zero (vector)", "full_desc": "Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FCMLE  <Hd>, <Hn>, #0.0\t; Scalar half precision", "FCMLE  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision", "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision", "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "LD1SB (scalar plus scalar)", "short_desc": "Contiguous load signed bytes to vector (scalar index)", "full_desc": "Contiguous load of signed bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1SB   { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 16-bit element", "LD1SB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 32-bit element", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 8;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "LD1SB (vector plus immediate)", "short_desc": "Gather load signed bytes to vector (immediate index)", "full_desc": "Gather load of signed bytes to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is in the range 0 to 31. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1SB   { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 8;\nboolean unsigned = FALSE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "USUBL, USUBL2", "short_desc": "Unsigned Subtract Long", "full_desc": "Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.", "syntax": ["USUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LD2R", "short_desc": "Load single 2-element structure and Replicate to all lanes of two registers", "full_desc": "Load single 2-element structure and Replicate to all lanes of two registers. This instruction loads a 2-element structure from memory and replicates the structure to all the lanes of the two SIMD&FP registers.", "syntax": ["LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; No offset", "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "FMAXP (scalar)", "short_desc": "Floating-point Maximum of Pair of elements (scalar)", "full_desc": "Floating-point Maximum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP register.", "syntax": ["FMAXP  <V><d>, <Vn>.<T>\t; Half-precision", "FMAXP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<V>\n", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<T>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then UNDEFINED;\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "SUBR (vectors)", "short_desc": "Reversed subtract vectors (predicated)", "full_desc": "Reversed subtract active elements of the first source vector from corresponding elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SUBR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = element2 - element1;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "SABA", "short_desc": "Signed Absolute difference and Accumulate", "full_desc": "Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.", "syntax": ["SABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "SADDLP", "short_desc": "Signed Add Long Pairwise", "full_desc": "Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.", "syntax": ["SADDLP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nif acc then result = V[d];\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    if acc then\n        Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n    else\n        Elem[result, e, 2*esize] = sum;\n\nV[d] = result;"}, {"mnemonic": "SB", "short_desc": "Speculation Barrier", "full_desc": "Speculation Barrier is a barrier that controls speculation.", "syntax": ["SB\t; System"], "symbols": [], "decode": "if !HaveSBExt() then UNDEFINED;", "operation": "SpeculationBarrier();"}, {"mnemonic": "FADD (vectors, unpredicated)", "short_desc": "Floating-point add vector (unpredicated)", "full_desc": "Add all floating-point elements of the second source vector to corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["FADD    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "FRECPS", "short_desc": "Floating-point reciprocal step (unpredicated)", "full_desc": "Multiply corresponding floating-point elements of the first and second source vectors, subtract the products from 2.0 without intermediate rounding and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["FRECPS  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRecipStepFused(element1, element2);\n\nZ[d] = result;"}, {"mnemonic": "FCVTPS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTPS  <Hd>, <Hn>\t; Scalar half precision", "FCVTPS  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTPS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTPS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "UQADD", "short_desc": "Unsigned saturating Add", "full_desc": "Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UQADD  <V><d>, <V><n>, <V><m>\t; Scalar", "UQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "SQRSHL", "short_desc": "Signed saturating Rounding Shift Left (register)", "full_desc": "Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SQRSHL  <V><d>, <V><n>, <V><m>\t; Scalar", "SQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "CMPLE (vectors)", "short_desc": "Compare signed less than or equal to vector, setting the condition flags", "full_desc": "Compare active signed integer elements in the first source vector being less than or equal to corresponding signed elements in the second source vector, and place the boolean results of the comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["CMPLE   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than or equal"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."]}, {"mnemonic": "FMAXNMV", "short_desc": "Floating-point Maximum Number across Vector", "full_desc": "Floating-point Maximum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMAXNMV  <V><d>, <Vn>.<T>\t; Half-precision", "FMAXNMV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<V>\nFor the half-precision variant: is the destination width specifier, H.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<T>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "SQDMLAL, SQDMLAL2 (by element)", "short_desc": "Signed saturating Doubling Multiply-Add Long (by element)", "full_desc": "Signed saturating Doubling Multiply-Add Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["SQDMLAL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]\t; Scalar", "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Va>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vb>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "ST4D (scalar plus scalar)", "short_desc": "Contiguous store four-doubleword structures from four vectors (scalar index)", "full_desc": "Contiguous store four-doubleword structures, each from the same element number in four vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by four. The index register is not updated by the instruction.", "syntax": ["ST4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "CNTP", "short_desc": "Set scalar to count of true predicate elements", "full_desc": "Counts the number of active and true elements in the source predicate and places the scalar result in the destination general-purpose register. Inactive predicate elements are not counted.", "syntax": ["CNTP    <Xd>, <Pg>, <Pn>.<T>\t; SVE"], "symbols": ["<Xd>\nIs the 64-bit name of the destination general-purpose register, encoded in the \"Rd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the source scalable predicate register, encoded in the \"Pn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger d = UInt(Rd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand = P[n];\nbits(64) sum = Zeros();\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' && ElemP[operand, e, esize] == '1' then\n        sum = sum + 1;\nX[d] = sum;"}, {"mnemonic": "LDRH (register)", "short_desc": "Load Register Halfword (register)", "full_desc": "Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\n"], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "SXTB, SXTH, SXTW", "short_desc": "Signed byte / halfword / word extend (predicated)", "full_desc": "Sign-extend the least-significant sub-element of each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SXTB    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Byte", "SXTH    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Halfword", "SXTW    <Zd>.D, <Pg>/M, <Zn>.D\t; Word"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger s_esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Extend(element<s_esize-1:0>, esize, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "LD4W (scalar plus immediate)", "short_desc": "Contiguous load four-word structures to four vectors (immediate index)", "full_desc": "Contiguous load four-word structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 4 in the range -32 to 28 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "FRINT32X (scalar)", "short_desc": "Floating-point Round to 32-bit Integer, using current rounding mode (scalar)", "full_desc": "Floating-point Round to 32-bit Integer, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 32-bit integer size using the rounding mode that is determined by the , and writes the result to the SIMD&FP destination register.", "syntax": ["FRINT32X  <Sd>, <Sn>\t; Single-precision", "FRINT32X  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFrintExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '1x' UNDEFINED;\n\ninteger intsize = if op<1> == '0' then 32 else 64;\n\nFPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundIntN(operand, FPCR, rounding, intsize);\n\nV[d] = result;"}, {"mnemonic": "UQINCW (vector)", "short_desc": "Unsigned saturating increment vector by multiple of 32-bit predicate constraint element count", "full_desc": "Determines the number of active 32-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment all destination vector elements. The results are saturated to the 32-bit unsigned integer range.", "syntax": ["UQINCW  <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "SQRDMLAH (vector)", "short_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector)", "full_desc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.", "syntax": ["SQRDMLAH  <V><d>, <V><n>, <V><m>\t; Scalar", "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveQRDMLAHExt() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "SMAX (vectors)", "short_desc": "Signed maximum vectors (predicated)", "full_desc": "Determine the signed maximum of active elements of the second source vector and corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer maximum = Max(element1, element2);\n        Elem[result, e, esize] = maximum<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "ST3D (scalar plus immediate)", "short_desc": "Contiguous store three-doubleword structures from three vectors (immediate index)", "full_desc": "Contiguous store three-doubleword structures, each from the same element number in three vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 3 in the range -24 to 21 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "LD3W (scalar plus scalar)", "short_desc": "Contiguous load three-word structures to three vectors (scalar index)", "full_desc": "Contiguous load three-word structures, each to the same element number in three vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by three. The index register is not updated by the instruction.", "syntax": ["LD3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "LDADDB, LDADDAB, LDADDALB, LDADDLB", "short_desc": "Atomic add on byte in memory", "full_desc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDADDAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDAB", "LDADDALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDALB", "LDADDB  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDB", "LDADDLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STADDB, STADDLB", "short_desc": "Atomic add on byte in memory, without return", "full_desc": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory.", "syntax": ["STADDB  <Ws>, [<Xn|SP>]\t; No memory ordering", "STADDLB  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "FCVTNS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTNS  <Hd>, <Hn>\t; Scalar half precision", "FCVTNS  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTNS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTNS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "DUP (indexed)", "short_desc": "Broadcast indexed element to vector (unpredicated)", "full_desc": "Unconditionally broadcast the indexed source vector element into each element of the destination vector. This instruction is unpredicated.", "syntax": ["DUP     <Zd>.<T>, <Zn>.<T>[<imm>]\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the immediate index, in the range 0 to one less than the number of elements in 512 bits, encoded in \"imm2:tsz\"."], "decode": "if !HaveSVE() then UNDEFINED;\nbits(7) imm = imm2:tsz;\ncase tsz of\n    when '00000' UNDEFINED;\n    when '10000' esize = 128; index = UInt(imm<6:5>);\n    when 'x1000' esize = 64;  index = UInt(imm<6:4>);\n    when 'xx100' esize = 32;  index = UInt(imm<6:3>);\n    when 'xxx10' esize = 16;  index = UInt(imm<6:2>);\n    when 'xxxx1' esize = 8;   index = UInt(imm<6:1>);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) result;\nbits(esize) element;\n\nif index >= elements then\n    element = Zeros();\nelse\n    element = Elem[operand1, index, esize];\nresult = Replicate(element);\n\nZ[d] = result;"}, {"mnemonic": "SADDW, SADDW2", "short_desc": "Signed Add Wide", "full_desc": "Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register.", "syntax": ["SADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Tb>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "ADDPL", "short_desc": "Add multiple of predicate register size to scalar register", "full_desc": "Add the current predicate register size in bytes multiplied by an immediate in the range -32 to 31 to the 64-bit source general-purpose register or current stack pointer and place the result in the 64-bit destination general-purpose register or current stack pointer.", "syntax": ["ADDPL   <Xd|SP>, <Xn|SP>, #<imm>\t; SVE"], "symbols": ["<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the signed immediate operand, in the range -32 to 31, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger n = UInt(Rn);\ninteger d = UInt(Rd);\ninteger imm = SInt(imm6);", "operation": "CheckSVEEnabled();\nbits(64) operand1 = if n == 31 then SP[] else X[n];\nbits(64) result = operand1 + (imm * (PL DIV 8));\n\nif d == 31 then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "SBFIZ", "short_desc": "Signed Bitfield Insert in Zero", "full_desc": "Signed Bitfield Insert in Zeros copies a bitfield of  bits from the least significant bits of the source register to bit position  of the destination register, setting the destination bits below the bitfield to zero, and the bits above the bitfield to a copy of the most significant bit of the bitfield.", "syntax": ["SBFIZ  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit", "SBFIZ  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<lsb>\nFor the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.", "<lsb>\nFor the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<width>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<width>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "STR (register)", "short_desc": "Store Register (register)", "full_desc": "Store Register (register) calculates an address from a base register value and an offset register value, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory accesses, see .", "syntax": ["STR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit", "STR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\n", "<amount>\n"], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "SMMLA (vector)", "short_desc": "Signed 8-bit integer matrix multiply-accumulate (vector)", "full_desc": "Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of signed 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element.", "syntax": ["SMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveInt8MatMulExt() then UNDEFINED;\ncase B:U of\n    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;\n    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;\n    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;\n    when '11' UNDEFINED;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(128) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(128) addend   = V[d];\n\nV[d] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);"}, {"mnemonic": "TBL", "short_desc": "Table vector Lookup", "full_desc": "Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.", "syntax": ["TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>\t; Two register table", "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>\t; Three register table", "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>\t; Four register table", "TBL  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>\t; Single register table"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nFor the four register table, three register table and two register table variant: is the name of the first SIMD&FP table register, encoded in the \"Rn\" field.", "<Vn>\nFor the single register table variant: is the name of the SIMD&FP table register, encoded in the \"Rn\" field.", "<Vn+1>\nIs the name of the second SIMD&FP table register, encoded as \"Rn\" plus 1 modulo 32.", "<Vn+2>\nIs the name of the third SIMD&FP table register, encoded as \"Rn\" plus 2 modulo 32.", "<Vn+3>\nIs the name of the fourth SIMD&FP table register, encoded as \"Rn\" plus 3 modulo 32.", "<Vm>\nIs the name of the SIMD&FP index register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\ninteger regs = UInt(len) + 1;\nboolean is_tbl = (op == '0');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) indices = V[m];\nbits(128*regs) table = Zeros();\nbits(datasize) result;\ninteger index;\n\n// Create table from registers\nfor i = 0 to regs - 1\n    table<128*i+127:128*i> = V[n];\n    n = (n + 1) MOD 32;\n\nresult = if is_tbl then Zeros() else V[d];\nfor i = 0 to elements - 1\n    index = UInt(Elem[indices, i, 8]);\n    if index < 16 * regs then\n        Elem[result, i, 8] = Elem[table, index, 8];\n\nV[d] = result;"}, {"mnemonic": "LD1ROB (scalar plus immediate)", "short_desc": "Contiguous load and replicate thirty-two bytes (immediate index)", "full_desc": "Load thirty-two contiguous bytes to elements of a 256-bit (octaword) vector from the memory address generated by a 64-bit scalar base address and immediate index that is a multiple of 32 in the range -256 to +224 added to the base address.", "syntax": ["LD1ROB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate byte offset, a multiple of 32 in the range -256 to 224, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVEFP64MatMulExt() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\nif VL < 256 then UNDEFINED;\ninteger elements = 256 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low bits only\nbits(256) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * 32;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);"}, {"mnemonic": "STR (predicate)", "short_desc": "Store predicate register", "full_desc": "Store a predicate register to a memory address generated by a 64-bit scalar base, plus an immediate offset in the range -256 to 255 which is multiplied by the current predicate register size in bytes. This instruction is unpredicated.", "syntax": ["STR     <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Pt>\nIs the name of the scalable predicate transfer register, encoded in the \"Pt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -256 to 255, defaulting to 0, encoded in the \"imm9h:imm9l\" fields."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Pt);\ninteger n = UInt(Rn);\ninteger imm = SInt(imm9h:imm9l);", "operation": "CheckSVEEnabled();\ninteger elements = PL DIV 8;\nbits(PL) src;\nbits(64) base;\ninteger offset = imm * elements;\n\nif n == 31 then\n    CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nsrc = P[t];\nboolean aligned = AArch64.CheckAlignment(base + offset, 2, AccType_NORMAL, TRUE);\nfor e = 0 to elements-1\n    AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned] = Elem[src, e, 8];\n    offset = offset + 1;"}, {"mnemonic": "LDRSW (literal)", "short_desc": "Load Register Signed Word (literal)", "full_desc": "Load Register Signed Word (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDRSW  <Xt>, <label>\t; Literal"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<label>\nIs the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\n\noffset = SignExtend(imm19:'00', 64);\nboolean tag_checked = FALSE;", "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);"}, {"mnemonic": "MOV (SIMD&FP scalar, unpredicated)", "short_desc": "Move indexed element or SIMD&FP scalar to vector (unpredicated)", "full_desc": "Unconditionally broadcast the SIMD&FP scalar into each element of the destination vector. This instruction is unpredicated.", "syntax": ["MOV     <Zd>.<T>, <V><n>\t; ", "MOV     <Zd>.<T>, <Zn>.<T>[<imm>]\t; ", "\t; ", "\t; "], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the immediate index, in the range 0 to one less than the number of elements in 512 bits, encoded in \"imm2:tsz\".", "<V>\n", "<n>\nIs the number [0-31] of the source SIMD&FP register, encoded in the \"Zn\" field."]}, {"mnemonic": "RBIT (vector)", "short_desc": "Reverse Bit order (vector)", "full_desc": "Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["RBIT  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nbits(esize) rev;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    for i = 0 to esize-1\n        rev<esize-1-i> = element<i>;\n    Elem[result, e, esize] = rev;\n\nV[d] = result;"}, {"mnemonic": "STR (register, SIMD&FP)", "short_desc": "Store SIMD&FP register (register offset)", "full_desc": "Store SIMD&FP register (register offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended.", "syntax": ["STR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 8-fsreg,STR-8-fsreg", "STR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 8-fsreg,STR-8-fsreg", "STR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 16-fsreg,STR-16-fsreg", "STR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-fsreg,STR-32-fsreg", "STR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-fsreg,STR-64-fsreg", "STR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 128-fsreg,STR-128-fsreg"], "symbols": ["<Bt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Ht>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<extend>\n", "<amount>\nFor the 8-bit variant: is the index shift amount, it must be , encoded in \"S\" as  if omitted, or as  if present.", "<amount>\n", "<amount>\n", "<amount>\n", "<amount>\n"], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UNDEFINED;\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "ORN (shifted register)", "short_desc": "Bitwise OR NOT (shifted register)", "full_desc": "Bitwise OR NOT (shifted register) performs a bitwise (inclusive) OR of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "NEG", "short_desc": "Negate (predicated)", "full_desc": "Negate the signed integer value in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["NEG     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    integer element = SInt(Elem[operand, e, esize]);\n    if ElemP[mask, e, esize] == '1' then\n        element = -element;\n        Elem[result, e, esize] = element<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "MUL (vector)", "short_desc": "Multiply (vector)", "full_desc": "Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif U == '1' && size != '00' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean poly = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if poly then\n        product = PolynomialMult(element1, element2)<esize-1:0>;\n    else\n        product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;"}, {"mnemonic": "ST3 (multiple structures)", "short_desc": "Store multiple 3-element structures from three registers", "full_desc": "Store multiple 3-element structures from three registers. This instruction stores multiple 3-element structures to memory from three SIMD&FP registers, with interleaving. Every element of each register is stored.", "syntax": ["ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; No offset", "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UNDEFINED;\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then UNDEFINED;"}, {"mnemonic": "STNT1B (scalar plus immediate)", "short_desc": "Contiguous store non-temporal bytes from vector (immediate index)", "full_desc": "Contiguous store non-temporal of bytes from elements of a vector register to the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements are not written to memory.", "syntax": ["STNT1B  { <Zt>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nconstant integer mbytes = esize DIV 8;\nbits(VL) src;\nbits(PL) mask = P[g];\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\nsrc = Z[t];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];\n    addr = addr + mbytes;"}, {"mnemonic": "LDRSH (register)", "short_desc": "Load Register Signed Halfword (register)", "full_desc": "Load Register Signed Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRSH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit", "LDRSH  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\n"], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "FCVTMS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTMS  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTMS  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTMS  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTMS  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTMS  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTMS  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "LDR (literal)", "short_desc": "Load Register (literal)", "full_desc": "Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDR  <Wt>, <label>\t; 32-bit", "LDR  <Xt>, <label>\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<label>\nIs the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\n\noffset = SignExtend(imm19:'00', 64);\nboolean tag_checked = FALSE;", "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);"}, {"mnemonic": "BRKA, BRKAS", "short_desc": "Break after first true condition", "full_desc": "Sets destination predicate elements up to and including the first active and true source element to true, then sets subsequent elements to false. Inactive elements in the destination predicate register remain unmodified or are set to zero, depending on whether merging or zeroing predication is selected. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["BRKA    <Pd>.B, <Pg>/<ZM>, <Pn>.B\t; Not setting the condition flags", "BRKAS   <Pd>.B, <Pg>/Z, <Pn>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<ZM>\n", "<Pn>\nIs the name of the source scalable predicate register, encoded in the \"Pn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger d = UInt(Pd);\nboolean merging = (M == '1');\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand  = P[n];\nbits(PL) operand2 = P[d];\nboolean break = FALSE;\nbits(PL) result;\n\nfor e = 0 to elements-1\n    boolean element = ElemP[operand, e, esize] == '1';\n    if ElemP[mask, e, esize] == '1' then\n        ElemP[result, e, esize] = if !break then '1' else '0';\n        break = break || element;\n    elsif merging then\n        ElemP[result, e, esize] = ElemP[operand2, e, esize];\n    else\n        ElemP[result, e, esize] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "BIC (vector, immediate)", "short_desc": "Bitwise bit Clear (vector, immediate)", "full_desc": "Bitwise bit Clear (vector, immediate). This instruction reads each vector element from the destination SIMD&FP register, performs a bitwise AND between each result and the complement of an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit", "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit"], "symbols": ["<Vd>\nIs the name of the SIMD&FP register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<imm8>\nIs an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\".", "<amount>\n", "<amount>\n"], "decode": "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UNDEFINED;\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"}, {"mnemonic": "UQINCH (vector)", "short_desc": "Unsigned saturating increment vector by multiple of 16-bit predicate constraint element count", "full_desc": "Determines the number of active 16-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment all destination vector elements. The results are saturated to the 16-bit unsigned integer range.", "syntax": ["UQINCH  <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "FCMGT (register)", "short_desc": "Floating-point Compare Greater than (vector)", "full_desc": "Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FCMGT  <Hd>, <Hn>, <Hm>\t; Scalar half precision", "FCMGT  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision", "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision", "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FMAXNM (scalar)", "short_desc": "Floating-point Maximum Number (scalar)", "full_desc": "Floating-point Maximum Number (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the larger of the two floating-point values to the destination SIMD&FP register.", "syntax": ["FMAXNM  <Hd>, <Hn>, <Hm>\t; Half-precision", "FMAXNM  <Sd>, <Sn>, <Sm>\t; Single-precision", "FMAXNM  <Dd>, <Dn>, <Dm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SUB (vectors, predicated)", "short_desc": "Subtract vectors (predicated)", "full_desc": "Subtract active elements of the second source vector from corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SUB     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "FADD (vectors, predicated)", "short_desc": "Floating-point add vector (predicated)", "full_desc": "Add active floating-point elements of the second source vector to corresponding floating-point elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FADD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPAdd(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "MOV (to/from SP)", "short_desc": "Move between register and stack pointer", "syntax": ["MOV  <Wd|WSP>, <Wn|WSP>\t; 32-bit", "MOV  <Xd|SP>, <Xn|SP>\t; 64-bit"], "symbols": ["<Wd|WSP>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wn|WSP>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "FEXPA", "short_desc": "Floating-point exponential accelerator", "full_desc": "The  instruction accelerates the polynomial series calculation of the  function.", "syntax": ["FEXPA   <Zd>.<T>, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand  = Z[n];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPExpA(element);\n\nZ[d] = result;"}, {"mnemonic": "ADDS (shifted register)", "short_desc": "Add (shifted register), setting flags", "full_desc": "Add (shifted register), setting flags, adds a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ADDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "ADDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then UNDEFINED;\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "NOT", "short_desc": "Bitwise NOT (vector)", "full_desc": "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["NOT  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = NOT(element);\n\nV[d] = result;"}, {"mnemonic": "MNEG", "short_desc": "Multiply-Negate", "full_desc": "Multiply-Negate multiplies two register values, negates the product, and writes the result to the destination register.", "syntax": ["MNEG  <Wd>, <Wn>, <Wm>\t; 32-bit", "MNEG  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "STLXRH", "short_desc": "Store-Release Exclusive Register Halfword", "full_desc": "Store-Release Exclusive Register Halfword stores a halfword from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See . The memory access is atomic. The instruction also has memory ordering semantics as described in . For information about memory accesses see .", "syntax": ["STLXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "CMLE (zero)", "short_desc": "Compare signed Less than or Equal to zero (vector)", "full_desc": "Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMLE  <V><d>, <V><n>, #0\t; Scalar", "CMLE  <Vd>.<T>, <Vn>.<T>, #0\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "UABDL, UABDL2", "short_desc": "Unsigned Absolute Difference Long", "full_desc": "Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.", "syntax": ["UABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "WFE", "short_desc": "Wait For Event", "full_desc": "Wait For Event is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. Wakeup events include the event signaled as a result of executing the  instruction on any PE in the multiprocessor system. For more information, see .", "syntax": ["WFE\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "UMAXV", "short_desc": "Unsigned maximum reduction to scalar", "full_desc": "Unsigned maximum horizontally across all lanes of a vector, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as zero.", "syntax": ["UMAXV   <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\ninteger maximum = if unsigned then 0 else -(2^(esize-1));\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer element = Int(Elem[operand, e, esize], unsigned);\n        maximum = Max(maximum, element);\n\nV[d] = maximum<esize-1:0>;"}, {"mnemonic": "SUB (shifted register)", "short_desc": "Subtract (shifted register)", "full_desc": "Subtract (shifted register) subtracts an optionally-shifted register value from a register value, and writes the result to the destination register.", "syntax": ["SUB  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "SUB  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then UNDEFINED;\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "ST1D (vector plus immediate)", "short_desc": "Scatter store doublewords from a vector (immediate index)", "full_desc": "Scatter store of doublewords from the active elements of a vector register to the memory addresses generated by a vector base plus immediate index. The index is a multiple of 8 in the range 0 to 248. Inactive elements are not written to memory.", "syntax": ["ST1D    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 248, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(VL) src = Z[t];\nbits(PL) mask = P[g];\nbits(64) addr;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;"}, {"mnemonic": "ST1D (scalar plus scalar)", "short_desc": "Contiguous store doublewords from vector (scalar index)", "full_desc": "Contiguous store of doublewords from elements of a vector register to the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 8 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements are not written to memory.", "syntax": ["ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nbits(VL) src = Z[t];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;\n    offset = offset + 1;"}, {"mnemonic": "LD1W (scalar plus immediate)", "short_desc": "Contiguous load unsigned words to vector (immediate index)", "full_desc": "Contiguous load of unsigned words to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\nboolean unsigned = TRUE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "GMI", "short_desc": "Tag Mask Insert", "full_desc": "Tag Mask Insert inserts the tag in the first source register into the excluded set specified in the second source register, writing the new excluded set to the destination register.", "syntax": ["GMI  <Xd>, <Xn|SP>, <Xm>\t; Integer"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Xd\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Xm\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger d = UInt(Xd);\ninteger n = UInt(Xn);\ninteger m = UInt(Xm);", "operation": "bits(64) address = if n == 31 then SP[] else X[n];\nbits(64) mask = X[m];\nbits(4) tag = AArch64.AllocationTagFromAddress(address);\n\nmask<UInt(tag)> = '1';\nX[d] = mask;"}, {"mnemonic": "SABD", "short_desc": "Signed Absolute Difference", "full_desc": "Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "LD4 (multiple structures)", "short_desc": "Load multiple 4-element structures to four registers", "full_desc": "Load multiple 4-element structures to four registers. This instruction loads multiple 4-element structures from memory and writes the result to the four SIMD&FP registers, with de-interleaving.", "syntax": ["LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; No offset", "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Vt4>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UNDEFINED;\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then UNDEFINED;"}, {"mnemonic": "TRN1, TRN2 (predicates)", "short_desc": "Interleave even or odd elements from two predicates", "full_desc": "Interleave alternating even or odd-numbered elements from the first and second source predicates and place in elements of the destination predicate. This instruction is unpredicated.", "syntax": ["TRN1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Even", "TRN2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Odd"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\ninteger part = 0;", "operation": "CheckSVEEnabled();\ninteger pairs = VL DIV (esize * 2);\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize DIV 8] = Elem[operand1, 2*p+part, esize DIV 8];\n    Elem[result, 2*p+1, esize DIV 8] = Elem[operand2, 2*p+part, esize DIV 8];\n\nP[d] = result;"}, {"mnemonic": "SUBG", "short_desc": "Subtract with Tag", "full_desc": "Subtract with Tag subtracts an immediate value scaled by the Tag granule from the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag.", "syntax": ["SUBG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>\t; Integer"], "symbols": ["<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Xd\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<uimm6>\nIs an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the \"uimm6\" field.", "<uimm4>\nIs an unsigned immediate, in the range 0 to 15, encoded in the \"uimm4\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger d = UInt(Xd);\ninteger n = UInt(Xn);\nbits(4) tag_offset = uimm4;\nbits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);\nboolean ADD = FALSE;", "operation": "bits(64) operand1 = if n == 31 then SP[] else X[n];\nbits(4) start_tag = AArch64.AllocationTagFromAddress(operand1);\nbits(16) exclude = GCR_EL1.Exclude;\nbits(64) result;\nbits(4) rtag;\n\nif AArch64.AllocationTagAccessIsEnabled(AccType_NORMAL) then\n    rtag = AArch64.ChooseNonExcludedTag(start_tag, tag_offset, exclude);\nelse\n    rtag = '0000';\n\nif ADD then\n    (result, -) = AddWithCarry(operand1, offset, '0');\nelse\n    (result, -) = AddWithCarry(operand1, NOT(offset), '1');\n\nresult = AArch64.AddressWithAllocationTag(result, AccType_NORMAL, rtag);\n\nif d == 31 then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LDURB", "short_desc": "Load Register Byte (unscaled)", "full_desc": "Load Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDURB  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "STNP", "short_desc": "Store Pair of Registers, with non-temporal hint", "full_desc": "Store Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about memory accesses, see . For information about Non-temporal pair instructions, see .", "syntax": ["STNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit", "STNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit"], "symbols": ["<Wt1>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8."], "decode": "boolean wback  = FALSE;\nboolean postindex = FALSE;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_STREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc<0> == '1' then UNDEFINED;\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\nboolean tag_checked = wback || n != 31;"}, {"mnemonic": "REV64", "short_desc": "Reverse elements in 64-bit doublewords (vector)", "full_desc": "Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["REV64  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\n// size=esize:   B(0),  H(1),  S(1), D(S)\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\n\n// op=REVx: 64(0), 32(1), 16(2)\nbits(2) op = o0:U; \n\n// => op+size: \n//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X\n//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X\n//    16+B = 2, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n// => 3-(op+size) (index bits in group)\n//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X\n//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X\n//    16+B = 1, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n\n// index bits within group: 1, 2, 3\nif UInt(op)+UInt(size) >= 3 then UNDEFINED;\n\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;"}, {"mnemonic": "SUBP", "short_desc": "Subtract Pointer", "full_desc": "Subtract Pointer subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64-bits, and writes the result to the destination register.", "syntax": ["SUBP  <Xd>, <Xn|SP>, <Xm|SP>\t; Integer"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Xd\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xm|SP>\nIs the 64-bit name of the second general-purpose source register or stack pointer, encoded in the \"Xm\" field."], "decode": "integer d = UInt(Xd);\ninteger n = UInt(Xn);\ninteger m = UInt(Xm);\nboolean setflags = FALSE;", "operation": "bits(64) operand1 = if n == 31 then SP[] else X[n];\nbits(64) operand2 = if m == 31 then SP[] else X[m];\noperand1 = SignExtend(operand1<55:0>, 64);\noperand2 = SignExtend(operand2<55:0>, 64);\n\nbits(64) result;\nbits(4) nzcv;\n\noperand2 = NOT(operand2);\n(result, nzcv) = AddWithCarry(operand1, operand2, '1');\n\nif setflags then\n    PSTATE.<N,Z,C,V> = nzcv;\nX[d] = result;"}, {"mnemonic": "LD3B (scalar plus immediate)", "short_desc": "Contiguous load three-byte structures to three vectors (immediate index)", "full_desc": "Contiguous load three-byte structures, each to the same element number in three vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 3 in the range -24 to 21 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "DGH", "short_desc": "Data Gathering Hint", "full_desc": "DGH is a hint instruction. A  instruction is not expected to be performance optimal to merge memory accesses with Normal Non-cacheable or Device-GRE attributes appearing in program order before the hint instruction with any memory accesses appearing after the hint instruction into a single memory transaction on an interconnect.", "syntax": ["DGH\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "FCCMPE", "short_desc": "Floating-point Conditional signaling Compare (scalar)", "full_desc": "Floating-point Conditional signaling Compare (scalar). This instruction compares the two SIMD&FP source register values and writes the result to the .{N, Z, C, V} flags. If the condition does not pass then the .{N, Z, C, V} flags are set to the flag bit specifier.", "syntax": ["FCCMPE  <Hn>, <Hm>, #<nzcv>, <cond>\t; Half-precision", "FCCMPE  <Sn>, <Sm>, #<nzcv>, <cond>\t; Single-precision", "FCCMPE  <Dn>, <Dm>, #<nzcv>, <cond>\t; Double-precision"], "symbols": ["<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean signal_all_nans = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = V[m];\n\nif ConditionHolds(condition) then\n    flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "SQINCW (scalar)", "short_desc": "Signed saturating increment scalar by multiple of 32-bit predicate constraint element count", "full_desc": "Determines the number of active 32-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQINCW  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "SQINCW  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "RBIT", "short_desc": "Reverse bits (predicated)", "full_desc": "Reverse bits in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["RBIT    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = BitReverse(element);\n\nZ[d] = result;"}, {"mnemonic": "UDIV", "short_desc": "Unsigned divide (predicated)", "full_desc": "Unsigned divide active elements of the first source vector by corresponding elements of the second source vector and destructively place the quotient in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["UDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '0x' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer quotient;\n        if element2 == 0 then\n            quotient = 0;\n        else\n            quotient = RoundTowardsZero(Real(element1) / Real(element2));\n        Elem[result, e, esize] = quotient<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "LDLARB", "short_desc": "Load LOAcquire Register Byte", "full_desc": "Load LOAcquire Register Byte loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["LDLARB  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FMAXV", "short_desc": "Floating-point maximum recursive reduction to scalar", "full_desc": "Floating-point maximum horizontally over all lanes of a vector using a recursive pairwise reduction, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as -Infinity.", "syntax": ["FMAXV   <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(esize) identity = FPInfinity('1');\n\nV[d] = ReducePredicated(ReduceOp_FMAX, operand, mask, identity);"}, {"mnemonic": "LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB", "short_desc": "Atomic bit clear on byte in memory", "full_desc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDCLRAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRAB", "LDCLRALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRALB", "LDCLRB  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRB", "LDCLRLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FCVTZS (scalar, fixed-point)", "short_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTZS  <Wd>, <Hn>, #<fbits>\t; Half-precision to 32-bit", "FCVTZS  <Xd>, <Hn>, #<fbits>\t; Half-precision to 64-bit", "FCVTZS  <Wd>, <Sn>, #<fbits>\t; Single-precision to 32-bit", "FCVTZS  <Xd>, <Sn>, #<fbits>\t; Single-precision to 64-bit", "FCVTZS  <Wd>, <Dn>, #<fbits>\t; Double-precision to 32-bit", "FCVTZS  <Xd>, <Dn>, #<fbits>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<fbits>\nFor the double-precision to 32-bit, half-precision to 32-bit and single-precision to 32-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 32, encoded as 64 minus \"scale\".", "<fbits>\nFor the double-precision to 64-bit, half-precision to 64-bit and single-precision to 64-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus \"scale\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase ftype of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\nif sf == '0' && scale<5> == '0' then UNDEFINED;\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"}, {"mnemonic": "PTEST", "short_desc": "Set condition flags for predicate", "full_desc": "Sets the  (N),  (Z),  (C) condition flags based on the predicate source register, and the V flag to zero.", "syntax": ["PTEST   <Pg>, <Pn>.B\t; SVE"], "symbols": ["<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the source scalable predicate register, encoded in the \"Pn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);", "operation": "CheckSVEEnabled();\nbits(PL) mask = P[g];\nbits(PL) result = P[n];\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);"}, {"mnemonic": "LD4B (scalar plus scalar)", "short_desc": "Contiguous load four-byte structures to four vectors (scalar index)", "full_desc": "Contiguous load four-byte structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register and added to the base address. After each structure access the index value is incremented by four. The index register is not updated by the instruction.", "syntax": ["LD4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "PRFD (scalar plus scalar)", "short_desc": "Contiguous prefetch doublewords (scalar index)", "full_desc": "Contiguous prefetch of doubleword elements from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 8 and added to the base address. After each element prefetch the index value is incremented, but the index register is not updated.", "syntax": ["PRFD    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger esize = 64;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) offset = X[m];\nbits(64) addr;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + (UInt(offset) << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);\n    offset = offset + 1;"}, {"mnemonic": "PRFD (vector plus immediate)", "short_desc": "Gather prefetch doublewords (vector plus immediate)", "full_desc": "Gather prefetch of doublewords from the active memory addresses generated by a vector base plus immediate index. The index is a multiple of 8 in the range 0 to 248. Inactive addresses are not prefetched from memory.", "syntax": ["PRFD    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element", "PRFD    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 248, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 3;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) base;\nbits(64) addr;\nbase = Z[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);"}, {"mnemonic": "UDOT (vectors)", "short_desc": "Unsigned integer dot product", "full_desc": "The unsigned integer dot product instruction computes the dot product of a group of four unsigned 8-bit or 16-bit integer values held in each 32-bit or 64-bit element of the first source vector multiplied by a group of four unsigned 8-bit or 16-bit integer values in the corresponding 32-bit or 64-bit element of the second source vector, and then destructively adds the widened dot product to the corresponding 32-bit or 64-bit element of the destination vector.", "syntax": ["UDOT    <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Tb>\n", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '0x' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) res = Elem[operand3, e, esize];\n    for i = 0 to 3\n        integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n        integer element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        res = res + element1 * element2;\n    Elem[result, e, esize] = res;\n\nZ[da] = result;"}, {"mnemonic": "BFCVT", "short_desc": "Floating-point down convert to BFloat16 format (predicated)", "full_desc": "Convert to BFloat16 from single-precision in each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["BFCVT   <Zd>.H, <Pg>/M, <Zn>.S\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 32;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(32) element = Elem[operand, e, 32];\n    if ElemP[mask, e, 32] == '1' then\n        Elem[result, 2*e, 16] = FPConvertBF(element, FPCR<31:0>);\n        Elem[result, 2*e+1, 16] = Zeros();\n\nZ[d] = result;"}, {"mnemonic": "RADDHN, RADDHN2", "short_desc": "Rounding Add returning High Narrow", "full_desc": "Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.", "syntax": ["RADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"}, {"mnemonic": "STSMAXH, STSMAXLH", "short_desc": "Atomic signed maximum on halfword in memory, without return", "full_desc": "Atomic signed maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.", "syntax": ["STSMAXH  <Ws>, [<Xn|SP>]\t; No memory ordering", "STSMAXLH  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "ADDS (immediate)", "short_desc": "Add (immediate), setting flags", "full_desc": "Add (immediate), setting flags, adds a register value and an optionally-shifted immediate value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ADDS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit", "ADDS  <Xd>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn|WSP>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase sh of\n    when '0' imm = ZeroExtend(imm12, datasize);\n    when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LD1SW (scalar plus immediate)", "short_desc": "Contiguous load signed words to vector (immediate index)", "full_desc": "Contiguous load of signed words to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 32;\nboolean unsigned = FALSE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "MUL (immediate)", "short_desc": "Multiply by immediate (unpredicated)", "full_desc": "Multiply by an immediate each element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is a signed 8-bit value in the range -128 to +127, inclusive. This instruction is unpredicated.", "syntax": ["MUL     <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs the signed immediate operand, in the range -128 to 127, encoded in the \"imm8\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger imm = SInt(imm8);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = SInt(Elem[operand1, e, esize]);\n    Elem[result, e, esize] = (element1 * imm)<esize-1:0>;\n\nZ[dn] = result;"}, {"mnemonic": "SQADD (vectors)", "short_desc": "Signed saturating add vectors (unpredicated)", "full_desc": "Signed saturating add all elements of the second source vector to corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. Each result element is saturated to the N-bit element's signed integer range -2 to (2)-1. This instruction is unpredicated.", "syntax": ["SQADD   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + element2, esize, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "UMLAL, UMLAL2 (by element)", "short_desc": "Unsigned Multiply-Add Long (vector, by element)", "full_desc": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"}, {"mnemonic": "CMP (shifted register)", "short_desc": "Compare (shifted register)", "full_desc": "Compare (shifted register) subtracts an optionally-shifted register value from a register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP  <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "CMP  <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."]}, {"mnemonic": "ORR (immediate)", "short_desc": "Bitwise inclusive OR with immediate (unpredicated)", "full_desc": "Bitwise inclusive OR an immediate with each 64-bit element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is a 64-bit value consisting of a single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction is unpredicated.", "syntax": ["ORR     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<const>\nIs a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger dn = UInt(Zdn);\nbits(64) imm;\n(imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 64;\nbits(VL) operand = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(64) element1 = Elem[operand, e, 64];\n    Elem[result, e, 64] = element1 OR imm;\n\nZ[dn] = result;"}, {"mnemonic": "ADDS (extended register)", "short_desc": "Add (extended register), setting flags", "full_desc": "Add (extended register), setting flags, adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the  register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result.", "syntax": ["ADDS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit", "ADDS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn|WSP>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<R>\n", "<m>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<extend>\n", "<extend>\n", "<amount>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then UNDEFINED;", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH", "short_desc": "Atomic signed minimum on halfword in memory", "full_desc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDSMINAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINAH", "LDSMINALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINALH", "LDSMINH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINH", "LDSMINLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SHA256SU1", "short_desc": "SHA256 schedule update 1", "full_desc": "SHA256 schedule update 1.", "syntax": ["SHA256SU1  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif !HaveSHA256Ext() then UNDEFINED;", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\nbits(128) T0 = operand3<31:0> : operand2<127:32>;\nbits(64) T1;\nbits(32) elt;\n\nT1 = operand3<127:64>;\nfor e = 0 to 1\n    elt = Elem[T1, e, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\n\nT1 = result<63:0>;\nfor e = 2 to 3\n    elt = Elem[T1, e - 2, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\n\nV[d] = result;"}, {"mnemonic": "SQDECD (scalar)", "short_desc": "Signed saturating decrement scalar by multiple of 64-bit predicate constraint element count", "full_desc": "Determines the number of active 64-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQDECD  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "SQDECD  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "FJCVTZS", "short_desc": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero", "full_desc": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero. This instruction converts the double-precision floating-point value in the SIMD&FP source register to a 32-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. If the result is too large to be accommodated as a signed 32-bit integer, then the result is the integer modulo 2, as held in a 32-bit signed integer.", "syntax": ["FJCVTZS  <Wd>, <Dn>\t; Double-precision to 32-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "ABS", "short_desc": "Absolute value (vector)", "full_desc": "Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["ABS  <V><d>, <V><n>\t; Scalar", "ABS  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    Elem[result, e, esize] = element<esize-1:0>;                \n\nV[d] = result;"}, {"mnemonic": "FRINT64X (vector)", "short_desc": "Floating-point Round to 64-bit Integer, using current rounding mode (vector)", "full_desc": "Floating-point Round to 64-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the rounding mode that is determined by the , and writes the result to the SIMD&FP destination register.", "syntax": ["FRINT64X  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFrintExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then UNDEFINED;\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger intsize = if op == '0' then 32 else 64; \nFPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);\n\nV[d] = result;"}, {"mnemonic": "BIC (vectors, unpredicated)", "short_desc": "Bitwise clear vectors (unpredicated)", "full_desc": "Bitwise AND inverted all elements of the second source vector with corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["BIC     <Zd>.D, <Zn>.D, <Zm>.D\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\n\nZ[d] = operand1 AND (NOT operand2);"}, {"mnemonic": "FSQRT (vector)", "short_desc": "Floating-point Square Root (vector)", "full_desc": "Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FSQRT  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FSQRT  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPSqrt(element, FPCR);\n\nV[d] = result;"}, {"mnemonic": "TBZ", "short_desc": "Test bit and Branch if Zero", "full_desc": "Test bit and Branch if Zero compares the value of a test bit with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.", "syntax": ["TBZ  <R><t>, #<imm>, <label>\t; 14-bit signed PC-relative branch offset"], "symbols": ["<R>\n", "<t>\nIs the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in the \"Rt\" field.", "<imm>\nIs the bit number to be tested, in the range 0 to 63, encoded in \"b5:b40\".", "<label>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-32KB, is encoded as \"imm14\" times 4."], "decode": "integer t = UInt(Rt);\n\ninteger datasize = if b5 == '1' then 64 else 32;\ninteger bit_pos = UInt(b5:b40);\nbit bit_val = op;\nbits(64) offset = SignExtend(imm14:'00', 64);", "operation": "bits(datasize) operand = X[t];\n\nif operand<bit_pos> == bit_val then\n    BranchTo(PC[] + offset, BranchType_DIR);"}, {"mnemonic": "FNMSUB", "short_desc": "Floating-point Negated fused Multiply-Subtract (scalar)", "full_desc": "Floating-point Negated fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, subtracts the value of the third SIMD&FP source register, and writes the result to the destination SIMD&FP register.", "syntax": ["FNMSUB  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision", "FNMSUB  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision", "FNMSUB  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Da>\nIs the 64-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ha>\nIs the 16-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Sa>\nIs the 32-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ST1W (vector plus immediate)", "short_desc": "Scatter store words from a vector (immediate index)", "full_desc": "Scatter store of words from the active elements of a vector register to the memory addresses generated by a vector base plus immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive elements are not written to memory.", "syntax": ["ST1W    { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element", "ST1W    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(VL) src = Z[t];\nbits(PL) mask = P[g];\nbits(64) addr;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;"}, {"mnemonic": "ST1W (scalar plus scalar)", "short_desc": "Contiguous store words from vector (scalar index)", "full_desc": "Contiguous store of words from elements of a vector register to the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 4 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements are not written to memory.", "syntax": ["ST1W    { <Zt>.<T> }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size != '1x' then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8 << UInt(size);\ninteger msize = 32;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nbits(VL) src = Z[t];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;\n    offset = offset + 1;"}, {"mnemonic": "LD1D (scalar plus immediate)", "short_desc": "Contiguous load doublewords to vector (immediate index)", "full_desc": "Contiguous load of doublewords to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\nboolean unsigned = TRUE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "FMINP (vector)", "short_desc": "Floating-point Minimum Pairwise (vector)", "full_desc": "Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "TRN1", "short_desc": "Transpose vectors (primary)", "full_desc": "Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.", "syntax": ["TRN1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\n\nV[d] = result;"}, {"mnemonic": "INCB, INCD, INCH, INCW (scalar)", "short_desc": "Increment scalar by multiple of predicate constraint element count", "full_desc": "Determines the number of active elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment the scalar destination.", "syntax": ["INCB    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Byte", "INCD    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Doubleword", "INCH    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Halfword", "INCW    <Xdn>{, <pattern>{, MUL #<imm>}}\t; Word"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(64) operand1 = X[dn];\n\nX[dn] = operand1 + (count * imm);"}, {"mnemonic": "LDFF1SH (vector plus immediate)", "short_desc": "Gather load first-fault signed halfwords to vector (immediate index)", "full_desc": "Gather load with first-faulting behavior of signed halfwords to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 2 in the range 0 to 62. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1SH { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\nboolean unsigned = FALSE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "LDFF1SH (scalar plus scalar)", "short_desc": "Contiguous load first-fault signed halfwords to vector (scalar index)", "full_desc": "Contiguous load with first-faulting behavior of signed halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 2 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDFF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 32-bit element", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + UInt(offset) * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "MLA (by element)", "short_desc": "Multiply-Add to accumulator (vector, by element)", "full_desc": "Multiply-Add to accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values.", "syntax": ["MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\n\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\nV[d] = result;"}, {"mnemonic": "PRFW (scalar plus scalar)", "short_desc": "Contiguous prefetch words (scalar index)", "full_desc": "Contiguous prefetch of word elements from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 4 and added to the base address. After each element prefetch the index value is incremented, but the index register is not updated.", "syntax": ["PRFW    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) offset = X[m];\nbits(64) addr;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + (UInt(offset) << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);\n    offset = offset + 1;"}, {"mnemonic": "PRFW (vector plus immediate)", "short_desc": "Gather prefetch words (vector plus immediate)", "full_desc": "Gather prefetch of words from the active memory addresses generated by a vector base plus immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive addresses are not prefetched from memory.", "syntax": ["PRFW    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element", "PRFW    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 2;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) base;\nbits(64) addr;\nbase = Z[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);"}, {"mnemonic": "SM3TT2A", "short_desc": "SM3TT2A", "full_desc": "SM3TT2A takes three 128-bit vectors from three source SIMD&FP register and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a three-way exclusive OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:", "syntax": ["SM3TT2A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field.", "<imm2>\nIs a 32-bit element indexed out of <Vm>, encoded in \"imm2\"."], "decode": "if !HaveSM3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger i = UInt(imm2);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) Wj;\nbits(128) result; \nbits(32) TT2;\n\nWj = Elem[Vm,i,32];\nTT2 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);\nTT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;\n\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,19); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); \nV[d] = result;"}, {"mnemonic": "MSR (immediate)", "short_desc": "Move immediate value to Special Register", "full_desc": "Move immediate value to Special Register moves an immediate value to selected bits of the PSTATE. For more information, see .", "syntax": ["MSR  <pstatefield>, #<imm>\t; System"], "symbols": ["<pstatefield>\n", "<imm>\nIs a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"CRm\" field."], "decode": "if op1 == '000' && op2 == '000' then SEE \"CFINV\";\nif op1 == '000' && op2 == '001' then SEE \"XAFLAG\";\nif op1 == '000' && op2 == '010' then SEE \"AXFLAG\";\n\nAArch64.CheckSystemAccess('00', op1, '0100', CRm, op2, '11111', '0');\n\nbits(4) operand = CRm;\nPSTATEField field;\n\ncase op1:op2 of\n    when '000 011'\n        if !HaveUAOExt() then\n            UNDEFINED;\n        field = PSTATEField_UAO;\n    when '000 100'\n        if !HavePANExt() then\n            UNDEFINED;\n        field = PSTATEField_PAN;\n    when '000 101' field = PSTATEField_SP;\n    when '011 010'\n        if !HaveDITExt() then\n            UNDEFINED;\n        field = PSTATEField_DIT;\n    when '011 100'\n        if !HaveMTEExt() then\n            UNDEFINED;\n        field = PSTATEField_TCO;\n    when '011 110' field = PSTATEField_DAIFSet;\n    when '011 111' field = PSTATEField_DAIFClr;\n    when '011 001'\n        if !HaveSSBSExt() then\n            UNDEFINED;\n        field = PSTATEField_SSBS;\n    otherwise      UNDEFINED;\n\n// Check that an AArch64 MSR/MRS access to the DAIF flags is permitted\nif PSTATE.EL == EL0 && field IN {PSTATEField_DAIFSet, PSTATEField_DAIFClr}  then\n    if !ELUsingAArch32(EL1) && ((EL2Enabled() && HCR_EL2.<E2H,TGE> == '11') || SCTLR_EL1.UMA == '0') then\n        if EL2Enabled() && !ELUsingAArch32(EL2) && HCR_EL2.TGE == '1' then\n            AArch64.SystemAccessTrap(EL2, 0x18);\n        else\n            AArch64.SystemAccessTrap(EL1, 0x18);", "operation": "case field of\n    when PSTATEField_SSBS\n        PSTATE.SSBS = operand<0>;\n    when PSTATEField_SP\n        PSTATE.SP = operand<0>;\n    when PSTATEField_DAIFSet\n        PSTATE.D = PSTATE.D OR operand<3>;\n        PSTATE.A = PSTATE.A OR operand<2>;\n        PSTATE.I = PSTATE.I OR operand<1>;\n        PSTATE.F = PSTATE.F OR operand<0>;\n    when PSTATEField_DAIFClr\n        PSTATE.D = PSTATE.D AND NOT(operand<3>);\n        PSTATE.A = PSTATE.A AND NOT(operand<2>);\n        PSTATE.I = PSTATE.I AND NOT(operand<1>);\n        PSTATE.F = PSTATE.F AND NOT(operand<0>);\n    when PSTATEField_PAN\n        PSTATE.PAN = operand<0>;\n    when PSTATEField_UAO\n        PSTATE.UAO = operand<0>;\n    when PSTATEField_DIT\n        PSTATE.DIT = operand<0>;\n    when PSTATEField_TCO\n        PSTATE.TCO = operand<0>;"}, {"mnemonic": "FMLAL, FMLAL2 (by element)", "short_desc": "Floating-point fused Multiply-Add Long to accumulator (by element)", "full_desc": "Floating-point fused Multiply-Add Long to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.", "syntax": ["FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]\t; FMLAL", "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]\t; FMLAL2"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<index>\nIs the element index, encoded in the \"H:L:M\" fields."], "decode": "if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.\nif sz == '1' then UNDEFINED;\ninteger index = UInt(H:L:M); \n\ninteger esize = 32;\ninteger datasize = if Q=='1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (S == '1');\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize DIV 2) operand1 = Vpart[n,part];\nbits(128) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize DIV 2) element1;\nbits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize DIV 2];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "UABA", "short_desc": "Unsigned Absolute difference and Accumulate", "full_desc": "Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.", "syntax": ["UABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "BIF", "short_desc": "Bitwise Insert if False", "full_desc": "Bitwise Insert if False. This instruction inserts each bit from the first source SIMD&FP register into the destination SIMD&FP register if the corresponding bit of the second source SIMD&FP register is 0, otherwise leaves the bit in the destination register unchanged.", "syntax": ["BIF  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"}, {"mnemonic": "LD4R", "short_desc": "Load single 4-element structure and Replicate to all lanes of four registers", "full_desc": "Load single 4-element structure and Replicate to all lanes of four registers. This instruction loads a 4-element structure from memory and replicates the structure to all the lanes of the four SIMD&FP registers.", "syntax": ["LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; No offset", "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Vt4>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "STSET, STSETL", "short_desc": "Atomic bit set on word or doubleword in memory, without return", "full_desc": "Atomic bit set on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.", "syntax": ["STSET  <Ws>, [<Xn|SP>]\t; 32-bit LDSET alias", "STSETL  <Ws>, [<Xn|SP>]\t; 32-bit LDSETL alias", "STSET  <Xs>, [<Xn|SP>]\t; 64-bit LDSET alias", "STSETL  <Xs>, [<Xn|SP>]\t; 64-bit LDSETL alias"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "MOVS (predicated)", "short_desc": "Move predicates (zeroing), setting the condition flags", "full_desc": "Read active elements from the source predicate and place in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["MOVS    <Pd>.B, <Pg>/Z, <Pn>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field."]}, {"mnemonic": "ST3B (scalar plus scalar)", "short_desc": "Contiguous store three-byte structures from three vectors (scalar index)", "full_desc": "Contiguous store three-byte structures, each from the same element number in three vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register and added to the base address. After each structure access the index value is incremented by three. The index register is not updated by the instruction.", "syntax": ["ST3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "ERET", "short_desc": "Exception Return", "full_desc": "Exception Return using the ELR and SPSR for the current Exception level. When executed, the PE restores  from the SPSR, and branches to the address held in the ELR.", "syntax": ["ERET\t; System"], "symbols": [], "decode": "if PSTATE.EL == EL0 then UNDEFINED;\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\n\nif !pac && op4 != '00000' then\n    UNDEFINED;\nelsif pac && (!HavePACExt() || op4 != '11111') then\n    UNDEFINED;\n\nif Rn != '11111' then \n    UNDEFINED;", "operation": "AArch64.CheckForERetTrap(pac, use_key_a);\nbits(64) target = ELR[];\nboolean auth_then_branch = TRUE;\n\nif pac then\n    if use_key_a then\n        target = AuthIA(ELR[], SP[], auth_then_branch);\n    else\n        target = AuthIB(ELR[], SP[], auth_then_branch);\n\nAArch64.ExceptionReturn(target, SPSR[]);"}, {"mnemonic": "FNEG (scalar)", "short_desc": "Floating-point Negate (scalar)", "full_desc": "Floating-point Negate (scalar). This instruction negates the value in the SIMD&FP source register and writes the result to the SIMD&FP destination register.", "syntax": ["FNEG  <Hd>, <Hn>\t; Half-precision", "FNEG  <Sd>, <Sn>\t; Single-precision", "FNEG  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"}, {"mnemonic": "UXTB, UXTH, UXTW", "short_desc": "Unsigned byte / halfword / word extend (predicated)", "full_desc": "Zero-extend the least-significant sub-element of each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["UXTB    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Byte", "UXTH    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Halfword", "UXTW    <Zd>.D, <Pg>/M, <Zn>.D\t; Word"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger s_esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Extend(element<s_esize-1:0>, esize, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "INSR (scalar)", "short_desc": "Insert general-purpose register in shifted vector", "full_desc": "Shift the destination vector left by one element, and then place a copy of the least-significant bits of the general-purpose register in element 0 of the destination vector. This instruction is unpredicated.", "syntax": ["INSR    <Zdn>.<T>, <R><m>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<R>\n", "<m>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Rm);", "operation": "CheckSVEEnabled();\nbits(VL) dest = Z[dn];\nbits(esize) src = X[m];\nZ[dn] = dest<VL-esize-1:0> : src;"}, {"mnemonic": "SUBS (shifted register)", "short_desc": "Subtract (shifted register), setting flags", "full_desc": "Subtract (shifted register), setting flags, subtracts an optionally-shifted register value from a register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["SUBS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "SUBS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then UNDEFINED;\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "ST4B (scalar plus immediate)", "short_desc": "Contiguous store four-byte structures from four vectors (immediate index)", "full_desc": "Contiguous store four-byte structures, each from the same element number in four vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 4 in the range -32 to 28 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "LD3R", "short_desc": "Load single 3-element structure and Replicate to all lanes of three registers", "full_desc": "Load single 3-element structure and Replicate to all lanes of three registers. This instruction loads a 3-element structure from memory and replicates the structure to all the lanes of the three SIMD&FP registers.", "syntax": ["LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; No offset", "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "PRFB (scalar plus vector)", "short_desc": "Gather prefetch bytes (scalar plus vector)", "full_desc": "Gather prefetch of bytes from the active memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally sign or zero-extended from 32 to 64 bits. Inactive addresses are not prefetched from memory.", "syntax": ["PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit scaled offset", "PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked scaled offset", "PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit scaled offset"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger offs_size = 32;\nboolean offs_unsigned = (xs == '0');\ninteger scale = 0;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);"}, {"mnemonic": "UQRSHRN, UQRSHRN2", "short_desc": "Unsigned saturating Rounded Shift Right Narrow (immediate)", "full_desc": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see .", "syntax": ["UQRSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar", "UQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then UNDEFINED;\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "URSHR", "short_desc": "Unsigned Rounding Shift Right (immediate)", "full_desc": "Unsigned Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see .", "syntax": ["URSHR  <V><d>, <V><n>, #<shift>\t; Scalar", "URSHR  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "EXT", "short_desc": "Extract vector from pair of vectors", "full_desc": "Extract vector from pair of vectors. This instruction extracts the lowest vector elements from the second source SIMD&FP register and the highest vector elements from the first source SIMD&FP register, concatenates the results into a vector, and writes the vector to the destination SIMD&FP register vector. The index value specifies the lowest vector element to extract from the first source register, and consecutive elements are extracted from the first, then second, source registers until the destination vector is filled.", "syntax": ["EXT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<index>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif Q == '0' && imm4<3> == '1' then UNDEFINED;\n\ninteger datasize = if Q == '1' then 128 else 64;\ninteger position = UInt(imm4) << 3;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) hi = V[m];\nbits(datasize) lo = V[n];\nbits(datasize*2) concat = hi : lo;\n\nV[d] = concat<position+datasize-1:position>;"}, {"mnemonic": "UUNPKHI, UUNPKLO", "short_desc": "Unsigned unpack and extend half of vector", "full_desc": "Unpack elements from the lowest or highest half of the source vector and then zero-extend them to place in elements of twice their size within the destination vector. This instruction is unpredicated.", "syntax": ["UUNPKHI <Zd>.<T>, <Zn>.<Tb>\t; High half", "UUNPKLO <Zd>.<T>, <Zn>.<Tb>\t; Low half"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Tb>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\nboolean unsigned = TRUE;\nboolean hi = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger hsize = esize DIV 2;\nbits(VL) operand = Z[n];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(hsize) element = if hi then Elem[operand, e + elements, hsize] else Elem[operand, e, hsize];\n    Elem[result, e, esize] = Extend(element, esize, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "FCMLA", "short_desc": "Floating-point Complex Multiply Accumulate", "full_desc": "Floating-point Complex Multiply Accumulate.", "syntax": ["FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<rotate>\n"], "decode": "if !HaveFCADDExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' then UNDEFINED;\nif Q == '0' && size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\nif !HaveFP16Ext() && esize == 16 then UNDEFINED;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) element3;\nbits(esize) element4;\n\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '00'\n            element1 = Elem[operand2, e*2, esize]; \n            element2 = Elem[operand1, e*2, esize];\n            element3 = Elem[operand2, e*2+1, esize];\n            element4 = Elem[operand1, e*2, esize];\n        when '01'\n            element1 = FPNeg(Elem[operand2, e*2+1, esize]); \n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = Elem[operand2, e*2, esize];\n            element4 = Elem[operand1, e*2+1, esize];\n        when '10'\n            element1 = FPNeg(Elem[operand2, e*2, esize]); \n            element2 = Elem[operand1, e*2, esize];\n            element3 = FPNeg(Elem[operand2, e*2+1, esize]);\n            element4 = Elem[operand1, e*2, esize];\n        when '11'\n            element1 = Elem[operand2, e*2+1, esize]; \n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = FPNeg(Elem[operand2, e*2, esize]);\n            element4 = Elem[operand1, e*2+1, esize];\n\n    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2,   esize], element2, element1, FPCR);\n    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);\n\nV[d] = result;"}, {"mnemonic": "LDR (vector)", "short_desc": "Load vector register", "full_desc": "Load a vector register from a memory address generated by a 64-bit scalar base, plus an immediate offset in the range -256 to 255 which is multiplied by the current vector register size in bytes. This instruction is unpredicated.", "syntax": ["LDR     <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -256 to 255, defaulting to 0, encoded in the \"imm9h:imm9l\" fields."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger imm = SInt(imm9h:imm9l);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 8;\nbits(64) base;\ninteger offset = imm * elements;\nbits(VL) result;\n\nif n == 31 then\n    CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nboolean aligned = AArch64.CheckAlignment(base + offset, 16, AccType_NORMAL, FALSE);\nfor e = 0 to elements-1\n    Elem[result, e, 8] = AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned];\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "STR (immediate, SIMD&FP)", "short_desc": "Store SIMD&FP register (immediate offset)", "full_desc": "Store SIMD&FP register (immediate offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an immediate offset.", "syntax": ["STR  <Bt>, [<Xn|SP>], #<simm>\t; 8-bit", "STR  <Ht>, [<Xn|SP>], #<simm>\t; 16-bit", "STR  <St>, [<Xn|SP>], #<simm>\t; 32-bit", "STR  <Dt>, [<Xn|SP>], #<simm>\t; 64-bit", "STR  <Qt>, [<Xn|SP>], #<simm>\t; 128-bit", "STR  <Bt>, [<Xn|SP>, #<simm>]!\t; 8-bit", "STR  <Ht>, [<Xn|SP>, #<simm>]!\t; 16-bit", "STR  <St>, [<Xn|SP>, #<simm>]!\t; 32-bit", "STR  <Dt>, [<Xn|SP>, #<simm>]!\t; 64-bit", "STR  <Qt>, [<Xn|SP>, #<simm>]!\t; 128-bit", "STR  <Bt>, [<Xn|SP>{, #<pimm>}]\t; 8-bit", "STR  <Ht>, [<Xn|SP>{, #<pimm>}]\t; 16-bit", "STR  <St>, [<Xn|SP>{, #<pimm>}]\t; 32-bit", "STR  <Dt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit", "STR  <Qt>, [<Xn|SP>{, #<pimm>}]\t; 128-bit"], "symbols": ["<Bt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Ht>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nFor the 8-bit variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<pimm>\nFor the 16-bit variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2.", "<pimm>\nFor the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4.", "<pimm>\nFor the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8.", "<pimm>\nFor the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range 0 to 65520, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/16."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UNDEFINED;\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "UQADD (immediate)", "short_desc": "Unsigned saturating add immediate (unpredicated)", "full_desc": "Unsigned saturating add of an unsigned immediate to each element of the source vector, and destructively place the results in the corresponding elements of the source vector. Each result element is saturated to the N-bit element's unsigned integer range 0 to (2)-1. This instruction is unpredicated.", "syntax": ["UQADD   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger imm = UInt(imm8);\nif sh == '1' then imm = imm << 8;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + imm, esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "ORN, ORNS (predicates)", "short_desc": "Bitwise inclusive OR inverted predicate", "full_desc": "Bitwise inclusive OR inverted active elements of the second source predicate with corresponding elements of the first source predicate and place the results in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["ORN     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags", "ORNS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bit element1 = ElemP[operand1, e, esize];\n    bit element2 = ElemP[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        ElemP[result, e, esize] = element1 OR (NOT element2);\n    else\n        ElemP[result, e, esize] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "LDRSB (immediate)", "short_desc": "Load Register Signed Byte (immediate)", "full_desc": "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends it to either 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see .", "syntax": ["LDRSB  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit", "LDRSB  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit", "LDRSB  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit", "LDRSB  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit", "LDRSB  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit", "LDRSB  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nIs the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "SQINCP (vector)", "short_desc": "Signed saturating increment vector by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to increment all destination vector elements. The results are saturated to the element signed integer range.", "syntax": ["SQINCP  <Zdn>.<T>, <Pm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Zdn);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(PL) operand2 = P[m];\nbits(VL) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\nfor e = 0 to elements-1\n    integer element = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element + count, esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "USMMLA (vector)", "short_desc": "Unsigned and signed 8-bit integer matrix multiply-accumulate (vector)", "full_desc": "Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element.", "syntax": ["USMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveInt8MatMulExt() then UNDEFINED;\ncase B:U of\n    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;\n    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;\n    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;\n    when '11' UNDEFINED;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(128) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(128) addend   = V[d];\n\nV[d] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);"}, {"mnemonic": "CLASTB (vectors)", "short_desc": "Conditionally extract last element to vector register", "full_desc": "From the second source vector register extract the last active element, and then replicate that element to destructively fill the destination and first source vector.", "syntax": ["CLASTB  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean isBefore = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\ninteger last = LastActiveElement(mask, esize);\n\nif last < 0 then\n    result = operand1;\nelse\n    if !isBefore then\n        last = last + 1;\n        if last >= elements then last = 0;\n    for e = 0 to elements-1\n        Elem[result, e, esize] = Elem[operand2, last, esize];\n\nZ[dn] = result;"}, {"mnemonic": "FRINT32Z (vector)", "short_desc": "Floating-point Round to 32-bit Integer toward Zero (vector)", "full_desc": "Floating-point Round to 32-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINT32Z  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFrintExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then UNDEFINED;\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger intsize = if op == '0' then 32 else 64; \nFPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);\n\nV[d] = result;"}, {"mnemonic": "LDFF1H (scalar plus scalar)", "short_desc": "Contiguous load first-fault unsigned halfwords to vector (scalar index)", "full_desc": "Contiguous load with first-faulting behavior of unsigned halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 2 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDFF1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 16-bit element", "LDFF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 32-bit element", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 16;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + UInt(offset) * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "SMSUBL", "short_desc": "Signed Multiply-Subtract Long", "full_desc": "Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["SMSUBL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xa>\nIs the 64-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"}, {"mnemonic": "LDFF1H (vector plus immediate)", "short_desc": "Gather load first-fault unsigned halfwords to vector (immediate index)", "full_desc": "Gather load with first-faulting behavior of unsigned halfwords to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 2 in the range 0 to 62. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1H  { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "LD1RH", "short_desc": "Load and broadcast unsigned halfword to vector", "full_desc": "Load a single unsigned halfword from a memory address generated by a 64-bit scalar base address plus an immediate offset which is a multiple of 2 in the range 0 to 126.", "syntax": ["LD1RH   { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 16-bit element", "LD1RH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element", "LD1RH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 126, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 16;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\ninteger last = LastActiveElement(mask, esize);\nif last >= 0 then\n    addr = base + offset * mbytes;\n    data = Mem[addr, mbytes, AccType_NORMAL];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "FMLS (vectors)", "short_desc": "Floating-point fused multiply-subtract vectors (predicated), writing addend [Zda = Zda + -Zn * Zm]", "full_desc": "Multiply the corresponding active floating-point elements of the first and second source vectors and subtract from elements of the third source (addend) vector without intermediate rounding. Destructively place the results in the destination and third source (addend) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMLS    <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean op1_neg = TRUE;\nboolean op3_neg = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    bits(esize) element3 = Elem[operand3, e, esize];\n\n    if ElemP[mask, e, esize] == '1' then\n        if op1_neg then element1 = FPNeg(element1);\n        if op3_neg then element3 = FPNeg(element3);\n        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element3;\n\nZ[da] = result;"}, {"mnemonic": "MOVPRFX (unpredicated)", "short_desc": "Move prefix (unpredicated)", "full_desc": "The unpredicated  instruction is a hint to hardware that the instruction may be combined with the destructive instruction which follows it in program order to create a single constructive operation. Since it is a hint it is also permitted to be implemented as a discrete vector copy, and the result of executing the pair of instructions with or without combining is identical. The choice of combined versus discrete operation may vary dynamically.", "syntax": ["MOVPRFX <Zd>, <Zn>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\nbits(VL) result = Z[n];\nZ[d] = result;"}, {"mnemonic": "UDOT (vector)", "short_desc": "Dot Product unsigned arithmetic (vector)", "full_desc": "Dot Product unsigned arithmetic (vector). This instruction performs the dot product of the four unsigned 8-bit elements in each 32-bit element of the first source register with the four unsigned 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveDOTPExt() then UNDEFINED;\nif size!= '10' then UNDEFINED;\nboolean signed = (U=='0');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nresult = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3 \n        if signed then\n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        res = res + element1 * element2; \n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nV[d] = result;"}, {"mnemonic": "SDOT (by element)", "short_desc": "Dot Product signed arithmetic (vector, by element)", "full_desc": "Dot Product signed arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<index>\nIs the element index, encoded in the \"H:L\" fields."], "decode": "if !HaveDOTPExt() then UNDEFINED;\nif size  != '10' then UNDEFINED;\nboolean signed = (U=='0');\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\ninteger index = UInt(H:L);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(datasize) result = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3\n        if signed then  \n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        res = res + element1 * element2; \n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nV[d] = result;"}, {"mnemonic": "SSBB", "short_desc": "Speculative Store Bypass Barrier", "full_desc": "Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing earlier stores to the same virtual address under certain conditions.", "syntax": ["SSBB\t; System"], "symbols": [], "decode": "// No additional decoding required", "operation": "SpeculativeStoreBypassBarrierToVA();"}, {"mnemonic": "LDEORB, LDEORAB, LDEORALB, LDEORLB", "short_desc": "Atomic exclusive OR on byte in memory", "full_desc": "Atomic exclusive OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDEORAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORAB", "LDEORALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORALB", "LDEORB  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORB", "LDEORLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "MOV (to general)", "short_desc": "Move vector element to general-purpose register", "full_desc": "Move vector element to general-purpose register. This instruction reads the unsigned integer from the source SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register.", "syntax": ["MOV  <Wd>, <Vn>.S[<index>]\t; 32-bit", "MOV  <Xd>, <Vn>.D[<index>]\t; 64-reg,UMOV-64-reg"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<index>\nFor the 32-bit variant: is the element index encoded in \"imm5<4:3>\".", "<index>\nFor the 64-reg,UMOV-64-reg variant: is the element index encoded in \"imm5<4>\"."]}, {"mnemonic": "ZIP2", "short_desc": "Zip vectors (secondary)", "full_desc": "Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.", "syntax": ["ZIP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger base = part * pairs;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\n\nV[d] = result;"}, {"mnemonic": "BFDOT (vectors)", "short_desc": "BFloat16 floating-point dot product", "full_desc": "The BFloat16 floating-point (BF16) dot product instruction computes the dot product of a pair of BF16 values held in each 32-bit element of the first source vector multiplied by a pair of BF16 values in the corresponding 32-bit element of the second source vector, and then destructively adds the single-precision dot product to the corresponding single-precision element of the destination vector.", "syntax": ["BFDOT   <Zda>.S, <Zn>.H, <Zm>.H\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 32;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];\n    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];\n    bits(16) elt2_a = Elem[operand2, 2 * e + 0, 16];\n    bits(16) elt2_b = Elem[operand2, 2 * e + 1, 16];\n\n    bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));\n    Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);\n\nZ[da] = result;"}, {"mnemonic": "LSLV", "short_desc": "Logical Shift Left Variable", "full_desc": "Logical Shift Left Variable shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted.", "syntax": ["LSLV  <Wd>, <Wn>, <Wm>\t; 32-bit", "LSLV  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);", "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"}, {"mnemonic": "LD1RSH", "short_desc": "Load and broadcast signed halfword to vector", "full_desc": "Load a single signed halfword from a memory address generated by a 64-bit scalar base address plus an immediate offset which is a multiple of 2 in the range 0 to 126.", "syntax": ["LD1RSH  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element", "LD1RSH  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 126, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\nboolean unsigned = FALSE;\ninteger offset = UInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\ninteger last = LastActiveElement(mask, esize);\nif last >= 0 then\n    addr = base + offset * mbytes;\n    data = Mem[addr, mbytes, AccType_NORMAL];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "UDOT (indexed)", "short_desc": "Unsigned integer indexed dot product", "full_desc": "The unsigned integer indexed dot product instruction computes the dot product of a group of four unsigned 8-bit or 16-bit integer values held in each 32-bit or 64-bit element of the first source vector multiplied by a group of four unsigned 8-bit or 16-bit integer values in an indexed 32-bit or 64-bit element of the second source vector, and then destructively adds the widened dot product to the corresponding 32-bit or 64-bit element of the destination vector.", "syntax": ["UDOT    <Zda>.S, <Zn>.B, <Zm>.B[<imm>]\t; 32-bit", "UDOT    <Zda>.D, <Zn>.H, <Zm>.H[<imm>]\t; 64-bit"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nFor the 32-bit variant: is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zm>\nFor the 64-bit variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<imm>\nFor the 32-bit variant: is the immediate index of a quadtuplet of four 8-bit elements within each 128-bit vector segment, in the range 0 to 3, encoded in the \"i2\" field.", "<imm>\nFor the 64-bit variant: is the immediate index of a quadtuplet of four 16-bit elements within each 128-bit vector segment, in the range 0 to 1, encoded in the \"i1\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger index = UInt(i2);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger eltspersegment = 128 DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = segmentbase + index;\n    bits(esize) res = Elem[operand3, e, esize];\n    for i = 0 to 3\n        integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n        integer element2 = UInt(Elem[operand2, 4 * s + i, esize DIV 4]);\n        res = res + element1 * element2;\n    Elem[result, e, esize] = res;\n\nZ[da] = result;"}, {"mnemonic": "SM3PARTW1", "short_desc": "SM3PARTW1", "full_desc": "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers and returns a 128-bit result in the destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information.", "syntax": ["SM3PARTW1  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveSM3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) result; \n\nresult<95:0> = (Vd EOR Vn)<95:0> EOR (ROL(Vm<127:96>,15):ROL(Vm<95:64>,15):ROL(Vm<63:32>,15));\n\nfor i = 0 to 3\n    if i == 3 then \n        result<127:96> = (Vd EOR Vn)<127:96> EOR (ROL(result<31:0>,15));\n    result<(32*i)+31:(32*i)> = result<(32*i)+31:(32*i)> EOR ROL(result<(32*i)+31:(32*i)>,15) EOR ROL(result<(32*i)+31:(32*i)>,23);\nV[d] = result;"}, {"mnemonic": "LDSMIN, LDSMINA, LDSMINAL, LDSMINL", "short_desc": "Atomic signed minimum on word or doubleword in memory", "full_desc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDSMIN  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMIN", "LDSMINA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMINA", "LDSMINAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMINAL", "LDSMINL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMINL", "LDSMIN  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMIN", "LDSMINA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMINA", "LDSMINAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMINAL", "LDSMINL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMINL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "ST1B (scalar plus vector)", "short_desc": "Scatter store bytes from a vector (vector index)", "full_desc": "Scatter store of bytes from the active elements of a vector register to the memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally sign or zero-extended from 32 to 64 bits. Inactive elements are not written to memory.", "syntax": ["ST1B    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "ST1B    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "ST1B    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 8;\ninteger offs_size = 32;\nboolean offs_unsigned = xs == '0';\ninteger scale = 0;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(VL) offset = Z[m];\nbits(VL) src = Z[t];\nbits(PL) mask = P[g];\nbits(64) addr;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;"}, {"mnemonic": "SMULH", "short_desc": "Signed Multiply High", "full_desc": "Signed Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register.", "syntax": ["SMULH  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);           // ignored by UMULH/SMULH\ninteger destsize = 64;\ninteger datasize = destsize;\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\ninteger result;\n\nresult = Int(operand1, unsigned) * Int(operand2, unsigned);\n\nX[d] = result<127:64>;"}, {"mnemonic": "UDF", "short_desc": "Permanently Undefined", "full_desc": "Permanently Undefined generates an Undefined Instruction exception (ESR_ELx.EC = 0b000000). The encodings for UDF used in this section are defined as permanently  in the Armv8-A architecture.", "syntax": ["UDF  #<imm>\t; Integer"], "symbols": ["<imm>\nis a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field. The PE ignores the value of this constant."], "decode": "// The imm16 field is ignored by hardware.\nUNDEFINED;", "operation": "// No operation."}, {"mnemonic": "SMAX", "short_desc": "Signed Maximum (vector)", "full_desc": "Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LDRSW (immediate)", "short_desc": "Load Register Signed Word (immediate)", "full_desc": "Load Register Signed Word (immediate) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see .", "syntax": ["LDRSW  <Xt>, [<Xn|SP>], #<simm>\t; Post-index", "LDRSW  <Xt>, [<Xn|SP>, #<simm>]!\t; Pre-index", "LDRSW  <Xt>, [<Xn|SP>{, #<pimm>}]\t; Unsigned offset"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nIs the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "ZIP1, ZIP2 (predicates)", "short_desc": "Interleave elements from two half predicates", "full_desc": "Interleave alternating elements from the lowest or highest halves of the first and second source predicates and place in elements of the destination predicate. This instruction is unpredicated.", "syntax": ["ZIP2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; High halves", "ZIP1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Low halves"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\ninteger part = 1;", "operation": "CheckSVEEnabled();\ninteger pairs = VL DIV (esize * 2);\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\ninteger base = part * pairs;\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize DIV 8] = Elem[operand1, base+p, esize DIV 8];\n    Elem[result, 2*p+1, esize DIV 8] = Elem[operand2, base+p, esize DIV 8];\n\nP[d] = result;"}, {"mnemonic": "FMLA (by element)", "short_desc": "Floating-point fused Multiply-Add to accumulator (by element)", "full_desc": "Floating-point fused Multiply-Add to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the results in the vector elements of the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMLA  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision", "FMLA  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nFor the half-precision variant: is the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<Vm>\nFor the single-precision and double-precision variant: is the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<Ts>\n", "<index>\nFor the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields.", "<index>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);\ninteger index = UInt(H:L:M);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "UBFM", "short_desc": "Unsigned Bitfield Move", "full_desc": "Unigned Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly.", "syntax": ["UBFM  <Wd>, <Wn>, #<immr>, #<imms>\t; 32-bit", "UBFM  <Xd>, <Xn>, #<immr>, #<imms>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr>\nFor the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the \"immr\" field.", "<immr>\nFor the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the \"immr\" field.", "<imms>\nFor the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31, encoded in the \"imms\" field.", "<imms>\nFor the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the \"imms\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\n\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    // SBFM\n    when '01' inzero = FALSE; extend = FALSE;   // BFM\n    when '10' inzero = TRUE;  extend = FALSE;   // UBFM\n    when '11' UNDEFINED;\n\nif sf == '1' && N != '1' then UNDEFINED;\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;\n\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);", "operation": "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\n\n// perform bitfield move on low bits\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\n\n// determine extension bits (sign, zero or dest register)\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\n\n// combine extension bits and result bits\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);"}, {"mnemonic": "FMUL (indexed)", "short_desc": "Floating-point multiply by indexed elements", "full_desc": "Multiply all floating-point elements within each 128-bit segment of the first source vector by the specified element in the corresponding second source vector segment. The results are placed in the corresponding elements of the destination vector.", "syntax": ["FMUL    <Zd>.H, <Zn>.H, <Zm>.H[<imm>]\t; Half-precision", "FMUL    <Zd>.S, <Zn>.S, <Zm>.S[<imm>]\t; Single-precision", "FMUL    <Zd>.D, <Zn>.D, <Zm>.D[<imm>]\t; Double-precision"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nFor the half-precision and single-precision variant: is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zm>\nFor the double-precision variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<imm>\nFor the half-precision variant: is the immediate index, in the range 0 to 7, encoded in the \"i3h:i3l\" fields.", "<imm>\nFor the single-precision variant: is the immediate index, in the range 0 to 3, encoded in the \"i2\" field.", "<imm>\nFor the double-precision variant: is the immediate index, in the range 0 to 1, encoded in the \"i1\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger index = UInt(i3h:i3l);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger eltspersegment = 128 DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = segmentbase + index;\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, s, esize];\n    Elem[result, e, esize] = FPMul(element1, element2, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "MOVPRFX (predicated)", "short_desc": "Move prefix (predicated)", "full_desc": "The predicated  instruction is a hint to hardware that the instruction may be combined with the destructive instruction which follows it in program order to create a single constructive operation. Since it is a hint it is also permitted to be implemented as a discrete vector copy, and the result of executing the pair of instructions with or without combining is identical. The choice of combined versus discrete operation may vary dynamically.", "syntax": ["MOVPRFX <Zd>.<T>, <Pg>/<ZM>, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<ZM>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\nboolean merging = (M == '1');", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) dest = Z[d];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = element;\n    elsif merging then\n        Elem[result, e, esize] = Elem[dest, e, esize];\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[d] = result;"}, {"mnemonic": "FMSB", "short_desc": "Floating-point fused multiply-subtract vectors (predicated), writing multiplicand [Zdn = Za + -Zdn * Zm]", "full_desc": "Multiply the corresponding active floating-point elements of the first and second source vectors and subtract from elements of the third (addend) vector without intermediate rounding. Destructively place the results in the destination and first source (multiplicand) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMSB    <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Za>\nIs the name of the third source scalable vector register, encoded in the \"Za\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\ninteger a = UInt(Za);\nboolean op1_neg = TRUE;\nboolean op3_neg = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[a];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    bits(esize) element3 = Elem[operand3, e, esize];\n\n    if ElemP[mask, e, esize] == '1' then\n        if op1_neg then element1 = FPNeg(element1);\n        if op3_neg then element3 = FPNeg(element3);\n        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "LDSET, LDSETA, LDSETAL, LDSETL", "short_desc": "Atomic bit set on word or doubleword in memory", "full_desc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDSET  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSET", "LDSETA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSETA", "LDSETAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSETAL", "LDSETL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSETL", "LDSET  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSET", "LDSETA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSETA", "LDSETAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSETAL", "LDSETL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSETL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FMINNM (vectors)", "short_desc": "Floating-point minimum number (predicated)", "full_desc": "Determine the minimum number value of active floating-point elements of the second source vector and corresponding floating-point elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. If one element value is NaN then the result is the numeric value. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMINNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "REV16", "short_desc": "Reverse bytes in 16-bit halfwords", "full_desc": "Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit halfword of a register.", "syntax": ["REV16  <Wd>, <Wn>\t; 32-bit", "REV16  <Xd>, <Xn>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;\n\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UNDEFINED;\n        container_size = 64;", "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n\nX[d] = result;"}, {"mnemonic": "AND (vector)", "short_desc": "Bitwise AND (vector)", "full_desc": "Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.", "syntax": ["AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"}, {"mnemonic": "SMLSL, SMLSL2 (vector)", "short_desc": "Signed Multiply-Subtract Long (vector)", "full_desc": "Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"}, {"mnemonic": "LD3 (multiple structures)", "short_desc": "Load multiple 3-element structures to three registers", "full_desc": "Load multiple 3-element structures to three registers. This instruction loads multiple 3-element structures from memory and writes the result to the three SIMD&FP registers, with de-interleaving.", "syntax": ["LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; No offset", "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UNDEFINED;\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then UNDEFINED;"}, {"mnemonic": "SSUBW, SSUBW2", "short_desc": "Signed Subtract Wide", "full_desc": "Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.", "syntax": ["SSUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Tb>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQSHLU", "short_desc": "Signed saturating Shift Left Unsigned (immediate)", "full_desc": "Signed saturating Shift Left Unsigned (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, shifts each value by an immediate value, saturates the shifted result to an unsigned integer value, places the result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see .", "syntax": ["SQSHLU  <V><d>, <V><n>, #<shift>\t; Scalar", "SQSHLU  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UNDEFINED;\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "UQINCH (scalar)", "short_desc": "Unsigned saturating increment scalar by multiple of 16-bit predicate constraint element count", "full_desc": "Determines the number of active 16-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQINCH  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "UQINCH  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "LD1D (vector plus immediate)", "short_desc": "Gather load doublewords to vector (immediate index)", "full_desc": "Gather load of doublewords to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 8 in the range 0 to 248. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 248, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "LD1D (scalar plus scalar)", "short_desc": "Contiguous load doublewords to vector (scalar index)", "full_desc": "Contiguous load of doublewords to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 8 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "UMULL, UMULL2 (by element)", "short_desc": "Unsigned Multiply Long (vector, by element)", "full_desc": "Unsigned Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = product;\n\nV[d] = result;"}, {"mnemonic": "FCVTZS (vector, fixed-point)", "short_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTZS  <V><d>, <V><n>, #<fbits>\t; Scalar", "FCVTZS  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<fbits>\n", "<fbits>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FDIV (vector)", "short_desc": "Floating-point Divide (vector)", "full_desc": "Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&FP register, by the floating-point values in the corresponding elements in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPDiv(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ST1W (scalar plus immediate)", "short_desc": "Contiguous store words from vector (immediate index)", "full_desc": "Contiguous store of words from elements of a vector register to the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements are not written to memory.", "syntax": ["ST1W    { <Zt>.<T> }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size != '1x' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8 << UInt(size);\ninteger msize = 32;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) src = Z[t];\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;\n    addr = addr + mbytes;"}, {"mnemonic": "NOTS", "short_desc": "Bitwise invert predicate, setting the condition flags", "full_desc": "Bitwise invert each active element of the source predicate, and place the results in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["NOTS    <Pd>.B, <Pg>/Z, <Pn>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field."]}, {"mnemonic": "PRFW (scalar plus immediate)", "short_desc": "Contiguous prefetch words (immediate index)", "full_desc": "Contiguous prefetch of word elements from the memory address generated by a 64-bit scalar base and immediate index in the range -32 to 31 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address.", "syntax": ["PRFW    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -32 to 31, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 2;\ninteger offset = SInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) addr;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\n\naddr = base + ((offset * elements) << scale);\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Hint_Prefetch(addr, pref_hint, level, stream);\n    addr = addr + (1 << scale);"}, {"mnemonic": "LDTRSW", "short_desc": "Load Register Signed Word (unprivileged)", "full_desc": "Load Register Signed Word (unprivileged) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.", "syntax": ["LDTRSW  <Xt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\n\nunpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');\nunpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';\n\nuser_access_override = HaveUAOExt() && PSTATE.UAO == '1';\nif !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then\n    acctype = AccType_UNPRIV;\nelse\n    acctype = AccType_NORMAL;\n\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "STLRH", "short_desc": "Store-Release Register Halfword", "full_desc": "Store-Release Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["STLRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "BFMMLA", "short_desc": "BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix", "full_desc": "BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix. This instruction multiplies the 2x4 matrix of BF16 values held in the first 128-bit source vector by the 4x2 BF16 matrix in the second 128-bit source vector. The resulting 2x2 single-precision matrix product is then added destructively to the 2x2 single-precision matrix in the 128-bit destination vector. This is equivalent to performing a 4-way dot product per destination element. The instruction ignores the  and does not update the  exception status.", "syntax": ["BFMMLA  <Vd>.4S, <Vn>.8H, <Vm>.8H\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(128) op1 = V[n];\nbits(128) op2 = V[m];\nbits(128) acc = V[d];\n\nV[d] = BFMatMulAdd(acc, op1, op2);"}, {"mnemonic": "FCVTPS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTPS  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTPS  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTPS  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTPS  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTPS  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTPS  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "LDNF1W", "short_desc": "Contiguous load non-fault unsigned words to vector (immediate index)", "full_desc": "Contiguous load with non-faulting behavior of unsigned words to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LDNF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\nboolean unsigned = TRUE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif n == 31 then\n    if ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        // MemNF[] will return fault=TRUE if access is not performed for any reason\n        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "BFCVT", "short_desc": "Floating-point convert from single-precision to BFloat16 format (scalar)", "full_desc": "Floating-point convert from single-precision to BFloat16 format (scalar) converts the single-precision floating-point value in the 32-bit SIMD&FP source register to BFloat16 format and writes the result in the 16-bit SIMD&FP destination register.", "syntax": ["BFCVT  <Hd>, <Sn>\t; Single-precision to BFloat16"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Rn);\ninteger d = UInt(Rd);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(32) operand = V[n];\nbits(16) result;\n\nresult = FPConvertBF(operand, FPCR);\nV[d] = result;"}, {"mnemonic": "CLZ", "short_desc": "Count leading zero bits (predicated)", "full_desc": "Count leading zero bits in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["CLZ     <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = CountLeadingZeroBits(element)<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "BFCVTN, BFCVTN2", "short_desc": "Floating-point convert from single-precision to BFloat16 format (vector)", "full_desc": "Floating-point convert from single-precision to BFloat16 format (vector) reads each single-precision element in the SIMD&FP source vector, converts each value to BFloat16 format, and writes the results in the lower or upper half of the SIMD&FP destination vector. The result elements are half the width of the source elements.", "syntax": ["BFCVTN{2}  <Vd>.<Ta>, <Vn>.4S\t; Vector single-precision to BFloat16"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Rn);\ninteger d = UInt(Rd);\ninteger part = UInt(Q);\ninteger elements = 64 DIV 16;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(128) operand = V[n];\nbits(64) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, 16] = FPConvertBF(Elem[operand, e, 32], FPCR);\n\nVpart[d, part] = result;"}, {"mnemonic": "FMAXNM (vectors)", "short_desc": "Floating-point maximum number (predicated)", "full_desc": "Determine the maximum number value of active floating-point elements of the second source vector and corresponding floating-point elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. If one element value is NaN then the result is the numeric value. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMAXNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "FMULX", "short_desc": "Floating-point Multiply extended", "full_desc": "Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FMULX  <Hd>, <Hn>, <Hm>\t; Scalar half precision", "FMULX  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "ASR (immediate)", "short_desc": "Arithmetic Shift Right (immediate)", "full_desc": "Arithmetic Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in copies of the sign bit in the upper bits and zeros in the lower bits, and writes the result to the destination register.", "syntax": ["ASR  <Wd>, <Wn>, #<shift>\t; 32-bit", "ASR  <Xd>, <Xn>, #<shift>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<shift>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, encoded in the \"immr\" field.", "<shift>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the \"immr\" field."]}, {"mnemonic": "FMAX (immediate)", "short_desc": "Floating-point maximum with immediate (predicated)", "full_desc": "Determine the maximum of an immediate and each active floating-point element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate may take the value +0.0 or +1.0 only. If the element value is NaN then the result is NaN. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\nbits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMax(element1, imm, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "ST3B (scalar plus immediate)", "short_desc": "Contiguous store three-byte structures from three vectors (immediate index)", "full_desc": "Contiguous store three-byte structures, each from the same element number in three vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 3 in the range -24 to 21 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "BRAA, BRAAZ, BRAB, BRABZ", "short_desc": "Branch to Register, with pointer authentication", "full_desc": "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by , using a modifier and the specified key, and branches to the authenticated address.", "syntax": ["BRAAZ  <Xn>\t; Key A, zero modifier", "BRAA  <Xn>, <Xm|SP>\t; Key A, register modifier", "BRABZ  <Xn>\t; Key B, zero modifier", "BRAB  <Xn>, <Xm|SP>\t; Key B, register modifier"], "symbols": ["<Xn>\nIs the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field.", "<Xm|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer holding the modifier, encoded in the \"Rm\" field."], "decode": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UNDEFINED;\nelsif pac && !HavePACExt() then \n    UNDEFINED;\n\ncase op of\n    when '00' branch_type = BranchType_INDIR;\n    when '01' branch_type = BranchType_INDCALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UNDEFINED;\n\nif pac then\n    if Z == '0' && m != 31 then\n        UNDEFINED;\n\n    if branch_type == BranchType_RET then\n        if n != 31 then UNDEFINED;\n        n = 30;\n        source_is_sp = TRUE;", "operation": "bits(64) target = X[n];\nboolean auth_then_branch = TRUE;\n\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier, auth_then_branch);\n    else\n        target = AuthIB(target, modifier, auth_then_branch);\n\nif branch_type == BranchType_INDCALL then X[30] = PC[] + 4;\n\n// Value in BTypeNext will be used to set PSTATE.BTYPE\ncase branch_type of\n    when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ\n        if InGuardedPage then\n            if n == 16 || n == 17 then\n                BTypeNext = '01';\n            else\n                BTypeNext = '11';\n        else\n            BTypeNext = '01';\n    when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ\n        BTypeNext = '10';\n    when BranchType_RET             // RET, RETAA, RETAB \n        BTypeNext = '00';\n\nBranchTo(target, branch_type);"}, {"mnemonic": "SHA512H", "short_desc": "SHA512 Hash update part 1", "full_desc": "SHA512 Hash update part 1 takes the values from the three 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the sigma1 and chi functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&FP register.", "syntax": ["SHA512H  <Qd>, <Qn>, <Vm>.2D\t; Advanced SIMD"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Qn>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveSHA512Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vtmp;  \nbits(64)  MSigma1;\nbits(64)  tmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\n\nMSigma1 =  ROR(Y<127:64>, 14) EOR ROR(Y<127:64>,18) EOR ROR(Y<127:64>,41);\nVtmp<127:64> =  (Y<127:64> AND X<63:0>) EOR (NOT(Y<127:64>) AND X<127:64>);\nVtmp<127:64> = (Vtmp<127:64> + MSigma1 +  W<127:64>);\ntmp = Vtmp<127:64> + Y<63:0>;\nMSigma1 = ROR(tmp, 14) EOR ROR(tmp,18) EOR ROR(tmp,41);\nVtmp<63:0> = (tmp AND Y<127:64>) EOR (NOT(tmp) AND X<63:0>);\nVtmp<63:0> = (Vtmp<63:0> + MSigma1 + W<63:0>);\nV[d] =  Vtmp;"}, {"mnemonic": "ST4B (scalar plus scalar)", "short_desc": "Contiguous store four-byte structures from four vectors (scalar index)", "full_desc": "Contiguous store four-byte structures, each from the same element number in four vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register and added to the base address. After each structure access the index value is incremented by four. The index register is not updated by the instruction.", "syntax": ["ST4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "STEORH, STEORLH", "short_desc": "Atomic exclusive OR on halfword in memory, without return", "full_desc": "Atomic exclusive OR on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory.", "syntax": ["STEORH  <Ws>, [<Xn|SP>]\t; No memory ordering", "STEORLH  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "CSNEG", "short_desc": "Conditional Select Negation", "full_desc": "Conditional Select Negation returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the negated value of the second source register.", "syntax": ["CSNEG  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit", "CSNEG  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"}, {"mnemonic": "CMN (immediate)", "short_desc": "Compare Negative (immediate)", "full_desc": "Compare Negative (immediate) adds a register value and an optionally-shifted immediate value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN  <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit", "CMN  <Xn|SP>, #<imm>{, <shift>}\t; 64-bit"], "symbols": ["<Wn|WSP>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<shift>\n"]}, {"mnemonic": "LDR (literal, SIMD&FP)", "short_desc": "Load SIMD&FP Register (PC-relative literal)", "full_desc": "Load SIMD&FP Register (PC-relative literal). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from the PC value and an immediate offset.", "syntax": ["LDR  <St>, <label>\t; 32-bit", "LDR  <Dt>, <label>\t; 64-bit", "LDR  <Qt>, <label>\t; 128-bit"], "symbols": ["<Dt>\nIs the 64-bit name of the SIMD&FP register to be loaded, encoded in the \"Rt\" field.", "<Qt>\nIs the 128-bit name of the SIMD&FP register to be loaded, encoded in the \"Rt\" field.", "<St>\nIs the 32-bit name of the SIMD&FP register to be loaded, encoded in the \"Rt\" field.", "<label>\nIs the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 16;\n    when '11'\n        UNDEFINED;\n\noffset = SignExtend(imm19:'00', 64);\nboolean tag_checked = FALSE;", "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nCheckFPAdvSIMDEnabled64();\n\ndata = Mem[address, size, AccType_VEC];\nV[t] = data;"}, {"mnemonic": "SQDMLSL, SQDMLSL2 (vector)", "short_desc": "Signed saturating Doubling Multiply-Subtract Long", "full_desc": "Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["SQDMLSL  <Va><d>, <Vb><n>, <Vb><m>\t; Scalar", "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Va>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vb>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "FRINTM (vector)", "short_desc": "Floating-point Round to Integral, toward Minus infinity (vector)", "full_desc": "Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTM  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FRINTM  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "FADD (vector)", "short_desc": "Floating-point Add (vector)", "full_desc": "Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&FP registers, writes the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SQRDMLSH (by element)", "short_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element)", "full_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.", "syntax": ["SQRDMLSH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar", "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "if !HaveQRDMLAHExt() then UNDEFINED;\n\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "CRC32B, CRC32H, CRC32W, CRC32X", "short_desc": "CRC32 checksum", "full_desc": "checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial  is used for the CRC calculation.", "syntax": ["CRC32B  <Wd>, <Wn>, <Wm>\t; CRC32B", "CRC32H  <Wd>, <Wn>, <Wm>\t; CRC32H", "CRC32W  <Wd>, <Wn>, <Wm>\t; CRC32W", "CRC32X  <Wd>, <Wn>, <Xm>\t; CRC32X"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose accumulator output register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose accumulator input register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose data source register, encoded in the \"Rm\" field.", "<Wm>\nIs the 32-bit name of the general-purpose data source register, encoded in the \"Rm\" field."], "decode": "if !HaveCRCExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sf == '1' && sz != '11' then UNDEFINED;\nif sf == '0' && sz == '11' then UNDEFINED;\ninteger size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64\nboolean crc32c = (C == '1');", "operation": "bits(32)      acc     = X[n];   // accumulator\nbits(size)    val     = X[m];   // input value\nbits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\n\nbits(32+size) tempacc = BitReverse(acc) : Zeros(size);\nbits(size+32) tempval = BitReverse(val) : Zeros(32);\n\n// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation\nX[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"}, {"mnemonic": "SCVTF (scalar, fixed-point)", "short_desc": "Signed fixed-point Convert to Floating-point (scalar)", "full_desc": "Signed fixed-point Convert to Floating-point (scalar). This instruction converts the signed value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the , and writes the result to the SIMD&FP destination register.", "syntax": ["SCVTF  <Hd>, <Wn>, #<fbits>\t; 32-bit to half-precision", "SCVTF  <Sd>, <Wn>, #<fbits>\t; 32-bit to single-precision", "SCVTF  <Dd>, <Wn>, #<fbits>\t; 32-bit to double-precision", "SCVTF  <Hd>, <Xn>, #<fbits>\t; 64-bit to half-precision", "SCVTF  <Sd>, <Xn>, #<fbits>\t; 64-bit to single-precision", "SCVTF  <Dd>, <Xn>, #<fbits>\t; 64-bit to double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<fbits>\nFor the 32-bit to double-precision, 32-bit to half-precision and 32-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 32, encoded as 64 minus \"scale\".", "<fbits>\nFor the 64-bit to double-precision, 64-bit to half-precision and 64-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus \"scale\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase ftype of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\nif sf == '0' && scale<5> == '0' then UNDEFINED;\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"}, {"mnemonic": "FCVTNS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTNS  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTNS  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTNS  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTNS  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTNS  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTNS  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "SQINCW (vector)", "short_desc": "Signed saturating increment vector by multiple of 32-bit predicate constraint element count", "full_desc": "Determines the number of active 32-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment all destination vector elements. The results are saturated to the 32-bit signed integer range.", "syntax": ["SQINCW  <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "EOR, EORS (predicates)", "short_desc": "Bitwise exclusive OR predicates", "full_desc": "Bitwise exclusive OR active elements of the second source predicate with corresponding elements of the first source predicate and place the results in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["EOR     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags", "EORS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bit element1 = ElemP[operand1, e, esize];\n    bit element2 = ElemP[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        ElemP[result, e, esize] = element1 EOR element2;\n    else\n        ElemP[result, e, esize] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "UMAX (vectors)", "short_desc": "Unsigned maximum vectors (predicated)", "full_desc": "Determine the unsigned maximum of active elements of the second source vector and corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["UMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer maximum = Max(element1, element2);\n        Elem[result, e, esize] = maximum<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "ASR (immediate, predicated)", "short_desc": "Arithmetic shift right by immediate (predicated)", "full_desc": "Shift right by immediate, preserving the sign bit, each active element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate shift amount is an unsigned value in the range 1 to number of bits per element. Inactive elements in the destination vector register remain unmodified.", "syntax": ["ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\nIs the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\"."], "decode": "if !HaveSVE() then UNDEFINED;\nbits(4) tsize = tszh:tszl;\ncase tsize of\n    when '0000' UNDEFINED;\n    when '0001' esize = 8;\n    when '001x' esize = 16;\n    when '01xx' esize = 32;\n    when '1xxx' esize = 64;\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger shift = (2 * esize) - UInt(tsize:imm3);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(PL) mask = P[g];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = ASR(element1, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "LDR (register)", "short_desc": "Load Register (register)", "full_desc": "Load Register (register) calculates an address from a base register value and an offset register value, loads a word from memory, and writes it to a register. The offset register value can optionally be shifted and extended. For information about memory accesses, see .", "syntax": ["LDR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-bit", "LDR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<amount>\n", "<amount>\n"], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "LDR (register, SIMD&FP)", "short_desc": "Load SIMD&FP Register (register offset)", "full_desc": "Load SIMD&FP Register (register offset). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended.", "syntax": ["LDR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\t; 8-fsreg,LDR-8-fsreg", "LDR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\t; 8-fsreg,LDR-8-fsreg", "LDR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 16-fsreg,LDR-16-fsreg", "LDR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 32-fsreg,LDR-32-fsreg", "LDR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 64-fsreg,LDR-64-fsreg", "LDR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\t; 128-fsreg,LDR-128-fsreg"], "symbols": ["<Bt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Ht>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nWhen  is set to , is the 32-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<Xm>\nWhen  is set to , is the 64-bit name of the general-purpose index register, encoded in the \"Rm\" field.", "<extend>\n", "<extend>\n", "<amount>\nFor the 8-bit variant: is the index shift amount, it must be , encoded in \"S\" as  if omitted, or as  if present.", "<amount>\n", "<amount>\n", "<amount>\n", "<amount>\n"], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UNDEFINED;\nif option<1> == '0' then UNDEFINED;             // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH;"}, {"mnemonic": "MOVZ", "short_desc": "Move wide with zero", "full_desc": "Move wide with zero moves an optionally-shifted 16-bit immediate value to a register.", "syntax": ["MOVZ  <Wd>, #<imm>{, LSL #<shift>}\t; 32-bit", "MOVZ  <Xd>, #<imm>{, LSL #<shift>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<imm>\nIs the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field.", "<shift>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<shift>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."], "decode": "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\n\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UNDEFINED;\n\nif sf == '0' && hw<1> == '1' then UNDEFINED;\npos = UInt(hw:'0000');", "operation": "bits(datasize) result;\n\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\n\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nX[d] = result;"}, {"mnemonic": "ST4 (multiple structures)", "short_desc": "Store multiple 4-element structures from four registers", "full_desc": "Store multiple 4-element structures from four registers. This instruction stores multiple 4-element structures to memory from four SIMD&FP registers, with interleaving. Every element of each register is stored.", "syntax": ["ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; No offset", "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Vt4>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UNDEFINED;\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then UNDEFINED;"}, {"mnemonic": "CBZ", "short_desc": "Compare and Branch on Zero", "full_desc": "Compare and Branch on Zero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.", "syntax": ["CBZ  <Wt>, <label>\t; 32-bit", "CBZ  <Xt>, <label>\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<label>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."], "decode": "integer t = UInt(Rt);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean iszero = (op == '0');\nbits(64) offset = SignExtend(imm19:'00', 64);", "operation": "bits(datasize) operand1 = X[t];\n\nif IsZero(operand1) == iszero then\n    BranchTo(PC[] + offset, BranchType_DIR);"}, {"mnemonic": "LDNF1SH", "short_desc": "Contiguous load non-fault signed halfwords to vector (immediate index)", "full_desc": "Contiguous load with non-faulting behavior of signed halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LDNF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\nboolean unsigned = FALSE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif n == 31 then\n    if ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        // MemNF[] will return fault=TRUE if access is not performed for any reason\n        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "CMLT (zero)", "short_desc": "Compare signed Less than zero (vector)", "full_desc": "Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMLT  <V><d>, <V><n>, #0\t; Scalar", "CMLT  <Vd>.<T>, <Vn>.<T>, #0\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison = CompareOp_LT;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "CMHI (register)", "short_desc": "Compare unsigned Higher (vector)", "full_desc": "Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMHI  <V><d>, <V><n>, <V><m>\t; Scalar", "CMHI  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "ERETAA, ERETAB", "short_desc": "Exception Return, with pointer authentication", "full_desc": "Exception Return, with pointer authentication. This instruction authenticates the address in ELR, using SP as the modifier and the specified key, the PE restores  from the SPSR for the current Exception level, and branches to the authenticated address.", "syntax": ["ERETAA\t; ERETAA", "ERETAB\t; ERETAB"], "symbols": [], "decode": "if PSTATE.EL == EL0 then UNDEFINED;\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\n\nif !pac && op4 != '00000' then\n    UNDEFINED;\nelsif pac && (!HavePACExt() || op4 != '11111') then\n    UNDEFINED;\n\nif Rn != '11111' then \n    UNDEFINED;", "operation": "AArch64.CheckForERetTrap(pac, use_key_a);\nbits(64) target = ELR[];\nboolean auth_then_branch = TRUE;\n\nif pac then\n    if use_key_a then\n        target = AuthIA(ELR[], SP[], auth_then_branch);\n    else\n        target = AuthIB(ELR[], SP[], auth_then_branch);\n\nAArch64.ExceptionReturn(target, SPSR[]);"}, {"mnemonic": "UABAL, UABAL2", "short_desc": "Unsigned Absolute difference and Accumulate Long", "full_desc": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.", "syntax": ["UABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "CCMP (register)", "short_desc": "Conditional Compare (register)", "full_desc": "Conditional Compare (register) sets the value of the condition flags to the result of the comparison of two registers if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMP  <Wn>, <Wm>, #<nzcv>, <cond>\t; 32-bit", "CCMP  <Xn>, <Xm>, #<nzcv>, <cond>\t; 64-bit"], "symbols": ["<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "STCLRH, STCLRLH", "short_desc": "Atomic bit clear on halfword in memory, without return", "full_desc": "Atomic bit clear on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.", "syntax": ["STCLRH  <Ws>, [<Xn|SP>]\t; No memory ordering", "STCLRLH  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "TST (shifted register)", "short_desc": "Test (shifted register)", "full_desc": "Test (shifted register) performs a bitwise AND operation on a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["TST  <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "TST  <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"]}, {"mnemonic": "LDXR", "short_desc": "Load Exclusive Register", "full_desc": "Load Exclusive Register derives an address from a base register value, loads a 32-bit word or a 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See . For information about memory accesses see .", "syntax": ["LDXR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit", "LDXR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "CSET", "short_desc": "Conditional Set", "full_desc": "Conditional Set sets the destination register to 1 if the condition is TRUE, and otherwise sets it to 0.", "syntax": ["CSET  <Wd>, <cond>\t; 32-bit", "CSET  <Xd>, <cond>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "SQABS", "short_desc": "Signed saturating Absolute value", "full_desc": "Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.", "syntax": ["SQABS  <V><d>, <V><n>\t; Scalar", "SQABS  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         \n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "DSB", "short_desc": "Data Synchronization Barrier", "full_desc": "Data Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see .", "syntax": ["DSB  <option>|#<imm>\t; System"], "symbols": ["<option>\nSpecifies the limitation on the barrier operation. Values are:", "<imm>\nIs a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"CRm\" field."], "decode": "case CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable; \n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\ncase CRm<1:0> of\n    when '00' types = MBReqTypes_All; domain = MBReqDomain_FullSystem;\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;", "operation": "DataSynchronizationBarrier(domain, types);"}, {"mnemonic": "LDAR", "short_desc": "Load-Acquire Register", "full_desc": "Load-Acquire Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["LDAR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit", "LDAR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STSETB, STSETLB", "short_desc": "Atomic bit set on byte in memory, without return", "full_desc": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.", "syntax": ["STSETB  <Ws>, [<Xn|SP>]\t; No memory ordering", "STSETLB  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "LDR (immediate, SIMD&FP)", "short_desc": "Load SIMD&FP Register (immediate offset)", "full_desc": "Load SIMD&FP Register (immediate offset). This instruction loads an element from memory, and writes the result as a scalar to the SIMD&FP register. The address that is used for the load is calculated from a base register value, a signed immediate offset, and an optional offset that is a multiple of the element size.", "syntax": ["LDR  <Bt>, [<Xn|SP>], #<simm>\t; 8-bit", "LDR  <Ht>, [<Xn|SP>], #<simm>\t; 16-bit", "LDR  <St>, [<Xn|SP>], #<simm>\t; 32-bit", "LDR  <Dt>, [<Xn|SP>], #<simm>\t; 64-bit", "LDR  <Qt>, [<Xn|SP>], #<simm>\t; 128-bit", "LDR  <Bt>, [<Xn|SP>, #<simm>]!\t; 8-bit", "LDR  <Ht>, [<Xn|SP>, #<simm>]!\t; 16-bit", "LDR  <St>, [<Xn|SP>, #<simm>]!\t; 32-bit", "LDR  <Dt>, [<Xn|SP>, #<simm>]!\t; 64-bit", "LDR  <Qt>, [<Xn|SP>, #<simm>]!\t; 128-bit", "LDR  <Bt>, [<Xn|SP>{, #<pimm>}]\t; 8-bit", "LDR  <Ht>, [<Xn|SP>{, #<pimm>}]\t; 16-bit", "LDR  <St>, [<Xn|SP>{, #<pimm>}]\t; 32-bit", "LDR  <Dt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit", "LDR  <Qt>, [<Xn|SP>{, #<pimm>}]\t; 128-bit"], "symbols": ["<Bt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Ht>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nFor the 8-bit variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<pimm>\nFor the 16-bit variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/2.", "<pimm>\nFor the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4.", "<pimm>\nFor the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8.", "<pimm>\nFor the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range 0 to 65520, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/16."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UNDEFINED;\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "LD1R", "short_desc": "Load one single-element structure and Replicate to all lanes (of one register)", "full_desc": "Load one single-element structure and Replicate to all lanes (of one register). This instruction loads a single-element structure from memory and replicates the structure to all the lanes of the SIMD&FP register.", "syntax": ["LD1R  { <Vt>.<T> }, [<Xn|SP>]\t; No offset", "LD1R  { <Vt>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "LD1R  { <Vt>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "FMUL (vector)", "short_desc": "Floating-point Multiply (vector)", "full_desc": "Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ASRV", "short_desc": "Arithmetic Shift Right Variable", "full_desc": "Arithmetic Shift Right Variable shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["ASRV  <Wd>, <Wn>, <Wm>\t; 32-bit", "ASRV  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);", "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"}, {"mnemonic": "LD1ROB (scalar plus scalar)", "short_desc": "Contiguous load and replicate thirty-two bytes (scalar index)", "full_desc": "Load thirty-two contiguous bytes to elements of a 256-bit (octaword) vector from the memory address generated by a 64-bit scalar base address and scalar index which is added to the base address.", "syntax": ["LD1ROB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVEFP64MatMulExt() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;", "operation": "CheckSVEEnabled();\nif VL < 256 then UNDEFINED;\ninteger elements = 256 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low bits only\nbits(64) offset;\nbits(256) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\noffset = X[m];\n\naddr = base + UInt(offset) * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);"}, {"mnemonic": "FCMEQ (zero)", "short_desc": "Floating-point Compare Equal to zero (vector)", "full_desc": "Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FCMEQ  <Hd>, <Hn>, #0.0\t; Scalar half precision", "FCMEQ  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision", "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision", "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "SRSHL", "short_desc": "Signed Rounding Shift Left (register)", "full_desc": "Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SRSHL  <V><d>, <V><n>, <V><m>\t; Scalar", "SRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "RSHRN, RSHRN2", "short_desc": "Rounding Shift Right Narrow (immediate)", "full_desc": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the vector in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see .", "syntax": ["RSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\nfor e = 0 to elements-1\n    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    Elem[result, e, esize] = element<esize-1:0>;\n\nVpart[d, part] = result;"}, {"mnemonic": "LDXP", "short_desc": "Load Exclusive Pair of Registers", "full_desc": "Load Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See . For information about memory accesses see .", "syntax": ["LDXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit", "LDXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Wt1>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UMAX (immediate)", "short_desc": "Unsigned maximum with immediate (unpredicated)", "full_desc": "Determine the unsigned maximum of an immediate and each element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is an unsigned 8-bit value in the range 0 to 255, inclusive. This instruction is unpredicated.", "syntax": ["UMAX    <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs the unsigned immediate operand, in the range 0 to 255, encoded in the \"imm8\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\nboolean unsigned = TRUE;\ninteger imm = Int(imm8, unsigned);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    Elem[result, e, esize] = Max(element1, imm)<esize-1:0>;\n\nZ[dn] = result;"}, {"mnemonic": "CMN (shifted register)", "short_desc": "Compare Negative (shifted register)", "full_desc": "Compare Negative (shifted register) adds a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN  <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "CMN  <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."]}, {"mnemonic": "AND (vectors, unpredicated)", "short_desc": "Bitwise AND vectors (unpredicated)", "full_desc": "Bitwise AND all elements of the second source vector with corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["AND     <Zd>.D, <Zn>.D, <Zm>.D\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\n\nZ[d] = operand1 AND operand2;"}, {"mnemonic": "SQINCP (scalar)", "short_desc": "Signed saturating increment scalar by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to increment the scalar destination. The result is saturated to the source general-purpose register's signed integer range. A 32-bit saturated result is then sign-extended to 64 bits.", "syntax": ["SQINCP  <Xdn>, <Pm>.<T>, <Wdn>\t; 32-bit", "SQINCP  <Xdn>, <Pm>.<T>\t; 64-bit"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<T>\n", "<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Rdn);\nboolean unsigned = FALSE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(ssize) operand1 = X[dn];\nbits(PL) operand2 = P[m];\nbits(ssize) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\ninteger element = Int(operand1, unsigned);\n(result, -) = SatQ(element + count, ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "LD1SB (scalar plus vector)", "short_desc": "Gather load signed bytes to vector (vector index)", "full_desc": "Gather load of signed bytes to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally sign or zero-extended from 32 to 64 bits. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LD1SB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 8;\ninteger offs_size = 32;\nboolean unsigned = FALSE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 0;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset = Z[m];\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "AXFLAG", "short_desc": "Convert floating-point condition flags from Arm to external format", "full_desc": "Convert floating-point condition flags from Arm to external format. This instruction converts the state of the PSTATE.{N,Z,C,V} flags from a form representing the result of an Arm floating-point scalar compare instruction to an alternative representation required by some software.", "syntax": ["AXFLAG\t; System"], "symbols": [], "decode": "if !HaveFlagFormatExt() then UNDEFINED;", "operation": "bit N = '0';\nbit Z = PSTATE.Z OR PSTATE.V;\nbit C = PSTATE.C AND NOT(PSTATE.V);\nbit V = '0';\n\nPSTATE.N = N;\nPSTATE.Z = Z;\nPSTATE.C = C;\nPSTATE.V = V;"}, {"mnemonic": "BIC, BICS (predicates)", "short_desc": "Bitwise clear predicates", "full_desc": "Bitwise AND inverted active elements of the second source predicate with corresponding elements of the first source predicate and place the results in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["BIC     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags", "BICS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bit element1 = ElemP[operand1, e, esize];\n    bit element2 = ElemP[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        ElemP[result, e, esize] = element1 AND (NOT element2);\n    else\n        ElemP[result, e, esize] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "FCVTZU (scalar, integer)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTZU  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTZU  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTZU  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTZU  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTZU  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTZU  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "AESIMC", "short_desc": "AES inverse mix columns", "full_desc": "AES inverse mix columns.", "syntax": ["AESIMC  <Vd>.16B, <Vn>.16B\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HaveAESExt() then UNDEFINED;\nboolean decrypt = (D == '1');", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand = V[n];\nbits(128) result;\nif decrypt then\n    result = AESInvMixColumns(operand);\nelse\n    result = AESMixColumns(operand);\nV[d] = result;"}, {"mnemonic": "EON (shifted register)", "short_desc": "Bitwise Exclusive OR NOT (shifted register)", "full_desc": "Bitwise Exclusive OR NOT (shifted register) performs a bitwise Exclusive OR NOT of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["EON  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "EON  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "STNT1B (scalar plus scalar)", "short_desc": "Contiguous store non-temporal bytes from vector (scalar index)", "full_desc": "Contiguous store non-temporal of bytes from elements of a vector register to the memory address generated by a 64-bit scalar base and scalar index which is added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements are not written to memory.", "syntax": ["STNT1B  { <Zt>.B }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(64) offset = X[m];\nbits(VL) src;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nsrc = Z[t];\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];\n    offset = offset + 1;"}, {"mnemonic": "UQINCB", "short_desc": "Unsigned saturating increment scalar by multiple of 8-bit predicate constraint element count", "full_desc": "Determines the number of active 8-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQINCB  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "UQINCB  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "PFALSE", "short_desc": "Set all predicate elements to false", "full_desc": "Set all elements in the destination predicate to false.", "syntax": ["PFALSE  <Pd>.B\t; SVE"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger d = UInt(Pd);", "operation": "CheckSVEEnabled();\nP[d] = Zeros(PL);"}, {"mnemonic": "UMULL", "short_desc": "Unsigned Multiply Long", "full_desc": "Unsigned Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register.", "syntax": ["UMULL  <Xd>, <Wn>, <Wm>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "MOV (element)", "short_desc": "Move vector element to another vector element", "full_desc": "Move vector element to another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.", "syntax": ["MOV  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ts>\n", "<index1>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<index2>\n"]}, {"mnemonic": "UQSUB", "short_desc": "Unsigned saturating Subtract", "full_desc": "Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UQSUB  <V><d>, <V><n>, <V><m>\t; Scalar", "UQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "LD1B (scalar plus vector)", "short_desc": "Gather load unsigned bytes to vector (vector index)", "full_desc": "Gather load of unsigned bytes to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally sign or zero-extended from 32 to 64 bits. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 8;\ninteger offs_size = 32;\nboolean unsigned = TRUE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 0;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset = Z[m];\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "TBNZ", "short_desc": "Test bit and Branch if Nonzero", "full_desc": "Test bit and Branch if Nonzero compares the value of a bit in a general-purpose register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.", "syntax": ["TBNZ  <R><t>, #<imm>, <label>\t; 14-bit signed PC-relative branch offset"], "symbols": ["<R>\n", "<t>\nIs the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in the \"Rt\" field.", "<imm>\nIs the bit number to be tested, in the range 0 to 63, encoded in \"b5:b40\".", "<label>\nIs the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-32KB, is encoded as \"imm14\" times 4."], "decode": "integer t = UInt(Rt);\n\ninteger datasize = if b5 == '1' then 64 else 32;\ninteger bit_pos = UInt(b5:b40);\nbit bit_val = op;\nbits(64) offset = SignExtend(imm14:'00', 64);", "operation": "bits(datasize) operand = X[t];\n\nif operand<bit_pos> == bit_val then\n    BranchTo(PC[] + offset, BranchType_DIR);"}, {"mnemonic": "SQDECD (vector)", "short_desc": "Signed saturating decrement vector by multiple of 64-bit predicate constraint element count", "full_desc": "Determines the number of active 64-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement all destination vector elements. The results are saturated to the 64-bit signed integer range.", "syntax": ["SQDECD  <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "STCLR, STCLRL", "short_desc": "Atomic bit clear on word or doubleword in memory, without return", "full_desc": "Atomic bit clear on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.", "syntax": ["STCLR  <Ws>, [<Xn|SP>]\t; 32-bit LDCLR alias", "STCLRL  <Ws>, [<Xn|SP>]\t; 32-bit LDCLRL alias", "STCLR  <Xs>, [<Xn|SP>]\t; 64-bit LDCLR alias", "STCLRL  <Xs>, [<Xn|SP>]\t; 64-bit LDCLRL alias"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "REVB, REVH, REVW", "short_desc": "Reverse bytes / halfwords / words within elements (predicated)", "full_desc": "Reverse the order of 8-bit bytes, 16-bit halfwords or 32-bit words within each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["REVB    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Byte", "REVH    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Halfword", "REVW    <Zd>.D, <Pg>/M, <Zn>.D\t; Word"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\ninteger swsize = 8;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        bits(esize) element = Elem[operand, e, esize];\n        Elem[result, e, esize] = Reverse(element, swsize);\n\nZ[d] = result;"}, {"mnemonic": "PMULL, PMULL2", "short_desc": "Polynomial Multiply Long", "full_desc": "Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["PMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '01' || size == '10' then UNDEFINED;\nif size == '11' && !HaveBit128PMULLExt() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, 2*esize] = PolynomialMult(element1, element2);\n\nV[d] = result;"}, {"mnemonic": "HINT", "short_desc": "Hint instruction", "full_desc": "Hint instruction is for the instruction set space that is reserved for architectural hint instructions.", "syntax": ["HINT  #<imm>\t; System"], "symbols": ["<imm>\nIs a 7-bit unsigned immediate, in the range 0 to 127 encoded in the \"CRm:op2\" field."], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "CMN (extended register)", "short_desc": "Compare Negative (extended register)", "full_desc": "Compare Negative (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount. The argument that is extended from the  register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit", "CMN  <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit"], "symbols": ["<Wn|WSP>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<R>\n", "<m>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<extend>\n", "<extend>\n", "<amount>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."]}, {"mnemonic": "UQSHL (immediate)", "short_desc": "Unsigned saturating Shift Left (immediate)", "full_desc": "Unsigned saturating Shift Left (immediate). This instruction takes each vector element in the source SIMD&FP register, shifts it by an immediate value, places the results in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see .", "syntax": ["UQSHL  <V><d>, <V><n>, #<shift>\t; Scalar", "UQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UNDEFINED;\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "PUNPKHI, PUNPKLO", "short_desc": "Unpack and widen half of predicate", "full_desc": "Unpack elements from the lowest or highest half of the source predicate and place in elements of twice their size within the destination predicate. This instruction is unpredicated.", "syntax": ["PUNPKHI <Pd>.H, <Pn>.B\t; High half", "PUNPKLO <Pd>.H, <Pn>.B\t; Low half"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pn>\nIs the name of the source scalable predicate register, encoded in the \"Pn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger n = UInt(Pn);\ninteger d = UInt(Pd);\nboolean hi = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) operand = P[n];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    ElemP[result, e, esize] = ElemP[operand, if hi then e + elements else e, esize DIV 2];\n\nP[d] = result;"}, {"mnemonic": "CLASTA (vectors)", "short_desc": "Conditionally extract element after last to vector register", "full_desc": "From the second source vector register extract the element after the last active element, or if the last active element is the final element extract element zero, and then replicate that element to destructively fill the destination and first source vector.", "syntax": ["CLASTA  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean isBefore = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\ninteger last = LastActiveElement(mask, esize);\n\nif last < 0 then\n    result = operand1;\nelse\n    if !isBefore then\n        last = last + 1;\n        if last >= elements then last = 0;\n    for e = 0 to elements-1\n        Elem[result, e, esize] = Elem[operand2, last, esize];\n\nZ[dn] = result;"}, {"mnemonic": "FNMAD", "short_desc": "Floating-point negated fused multiply-add vectors (predicated), writing multiplicand [Zdn = -Za + -Zdn * Zm]", "full_desc": "Multiply the corresponding active floating-point elements of the first and second source vectors and add to elements of the third (addend) vector without intermediate rounding. Destructively place the negated results in the destination and first source (multiplicand) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FNMAD   <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Za>\nIs the name of the third source scalable vector register, encoded in the \"Za\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\ninteger a = UInt(Za);\nboolean op1_neg = TRUE;\nboolean op3_neg = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[a];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    bits(esize) element3 = Elem[operand3, e, esize];\n\n    if ElemP[mask, e, esize] == '1' then\n        if op1_neg then element1 = FPNeg(element1);\n        if op3_neg then element3 = FPNeg(element3);\n        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "FMINNM (vector)", "short_desc": "Floating-point Minimum Number (vector)", "full_desc": "Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SUB (vectors, unpredicated)", "short_desc": "Subtract vectors (unpredicated)", "full_desc": "Subtract all elements of the second source vector from corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["SUB     <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = element1 - element2;\n\nZ[d] = result;"}, {"mnemonic": "MOVS (unpredicated)", "short_desc": "Move predicate (unpredicated), setting the condition flags", "full_desc": "Read all elements from the source predicate and place in the destination predicate. This instruction is unpredicated. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["MOVS    <Pd>.B, <Pn>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field."]}, {"mnemonic": "AND (shifted register)", "short_desc": "Bitwise AND (shifted register)", "full_desc": "Bitwise AND (shifted register) performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "SSHL", "short_desc": "Signed Shift Left (register)", "full_desc": "Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SSHL  <V><d>, <V><n>, <V><m>\t; Scalar", "SSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "WFI", "short_desc": "Wait For Interrupt", "full_desc": "Wait For Interrupt is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. For more information, see .", "syntax": ["WFI\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "ANDS (shifted register)", "short_desc": "Bitwise AND (shifted register), setting flags", "full_desc": "Bitwise AND (shifted register), setting flags, performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ANDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "ANDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "LD1W (vector plus immediate)", "short_desc": "Gather load unsigned words to vector (immediate index)", "full_desc": "Gather load of unsigned words to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LD1W    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "LD1W (scalar plus scalar)", "short_desc": "Contiguous load unsigned words to vector (scalar index)", "full_desc": "Contiguous load of unsigned words to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 4 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; 32-bit element", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "WHILELE", "short_desc": "While incrementing signed scalar less than or equal to scalar", "full_desc": "Generate a predicate that starting from the lowest numbered element is true while the incrementing value of the first, signed scalar operand is less than or equal to the second scalar operand and false thereafter up to the highest numbered element.", "syntax": ["WHILELE <Pd>.<T>, <R><n>, <R><m>\t; SVE"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<R>\n", "<n>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field.", "<m>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger rsize = 32 << UInt(sf);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Pd);\nboolean unsigned = FALSE;\nSVECmp op = Cmp_LE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = Ones(PL);\nbits(rsize) operand1 = X[n];\nbits(rsize) operand2 = X[m];\nbits(PL) result;\nboolean last = TRUE;\n\nfor e = 0 to elements-1\n    boolean cond;\n    case op of\n        when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));\n        when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));\n\n    last = last && cond;\n    ElemP[result, e, esize] = if last then '1' else '0';\n    operand1 = operand1 + 1;\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "ST1D (scalar plus immediate)", "short_desc": "Contiguous store doublewords from vector (immediate index)", "full_desc": "Contiguous store of doublewords from elements of a vector register to the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements are not written to memory.", "syntax": ["ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size != '11' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8 << UInt(size);\ninteger msize = 64;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) src = Z[t];\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;\n    addr = addr + mbytes;"}, {"mnemonic": "STUMAXH, STUMAXLH", "short_desc": "Atomic unsigned maximum on halfword in memory, without return", "full_desc": "Atomic unsigned maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.", "syntax": ["STUMAXH  <Ws>, [<Xn|SP>]\t; No memory ordering", "STUMAXLH  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "LDTRSB", "short_desc": "Load Register Signed Byte (unprivileged)", "full_desc": "Load Register Signed Byte (unprivileged) loads a byte from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.", "syntax": ["LDTRSB  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDTRSB  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\n\nunpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');\nunpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';\n\nuser_access_override = HaveUAOExt() && PSTATE.UAO == '1';\nif !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then\n    acctype = AccType_UNPRIV;\nelse\n    acctype = AccType_NORMAL;\n\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "BCAX", "short_desc": "Bit Clear and XOR", "full_desc": "Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.", "syntax": ["BCAX  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Va>\nIs the name of the third SIMD&FP source register, encoded in the \"Ra\" field."], "decode": "if !HaveSHA3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger a = UInt(Ra);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Va = V[a];\nV[d] = Vn EOR (Vm AND NOT(Va));"}, {"mnemonic": "MLA", "short_desc": "Multiply-add vectors (predicated), writing addend [Zda = Zda + Zn * Zm]", "full_desc": "Multiply the corresponding active elements of the first and second source vectors and add to elements of the third source (addend) vector. Destructively place the results in the destination and third source (addend) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["MLA     <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean sub_op = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = UInt(Elem[operand1, e, esize]);\n    integer element2 = UInt(Elem[operand2, e, esize]);\n    if ElemP[mask, e, esize] == '1' then\n        integer product = element1 * element2;\n        if sub_op then\n            Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n        else\n            Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize];\n\nZ[da] = result;"}, {"mnemonic": "STURH", "short_desc": "Store Register Halfword (unscaled)", "full_desc": "Store Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register. For information about memory accesses, see .", "syntax": ["STURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB", "short_desc": "Atomic signed maximum on byte in memory", "full_desc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDSMAXAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXAB", "LDSMAXALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXALB", "LDSMAXB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXB", "LDSMAXLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMAXLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "MOVN", "short_desc": "Move wide with NOT", "full_desc": "Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate value to a register.", "syntax": ["MOVN  <Wd>, #<imm>{, LSL #<shift>}\t; 32-bit", "MOVN  <Xd>, #<imm>{, LSL #<shift>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<imm>\nIs the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field.", "<shift>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<shift>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."], "decode": "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\n\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UNDEFINED;\n\nif sf == '0' && hw<1> == '1' then UNDEFINED;\npos = UInt(hw:'0000');", "operation": "bits(datasize) result;\n\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\n\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nX[d] = result;"}, {"mnemonic": "CSEL", "short_desc": "Conditional Select", "full_desc": "Conditional Select returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register.", "syntax": ["CSEL  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit", "CSEL  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"}, {"mnemonic": "FNEG", "short_desc": "Floating-point negate (predicated)", "full_desc": "Negate each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. This inverts the sign bit and cannot signal a floating-point exception. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FNEG    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPNeg(element);\n\nZ[d] = result;"}, {"mnemonic": "BRKN, BRKNS", "short_desc": "Propagate break to next partition", "full_desc": "If the last active element of the first source predicate is false then set the destination predicate to all-false. Otherwise leaves the destination and second source predicate unchanged. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["BRKN    <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B\t; Not setting the condition flags", "BRKNS   <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B\t; Setting the condition flags"], "symbols": ["<Pdm>\nIs the name of the second source and destination scalable predicate register, encoded in the \"Pdm\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger dm = UInt(Pdm);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[dm];\nbits(PL) result;\n\nif LastActive(mask, operand1, 8) == '1' then\n    result = operand2;\nelse\n    result = Zeros();\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(Ones(PL), result, 8);\nP[dm] = result;"}, {"mnemonic": "FRINTZ (scalar)", "short_desc": "Floating-point Round to Integral, toward Zero (scalar)", "full_desc": "Floating-point Round to Integral, toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTZ  <Hd>, <Hn>\t; Half-precision", "FRINTZ  <Sd>, <Sn>\t; Single-precision", "FRINTZ  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "SHADD", "short_desc": "Signed Halving Add", "full_desc": "Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    Elem[result, e, esize] = sum<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "UQSHRN, UQSHRN2", "short_desc": "Unsigned saturating Shift Right Narrow (immediate)", "full_desc": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see .", "syntax": ["UQSHRN  <Vb><d>, <Va><n>, #<shift>\t; Scalar", "UQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then UNDEFINED;\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "SEV", "short_desc": "Send Event", "full_desc": "Send Event is a hint instruction. It causes an event to be signaled to all PEs in the multiprocessor system. For more information, see .", "syntax": ["SEV\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "LDTR", "short_desc": "Load Register (unprivileged)", "full_desc": "Load Register (unprivileged) loads a word or doubleword from memory, and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset.", "syntax": ["LDTR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDTR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\n\nunpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');\nunpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';\n\nuser_access_override = HaveUAOExt() && PSTATE.UAO == '1';\nif !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then\n    acctype = AccType_UNPRIV;\nelse\n    acctype = AccType_NORMAL;\n\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "FMOV (zero, unpredicated)", "short_desc": "Move floating-point +0.0 to vector elements (unpredicated)", "full_desc": "Unconditionally broadcast the floating-point constant +0.0 into each element of the destination vector. This instruction is unpredicated.", "syntax": ["FMOV    <Zd>.<T>, #0.0\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n"]}, {"mnemonic": "LD3B (scalar plus scalar)", "short_desc": "Contiguous load three-byte structures to three vectors (scalar index)", "full_desc": "Contiguous load three-byte structures, each to the same element number in three vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register and added to the base address. After each structure access the index value is incremented by three. The index register is not updated by the instruction.", "syntax": ["LD3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "STGP", "short_desc": "Store Allocation Tag and Pair of registers", "full_desc": "Store Allocation Tag and Pair of registers stores an Allocation Tag and two 64-bit doublewords to memory, from two registers. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the base register.", "syntax": ["STGP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; Post-index", "STGP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; Pre-index", "STGP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; Signed offset"], "symbols": ["<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Xt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<imm>\nFor the post-index and pre-index variant: is the signed immediate offset, a multiple of 16 in the range -1024 to 1008, encoded in the \"simm7\" field.", "<imm>\nFor the signed offset variant: is the optional signed immediate offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"simm7\" field."], "decode": "integer n = UInt(Xn);\ninteger t = UInt(Xt);\ninteger t2 = UInt(Xt2);\nbits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);\nboolean writeback = TRUE;\nboolean postindex = TRUE;", "operation": "bits(64) address;\nbits(64) data1;\nbits(64) data2;\n\nSetTagCheckedInstruction(FALSE);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata1 = X[t];\ndata2 = X[t2];\n\nif !postindex then\n    address = address + offset;\n\nMem[address, 8, AccType_NORMAL] = data1;\nMem[address+8, 8, AccType_NORMAL] = data2;\n\nAArch64.MemTag[address, AccType_NORMAL] = AArch64.AllocationTagFromAddress(address);\n\nif writeback then\n    if postindex then\n        address = address + offset;\n\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "BFMLALT (vectors)", "short_desc": "BFloat16 floating-point multiply-add long to single-precision (top)", "full_desc": "This BFloat16 floating-point multiply-add long instruction widens the odd-numbered 16-bit BFloat16 elements in the first source vector and the corresponding elements in the second source vector to single-precision format and then destructively multiplies and adds these values without intermediate rounding to the overlapping 32-bit single-precision elements of the addend and destination vector. This instruction is unpredicated.", "syntax": ["BFMLALT <Zda>.S, <Zn>.H, <Zm>.H\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 32;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(32) element1 = Elem[operand1, 2 * e + 1, 16] : Zeros(16);\n    bits(32) element2 = Elem[operand2, 2 * e + 1, 16] : Zeros(16);\n    bits(32) element3 = Elem[operand3, e, 32];\n    Elem[result, e, 32] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n\nZ[da] = result;"}, {"mnemonic": "LD4B (scalar plus immediate)", "short_desc": "Contiguous load four-byte structures to four vectors (immediate index)", "full_desc": "Contiguous load four-byte structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 4 in the range -32 to 28 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "FNMADD", "short_desc": "Floating-point Negated fused Multiply-Add (scalar)", "full_desc": "Floating-point Negated fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, subtracts the value of the third SIMD&FP source register, and writes the result to the destination SIMD&FP register.", "syntax": ["FNMADD  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision", "FNMADD  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision", "FNMADD  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Da>\nIs the 64-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ha>\nIs the 16-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Sa>\nIs the 32-bit name of the third SIMD&FP source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SXTW", "short_desc": "Sign Extend Word", "full_desc": "Sign Extend Word sign-extends a word to the size of the register, and writes the result to the destination register.", "syntax": ["SXTW  <Xd>, <Wn>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "BFDOT (indexed)", "short_desc": "BFloat16 floating-point indexed dot product", "full_desc": "The BFloat16 floating-point (BF16) indexed dot product instruction computes the dot product of a pair of BF16 values held in each 32-bit element of the first source vector multiplied by a pair of BF16 values in an indexed 32-bit element of the second source vector, and then destructively adds the single-precision dot product to the corresponding single-precision element of the destination vector.", "syntax": ["BFDOT   <Zda>.S, <Zn>.H, <Zm>.H[<imm>]\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<imm>\nIs the immediate index, in the range 0 to 3, encoded in the \"i2\" field."], "decode": "if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\ninteger index = UInt(i2);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 32;\ninteger eltspersegment = 128 DIV 32;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = segmentbase + index;\n    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];\n    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];\n    bits(16) elt2_a = Elem[operand2, 2 * s + 0, 16];\n    bits(16) elt2_b = Elem[operand2, 2 * s + 1, 16];\n\n    bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));\n    Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);\n\nZ[da] = result;"}, {"mnemonic": "SADDV", "short_desc": "Signed add reduction to scalar", "full_desc": "Signed add horizontally across all lanes of a vector, and place the result in the SIMD&FP scalar destination register. Narrow elements are first sign-extended to 64 bits. Inactive elements in the source vector are treated as zero.", "syntax": ["SADDV   <Dd>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<Dd>\nIs the 64-bit name of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\ninteger sum = 0;\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer element = SInt(Elem[operand, e, esize]);\n        sum = sum + element;\n\nV[d] = sum<63:0>;"}, {"mnemonic": "PRFD (scalar plus immediate)", "short_desc": "Contiguous prefetch doublewords (immediate index)", "full_desc": "Contiguous prefetch of doubleword elements from the memory address generated by a 64-bit scalar base and immediate index in the range -32 to 31 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address.", "syntax": ["PRFD    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -32 to 31, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 3;\ninteger offset = SInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) addr;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\n\naddr = base + ((offset * elements) << scale);\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Hint_Prefetch(addr, pref_hint, level, stream);\n    addr = addr + (1 << scale);"}, {"mnemonic": "FMOV (immediate, predicated)", "short_desc": "Move 8-bit floating-point immediate to vector elements (predicated)", "full_desc": "Move a floating-point immediate into each active element in the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMOV    <Zd>.<T>, <Pg>/M, #<const>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<const>\nIs a floating-point immediate value expressable as \u00b1n\u00f716\u00d72^r, where n and r are integers such that 16 \u2264 n \u2264 31 and -3 \u2264 r \u2264 4, i.e. a normalized binary floating-point encoding with 1 sign bit, 3-bit exponent, and 4-bit fractional part, encoded in the \"imm8\" field."]}, {"mnemonic": "FMOV (immediate, unpredicated)", "short_desc": "Move 8-bit floating-point immediate to vector elements (unpredicated)", "full_desc": "Unconditionally broadcast the floating-point immediate into each element of the destination vector. This instruction is unpredicated.", "syntax": ["FMOV    <Zd>.<T>, #<const>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<const>\nIs a floating-point immediate value expressable as \u00b1n\u00f716\u00d72^r, where n and r are integers such that 16 \u2264 n \u2264 31 and -3 \u2264 r \u2264 4, i.e. a normalized binary floating-point encoding with 1 sign bit, 3-bit exponent, and 4-bit fractional part, encoded in the \"imm8\" field."]}, {"mnemonic": "LDCLR, LDCLRA, LDCLRAL, LDCLRL", "short_desc": "Atomic bit clear on word or doubleword in memory", "full_desc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDCLR  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDCLR", "LDCLRA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDCLRA", "LDCLRAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDCLRAL", "LDCLRL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDCLRL", "LDCLR  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDCLR", "LDCLRA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDCLRA", "LDCLRAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDCLRAL", "LDCLRL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDCLRL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LD1SW (vector plus immediate)", "short_desc": "Gather load signed words to vector (immediate index)", "full_desc": "Gather load of signed words to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 32;\nboolean unsigned = FALSE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "LD1SW (scalar plus scalar)", "short_desc": "Contiguous load signed words to vector (scalar index)", "full_desc": "Contiguous load of signed words to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 4 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 32;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "LDNF1D", "short_desc": "Contiguous load non-fault doublewords to vector (immediate index)", "full_desc": "Contiguous load with non-faulting behavior of doublewords to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\nboolean unsigned = TRUE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif n == 31 then\n    if ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        // MemNF[] will return fault=TRUE if access is not performed for any reason\n        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "AT", "short_desc": "Address Translate", "full_desc": "Address Translate. For more information, see .", "syntax": ["AT  <at_op>, <Xt>\t; System"], "symbols": ["<at_op>\n", "<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Xt>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."]}, {"mnemonic": "ADR", "short_desc": "Compute vector address", "full_desc": "Optionally sign or zero-extend the least significant 32-bits of each element from a vector of offsets or indices in the second source vector, scale each index by 2, 4 or 8, add to a vector of base addresses from the first source vector, and place the resulting addresses in the destination vector. This instruction is unpredicated.", "syntax": ["ADR     <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod> <amount>}]\t; Packed offsets", "ADR     <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{ <amount>}]\t; Unpacked 32-bit signed offsets", "ADR     <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{ <amount>}]\t; Unpacked 32-bit unsigned offsets"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n", "<amount>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32 << UInt(sz);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);\ninteger osize = esize;\nboolean unsigned = TRUE;\ninteger mbytes = 1 << UInt(msz);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(VL) offs = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) addr = Elem[base, e, esize];\n    integer offset = Int(Elem[offs, e, esize]<osize-1:0>, unsigned);\n    Elem[result, e, esize] = addr + (offset * mbytes);\n\nZ[d] = result;"}, {"mnemonic": "FABD", "short_desc": "Floating-point Absolute Difference (vector)", "full_desc": "Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FABD  <Hd>, <Hn>, <Hm>\t; Scalar half precision", "FABD  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision", "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision", "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean abs = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, FPCR);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\n\nV[d] = result;"}, {"mnemonic": "SBFX", "short_desc": "Signed Bitfield Extract", "full_desc": "Signed Bitfield Extract copies a bitfield of  bits starting from bit position  in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to a copy of the most significant bit of the bitfield.", "syntax": ["SBFX  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit", "SBFX  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<lsb>\nFor the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.", "<lsb>\nFor the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.", "<width>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<width>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB", "short_desc": "Atomic signed minimum on byte in memory", "full_desc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDSMINAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINAB", "LDSMINALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINALB", "LDSMINB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINB", "LDSMINLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSMINLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "NEG (shifted register)", "short_desc": "Negate (shifted register)", "full_desc": "Negate (shifted register) negates an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["NEG  <Wd>, <Wm>{, <shift> #<amount>}\t; 32-bit", "NEG  <Xd>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field."]}, {"mnemonic": "AESE", "short_desc": "AES single round encryption", "full_desc": "AES single round encryption.", "syntax": ["AESE  <Vd>.16B, <Vn>.16B\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HaveAESExt() then UNDEFINED;\nboolean decrypt = (D == '1');", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nresult = operand1 EOR operand2;\nif decrypt then\n    result = AESInvSubBytes(AESInvShiftRows(result));\nelse\n    result = AESSubBytes(AESShiftRows(result));\n\nV[d] = result;"}, {"mnemonic": "SCVTF (scalar, integer)", "short_desc": "Signed integer Convert to Floating-point (scalar)", "full_desc": "Signed integer Convert to Floating-point (scalar). This instruction converts the signed integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the , and writes the result to the SIMD&FP destination register.", "syntax": ["SCVTF  <Hd>, <Wn>\t; 32-bit to half-precision", "SCVTF  <Sd>, <Wn>\t; 32-bit to single-precision", "SCVTF  <Dd>, <Wn>\t; 32-bit to double-precision", "SCVTF  <Hd>, <Xn>\t; 64-bit to half-precision", "SCVTF  <Sd>, <Xn>\t; 64-bit to single-precision", "SCVTF  <Dd>, <Xn>\t; 64-bit to double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "PRFD (scalar plus vector)", "short_desc": "Gather prefetch doublewords (scalar plus vector)", "full_desc": "Gather prefetch of doublewords from the active memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then multiplied by 8. Inactive addresses are not prefetched from memory.", "syntax": ["PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]\t; 32-bit scaled offset", "PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]\t; 32-bit unpacked scaled offset", "PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]\t; 64-bit scaled offset"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger offs_size = 32;\nboolean offs_unsigned = (xs == '0');\ninteger scale = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);"}, {"mnemonic": "AESMC", "short_desc": "AES mix columns", "full_desc": "AES mix columns.", "syntax": ["AESMC  <Vd>.16B, <Vn>.16B\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HaveAESExt() then UNDEFINED;\nboolean decrypt = (D == '1');", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand = V[n];\nbits(128) result;\nif decrypt then\n    result = AESInvMixColumns(operand);\nelse\n    result = AESMixColumns(operand);\nV[d] = result;"}, {"mnemonic": "MUL (vectors)", "short_desc": "Multiply vectors (predicated)", "full_desc": "Multiply active elements of the first source vector by corresponding elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["MUL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = UInt(Elem[operand1, e, esize]);\n    integer element2 = UInt(Elem[operand2, e, esize]);\n    if ElemP[mask, e, esize] == '1' then\n        integer product = element1 * element2;\n        Elem[result, e, esize] = product<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "WRFFR", "short_desc": "Write the first-fault register", "full_desc": "Read the source predicate register and place in the first-fault register (). This instruction is intended to restore a saved  and is not recommended for general use by applications.", "syntax": ["WRFFR   <Pn>.B\t; SVE"], "symbols": ["<Pn>\nIs the name of the source scalable predicate register, encoded in the \"Pn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger n = UInt(Pn);", "operation": "CheckSVEEnabled();\nbits(PL) operand = P[n];\n\nhsb = HighestSetBit(operand);\nif hsb < 0 || IsOnes(operand<hsb:0>) then  \n    FFR[] = operand;\nelse // not a monotonic predicate\n    FFR[] = bits(PL) UNKNOWN;"}, {"mnemonic": "RDVL", "short_desc": "Read multiple of vector register size to scalar register", "full_desc": "Multiply the current vector register size in bytes by an immediate in the range -32 to 31 and place the result in the 64-bit destination general-purpose register.", "syntax": ["RDVL    <Xd>, #<imm>\t; SVE"], "symbols": ["<Xd>\nIs the 64-bit name of the destination general-purpose register, encoded in the \"Rd\" field.", "<imm>\nIs the signed immediate operand, in the range -32 to 31, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger imm = SInt(imm6);", "operation": "CheckSVEEnabled();\ninteger len = imm * (VL DIV 8);\nX[d] = len<63:0>;"}, {"mnemonic": "LDUR", "short_desc": "Load Register (unscaled)", "full_desc": "Load Register (unscaled) calculates an address from a base register and an immediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "FDUP", "short_desc": "Broadcast 8-bit floating-point immediate to vector elements (unpredicated)", "full_desc": "Unconditionally broadcast the floating-point immediate into each element of the destination vector. This instruction is unpredicated.", "syntax": ["FDUP    <Zd>.<T>, #<const>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<const>\nIs a floating-point immediate value expressable as \u00b1n\u00f716\u00d72^r, where n and r are integers such that 16 \u2264 n \u2264 31 and -3 \u2264 r \u2264 4, i.e. a normalized binary floating-point encoding with 1 sign bit, 3-bit exponent, and 4-bit fractional part, encoded in the \"imm8\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger d = UInt(Zd);\nbits(esize) imm = VFPExpandImm(imm8);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = imm;\n\nZ[d] = result;"}, {"mnemonic": "FRINT<r>", "short_desc": "Floating-point round to integral value (predicated)", "full_desc": "Round to an integral floating-point value with the specified rounding option from each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FRINTI  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Current mode", "FRINTX  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Current mode signalling inexact", "FRINTA  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Nearest with ties to away", "FRINTN  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Nearest with ties to even", "FRINTZ  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Toward zero", "FRINTM  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Toward minus infinity", "FRINTP  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; Toward plus infinity"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\nboolean exact = FALSE;\nFPRounding rounding = FPRoundingMode(FPCR<31:0>);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPRoundInt(element, FPCR<31:0>, rounding, exact);\n\nZ[d] = result;"}, {"mnemonic": "LD4 (single structure)", "short_desc": "Load single 4-element structure to one lane of four registers", "full_desc": "Load single 4-element structure to one lane of four registers. This instruction loads a 4-element structure from memory and writes the result to the corresponding elements of the four SIMD&FP registers without affecting the other bits of the registers.", "syntax": ["LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]\t; 8-bit", "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]\t; 16-bit", "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]\t; 32-bit", "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]\t; 64-bit", "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4\t; 8-bit, immediate offset", "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset", "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8\t; 16-bit, immediate offset", "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset", "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16\t; 32-bit, immediate offset", "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset", "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32\t; 64-bit, immediate offset", "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Vt4>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<index>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<index>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<index>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<index>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "UMINP", "short_desc": "Unsigned Minimum Pairwise", "full_desc": "Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FRECPX", "short_desc": "Floating-point reciprocal exponent (predicated)", "full_desc": "Invert the exponent and zero the fractional part of each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FRECPX  <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPRecpX(element, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "BFCVTNT", "short_desc": "Floating-point down convert and narrow to BFloat16 (top, predicated)", "full_desc": "Convert active 32-bit single-precision elements from the source vector to BFloat16 format, and place the results in the odd-numbered 16-bit elements of the destination vector, leaving the even-numbered elements unchanged. Inactive elements in the destination vector register remain unmodified.", "syntax": ["BFCVTNT <Zd>.H, <Pg>/M, <Zn>.S\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 32;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(32) element = Elem[operand, e, 32];\n    if ElemP[mask, e, 32] == '1' then\n        Elem[result, 2*e+1, 16] = FPConvertBF(element, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "TBL", "short_desc": "Programmable table lookup in single vector table", "full_desc": "Reads each element of the second source (index) vector and uses its value to select an indexed element from the first source (table) vector, and places the indexed table element in the destination vector element corresponding to the index vector element. If an index value is greater than or equal to the number of vector elements then it places zero in the corresponding destination vector element.", "syntax": ["TBL     <Zd>.<T>, { <Zn>.<T> }, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer idx = UInt(Elem[operand2, e, esize]);\n    Elem[result, e, esize] = if idx < elements then Elem[operand1, idx, esize] else Zeros();\n\nZ[d] = result;"}, {"mnemonic": "UXTB", "short_desc": "Unsigned Extend Byte", "full_desc": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["UXTB  <Wd>, <Wn>\t; 32-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "MOV (predicate, predicated, merging)", "short_desc": "Move predicates (merging)", "full_desc": "Read active elements from the source predicate and place in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register remain unmodified. Does not set the condition flags.", "syntax": ["MOV     <Pd>.B, <Pg>/M, <Pn>.B\t; SVE"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field."]}, {"mnemonic": "LD1ROW (scalar plus immediate)", "short_desc": "Contiguous load and replicate eight words (immediate index)", "full_desc": "Load eight contiguous words to elements of a 256-bit (octaword) vector from the memory address generated by a 64-bit scalar base address and immediate index that is a multiple of 32 in the range -256 to +224 added to the base address.", "syntax": ["LD1ROW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate byte offset, a multiple of 32 in the range -256 to 224, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVEFP64MatMulExt() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\nif VL < 256 then UNDEFINED;\ninteger elements = 256 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low bits only\nbits(256) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * 32;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);"}, {"mnemonic": "SMADDL", "short_desc": "Signed Multiply-Add Long", "full_desc": "Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["SMADDL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xa>\nIs the 64-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"}, {"mnemonic": "FMLSL, FMLSL2 (vector)", "short_desc": "Floating-point fused Multiply-Subtract Long from accumulator (vector)", "full_desc": "Floating-point fused Multiply-Subtract Long from accumulator (vector). This instruction negates the values in the vector of one SIMD&FP register, multiplies these with the corresponding values in another vector, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.", "syntax": ["FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; FMLSL", "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; FMLSL2"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz == '1' then UNDEFINED;\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (S == '1');\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize DIV 2) operand1 = Vpart[n,part];\nbits(datasize DIV 2) operand2 = Vpart[m,part];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize DIV 2) element1;\nbits(esize DIV 2) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize DIV 2];\n    element2 = Elem[operand2, e, esize DIV 2];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result,e,esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "FCVTNU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTNU  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTNU  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTNU  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTNU  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTNU  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTNU  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "RETAA, RETAB", "short_desc": "Return from subroutine, with pointer authentication", "full_desc": "Return from subroutine, with pointer authentication. This instruction authenticates the address that is held in LR, using SP as the modifier and the specified key, branches to the authenticated address, with a hint that this instruction is a subroutine return.", "syntax": ["RETAA\t; RETAA", "RETAB\t; RETAB"], "symbols": [], "decode": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UNDEFINED;\nelsif pac && !HavePACExt() then \n    UNDEFINED;\n\ncase op of\n    when '00' branch_type = BranchType_INDIR;\n    when '01' branch_type = BranchType_INDCALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UNDEFINED;\n\nif pac then\n    if Z == '0' && m != 31 then\n        UNDEFINED;\n\n    if branch_type == BranchType_RET then\n        if n != 31 then UNDEFINED;\n        n = 30;\n        source_is_sp = TRUE;", "operation": "bits(64) target = X[n];\nboolean auth_then_branch = TRUE;\n\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier, auth_then_branch);\n    else\n        target = AuthIB(target, modifier, auth_then_branch);\n\nif branch_type == BranchType_INDCALL then X[30] = PC[] + 4;\n\n// Value in BTypeNext will be used to set PSTATE.BTYPE\ncase branch_type of\n    when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ\n        if InGuardedPage then\n            if n == 16 || n == 17 then\n                BTypeNext = '01';\n            else\n                BTypeNext = '11';\n        else\n            BTypeNext = '01';\n    when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ\n        BTypeNext = '10';\n    when BranchType_RET             // RET, RETAA, RETAB \n        BTypeNext = '00';\n\nBranchTo(target, branch_type);"}, {"mnemonic": "FDIV", "short_desc": "Floating-point divide by vector (predicated)", "full_desc": "Divide active floating-point elements of the first source vector by corresponding floating-point elements of the second source vector and destructively place the quotient in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPDiv(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "DECD, DECH, DECW (vector)", "short_desc": "Decrement vector by multiple of predicate constraint element count", "full_desc": "Determines the number of active elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement all destination vector elements.", "syntax": ["DECD    <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; Doubleword", "DECH    <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; Halfword", "DECW    <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; Word"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[operand1, e, esize] - (count * imm);\n\nZ[dn] = result;"}, {"mnemonic": "SHA256H2", "short_desc": "SHA256 hash update (part 2)", "full_desc": "SHA256 hash update (part 2).", "syntax": ["SHA256H2  <Qd>, <Qn>, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Qn>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif !HaveSHA256Ext() then UNDEFINED;\nboolean part1 = (P == '0');", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) result;\nif part1 then\n    result = SHA256hash(V[d], V[n], V[m], TRUE);\nelse\n    result = SHA256hash(V[n], V[d], V[m], FALSE);\nV[d] = result;"}, {"mnemonic": "CCMN (immediate)", "short_desc": "Conditional Compare Negative (immediate)", "full_desc": "Conditional Compare Negative (immediate) sets the value of the condition flags to the result of the comparison of a register value and a negated immediate value if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMN  <Wn>, #<imm>, #<nzcv>, <cond>\t; 32-bit", "CCMN  <Xn>, #<imm>, #<nzcv>, <cond>\t; 64-bit"], "symbols": ["<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<imm>\nIs a five bit unsigned (positive) immediate encoded in the \"imm5\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\nbits(datasize) imm = ZeroExtend(imm5, datasize);", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "SXTH", "short_desc": "Sign Extend Halfword", "full_desc": "Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["SXTH  <Wd>, <Wn>\t; 32-bit", "SXTH  <Xd>, <Wn>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "USDOT (by element)", "short_desc": "Dot Product with unsigned and signed integers (vector, by element)", "full_desc": "Dot Product index form with unsigned and signed integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<index>\nIs the immediate index of a quadtuplet of four 8-bit elements in the range 0 to 3, encoded in the \"H:L\" fields."], "decode": "if !HaveInt8MatMulExt() then UNDEFINED;\nboolean op1_unsigned = (US == '1');\nboolean op2_unsigned = (US == '0');\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\ninteger d = UInt(Rd);\ninteger i = UInt(H:L);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 32;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128)      operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    bits(32) res = Elem[operand3, e, 32];\n    for b = 0 to 3\n        integer element1 = Int(Elem[operand1, 4 * e + b, 8], op1_unsigned);\n        integer element2 = Int(Elem[operand2, 4 * i + b, 8], op2_unsigned);\n        res = res + element1 * element2;\n    Elem[result, e, 32] = res;\nV[d] = result;"}, {"mnemonic": "CMGT (register)", "short_desc": "Compare signed Greater than (vector)", "full_desc": "Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMGT  <V><d>, <V><n>, <V><m>\t; Scalar", "CMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FMAD", "short_desc": "Floating-point fused multiply-add vectors (predicated), writing multiplicand [Zdn = Za + Zdn * Zm]", "full_desc": "Multiply the corresponding active floating-point elements of the first and second source vectors and add to elements of the third (addend) vector without intermediate rounding. Destructively place the results in the destination and first source (multiplicand) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMAD    <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Za>\nIs the name of the third source scalable vector register, encoded in the \"Za\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\ninteger a = UInt(Za);\nboolean op1_neg = FALSE;\nboolean op3_neg = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[a];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    bits(esize) element3 = Elem[operand3, e, esize];\n\n    if ElemP[mask, e, esize] == '1' then\n        if op1_neg then element1 = FPNeg(element1);\n        if op3_neg then element3 = FPNeg(element3);\n        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL", "short_desc": "Atomic unsigned maximum on word or doubleword in memory", "full_desc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDUMAX  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMAX", "LDUMAXA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMAXA", "LDUMAXAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMAXAL", "LDUMAXL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDUMAXL", "LDUMAX  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMAX", "LDUMAXA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMAXA", "LDUMAXAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMAXAL", "LDUMAXL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDUMAXL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "USQADD", "short_desc": "Unsigned saturating Accumulate of Signed value", "full_desc": "Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.", "syntax": ["USQADD  <V><d>, <V><n>\t; Scalar", "USQADD  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(datasize) operand2 = V[d];\ninteger op1;\ninteger op2;\nboolean sat;\n\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, e, esize], !unsigned);\n    op2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);\n    if sat then FPSR.QC = '1';\nV[d] = result;"}, {"mnemonic": "FCMGT (zero)", "short_desc": "Floating-point Compare Greater than zero (vector)", "full_desc": "Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FCMGT  <Hd>, <Hn>, #0.0\t; Scalar half precision", "FCMGT  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision", "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision", "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FMSUB", "short_desc": "Floating-point Fused Multiply-Subtract (scalar)", "full_desc": "Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, adds that to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.", "syntax": ["FMSUB  <Hd>, <Hn>, <Hm>, <Ha>\t; Half-precision", "FMSUB  <Sd>, <Sn>, <Sm>, <Sa>\t; Single-precision", "FMSUB  <Dd>, <Dn>, <Dm>, <Da>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Da>\nIs the 64-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Ha>\nIs the 16-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the \"Rm\" field.", "<Sa>\nIs the 32-bit name of the third SIMD&FP source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "UMAXP", "short_desc": "Unsigned Maximum Pairwise", "full_desc": "Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "STUMINH, STUMINLH", "short_desc": "Atomic unsigned minimum on halfword in memory, without return", "full_desc": "Atomic unsigned minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.", "syntax": ["STUMINH  <Ws>, [<Xn|SP>]\t; No memory ordering", "STUMINLH  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "UQDECD (scalar)", "short_desc": "Unsigned saturating decrement scalar by multiple of 64-bit predicate constraint element count", "full_desc": "Determines the number of active 64-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQDECD  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "UQDECD  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "ST1D (scalar plus vector)", "short_desc": "Scatter store doublewords from a vector (vector index)", "full_desc": "Scatter store of doublewords from the active elements of a vector register to the memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 8. Inactive elements are not written to memory.", "syntax": ["ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]\t; 32-bit unpacked scaled offset", "ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]\t; 64-bit scaled offset", "ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\ninteger offs_size = 32;\nboolean offs_unsigned = xs == '0';\ninteger scale = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(VL) offset = Z[m];\nbits(VL) src = Z[t];\nbits(PL) mask = P[g];\nbits(64) addr;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;"}, {"mnemonic": "TRN1, TRN2 (vectors)", "short_desc": "Interleave even or odd elements from two vectors", "full_desc": "Interleave alternating even or odd-numbered elements from the first and second source vectors and place in elements of the destination vector. This instruction is unpredicated. The 128-bit element variant of this instruction requires that the current vector length is at least 256 bits, and if the current vector length is not an integer multiple of 256 bits then the trailing bits are set to zero.", "syntax": ["TRN1    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Even", "TRN1    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Even (quadwords)", "TRN2    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; Odd", "TRN2    <Zd>.Q, <Zn>.Q, <Zm>.Q\t; Odd (quadwords)"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);\ninteger part = 0;", "operation": "CheckSVEEnabled();\nif VL < esize * 2 then UNDEFINED;\ninteger pairs = VL DIV (esize * 2);\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result = Zeros();\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\n\nZ[d] = result;"}, {"mnemonic": "URSRA", "short_desc": "Unsigned Rounding Shift Right and Accumulate (immediate)", "full_desc": "Unsigned Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see .", "syntax": ["URSRA  <V><d>, <V><n>, #<shift>\t; Scalar", "URSRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "ST2H (scalar plus scalar)", "short_desc": "Contiguous store two-halfword structures from two vectors (scalar index)", "full_desc": "Contiguous store two-halfword structures, each from the same element number in two vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by two. The index register is not updated by the instruction.", "syntax": ["ST2H    { <Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "STNT1W (scalar plus immediate)", "short_desc": "Contiguous store non-temporal words from vector (immediate index)", "full_desc": "Contiguous store non-temporal of words from elements of a vector register to the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements are not written to memory.", "syntax": ["STNT1W  { <Zt>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nconstant integer mbytes = esize DIV 8;\nbits(VL) src;\nbits(PL) mask = P[g];\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\nsrc = Z[t];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];\n    addr = addr + mbytes;"}, {"mnemonic": "FADD (immediate)", "short_desc": "Floating-point add immediate (predicated)", "full_desc": "Add an immediate to each active floating-point element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate may take the value +0.5 or +1.0 only. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FADD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\nbits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPAdd(element1, imm, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "SUB (immediate)", "short_desc": "Subtract immediate (unpredicated)", "full_desc": "Subtract an unsigned immediate from each element of the source vector, and destructively place the results in the corresponding elements of the source vector. This instruction is unpredicated.", "syntax": ["SUB     <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger imm = UInt(imm8);\nif sh == '1' then imm = imm << 8;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    Elem[result, e, esize] = element1 - imm;\n\nZ[dn] = result;"}, {"mnemonic": "BRKB, BRKBS", "short_desc": "Break before first true condition", "full_desc": "Sets destination predicate elements up to but not including the first active and true source element to true, then sets subsequent elements to false. Inactive elements in the destination predicate register remain unmodified or are set to zero, depending on whether merging or zeroing predication is selected. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["BRKB    <Pd>.B, <Pg>/<ZM>, <Pn>.B\t; Not setting the condition flags", "BRKBS   <Pd>.B, <Pg>/Z, <Pn>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<ZM>\n", "<Pn>\nIs the name of the source scalable predicate register, encoded in the \"Pn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger d = UInt(Pd);\nboolean merging = (M == '1');\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand  = P[n];\nbits(PL) operand2 = P[d];\nboolean break = FALSE;\nbits(PL) result;\n\nfor e = 0 to elements-1\n    boolean element = ElemP[operand, e, esize] == '1';\n    if ElemP[mask, e, esize] == '1' then\n        break = break || element;\n        ElemP[result, e, esize] = if !break then '1' else '0';\n    elsif merging then\n        ElemP[result, e, esize] = ElemP[operand2, e, esize];\n    else\n        ElemP[result, e, esize] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "ST3 (single structure)", "short_desc": "Store single 3-element structure from one lane of three registers", "full_desc": "Store single 3-element structure from one lane of three registers. This instruction stores a 3-element structure to memory from corresponding elements of three SIMD&FP registers.", "syntax": ["ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]\t; 8-bit", "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]\t; 16-bit", "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]\t; 32-bit", "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]\t; 64-bit", "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3\t; 8-bit, immediate offset", "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset", "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6\t; 16-bit, immediate offset", "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset", "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12\t; 32-bit, immediate offset", "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset", "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24\t; 64-bit, immediate offset", "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<index>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<index>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<index>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<index>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "CLZ", "short_desc": "Count Leading Zeros", "full_desc": "Count Leading Zeros counts the number of binary zero bits before the first binary one bit in the value of the source register, and writes the result to the destination register.", "syntax": ["CLZ  <Wd>, <Wn>\t; 32-bit", "CLZ  <Xd>, <Xn>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nCountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;", "operation": "integer result;\nbits(datasize) operand1 = X[n];\n\nif opcode == CountOp_CLZ then\n    result = CountLeadingZeroBits(operand1);\nelse\n    result = CountLeadingSignBits(operand1);\n\nX[d] = result<datasize-1:0>;"}, {"mnemonic": "SDOT (indexed)", "short_desc": "Signed integer indexed dot product", "full_desc": "The signed integer indexed dot product instruction computes the dot product of a group of four signed 8-bit or 16-bit integer values held in each 32-bit or 64-bit element of the first source vector multiplied by a group of four signed 8-bit or 16-bit integer values in an indexed 32-bit or 64-bit element of the second source vector, and then destructively adds the widened dot product to the corresponding 32-bit or 64-bit element of the destination vector.", "syntax": ["SDOT    <Zda>.S, <Zn>.B, <Zm>.B[<imm>]\t; 32-bit", "SDOT    <Zda>.D, <Zn>.H, <Zm>.H[<imm>]\t; 64-bit"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nFor the 32-bit variant: is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zm>\nFor the 64-bit variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<imm>\nFor the 32-bit variant: is the immediate index of a quadtuplet of four 8-bit elements within each 128-bit vector segment, in the range 0 to 3, encoded in the \"i2\" field.", "<imm>\nFor the 64-bit variant: is the immediate index of a quadtuplet of four 16-bit elements within each 128-bit vector segment, in the range 0 to 1, encoded in the \"i1\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger index = UInt(i2);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger eltspersegment = 128 DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = segmentbase + index;\n    bits(esize) res = Elem[operand3, e, esize];\n    for i = 0 to 3\n        integer element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n        integer element2 = SInt(Elem[operand2, 4 * s + i, esize DIV 4]);\n        res = res + element1 * element2;\n    Elem[result, e, esize] = res;\n\nZ[da] = result;"}, {"mnemonic": "CSINV", "short_desc": "Conditional Select Invert", "full_desc": "Conditional Select Invert returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the bitwise inversion value of the second source register.", "syntax": ["CSINV  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit", "CSINV  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"}, {"mnemonic": "PMUL", "short_desc": "Polynomial Multiply", "full_desc": "Polynomial Multiply. This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["PMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif U == '1' && size != '00' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean poly = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if poly then\n        product = PolynomialMult(element1, element2)<esize-1:0>;\n    else\n        product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;"}, {"mnemonic": "FSUB (scalar)", "short_desc": "Floating-point Subtract (scalar)", "full_desc": "Floating-point Subtract (scalar). This instruction subtracts the floating-point value of the second source SIMD&FP register from the floating-point value of the first source SIMD&FP register, and writes the result to the destination SIMD&FP register.", "syntax": ["FSUB  <Hd>, <Hn>, <Hm>\t; Half-precision", "FSUB  <Sd>, <Sn>, <Sm>\t; Single-precision", "FSUB  <Dd>, <Dn>, <Dm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean sub_op = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif sub_op then\n    result = FPSub(operand1, operand2, FPCR);\nelse\n    result = FPAdd(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "FMOV (scalar, immediate)", "short_desc": "Floating-point move immediate (scalar)", "full_desc": "Floating-point move immediate (scalar). This instruction copies a floating-point immediate constant into the SIMD&FP destination register.", "syntax": ["FMOV  <Hd>, #<imm>\t; Half-precision", "FMOV  <Sd>, #<imm>\t; Single-precision", "FMOV  <Dd>, #<imm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<imm>\nIs a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded in the \"imm8\" field. For details of the range of constants available and the encoding of , see ."], "decode": "integer d = UInt(Rd);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nbits(datasize) imm = VFPExpandImm(imm8);", "operation": "CheckFPAdvSIMDEnabled64();\n\nV[d] = imm;"}, {"mnemonic": "LD1B (scalar plus immediate)", "short_desc": "Contiguous load unsigned bytes to vector (immediate index)", "full_desc": "Contiguous load of unsigned bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1B    { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 8-bit element", "LD1B    { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element", "LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger msize = 8;\nboolean unsigned = TRUE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "FMINNMV", "short_desc": "Floating-point minimum number recursive reduction to scalar", "full_desc": "Floating-point minimum number horizontally over all lanes of a vector using a recursive pairwise reduction, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as the default NaN.", "syntax": ["FMINNMV <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(esize) identity = FPDefaultNaN();\n\nV[d] = ReducePredicated(ReduceOp_FMINNUM, operand, mask, identity);"}, {"mnemonic": "FTSSEL", "short_desc": "Floating-point trigonometric select coefficient", "full_desc": "The  instruction selects the coefficient for the final multiplication in the polynomial series approximation. The instruction places the value 1.0 or a copy of the first source vector element in the destination element, depending on bit 0 of the quadrant number  held in the corresponding element of the second source vector. The sign bit of the destination element is copied from bit 1 of the corresponding value of . This instruction is unpredicated.", "syntax": ["FTSSEL  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPTrigSSel(element1, element2);\n\nZ[d] = result;"}, {"mnemonic": "MOVK", "short_desc": "Move wide with keep", "full_desc": "Move wide with keep moves an optionally-shifted 16-bit immediate value into a register, keeping other bits unchanged.", "syntax": ["MOVK  <Wd>, #<imm>{, LSL #<shift>}\t; 32-bit", "MOVK  <Xd>, #<imm>{, LSL #<shift>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<imm>\nIs the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field.", "<shift>\nFor the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the \"hw\" field as <shift>/16.", "<shift>\nFor the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as <shift>/16."], "decode": "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\n\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UNDEFINED;\n\nif sf == '0' && hw<1> == '1' then UNDEFINED;\npos = UInt(hw:'0000');", "operation": "bits(datasize) result;\n\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\n\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nX[d] = result;"}, {"mnemonic": "BRKPA, BRKPAS", "short_desc": "Break after first true condition, propagating from previous partition", "full_desc": "If the last active element of the first source predicate is false then set the destination predicate to all-false. Otherwise sets destination predicate elements up to and including the first active and true source element to true, then sets subsequent elements to false. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["BRKPA   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags", "BRKPAS  <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\nboolean last = (LastActive(mask, operand1, 8) == '1');\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, 8] == '1' then\n        ElemP[result, e, 8] = if last then '1' else '0';\n        last = last && (ElemP[operand2, e, 8] == '0');\n    else\n        ElemP[result, e, 8] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "FCVTZS (vector, integer)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTZS  <Hd>, <Hn>\t; Scalar half precision", "FCVTZS  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTZS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTZS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "XTN, XTN2", "short_desc": "Extract Narrow", "full_desc": "Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.", "syntax": ["XTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    Elem[result, e, esize] = element<esize-1:0>;\nVpart[d, part] = result;"}, {"mnemonic": "SQSHL (immediate)", "short_desc": "Signed saturating Shift Left (immediate)", "full_desc": "Signed saturating Shift Left (immediate). This instruction reads each vector element in the source SIMD&FP register, shifts each result by an immediate value, places the final result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see .", "syntax": ["SQSHL  <V><d>, <V><n>, #<shift>\t; Scalar", "SQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UNDEFINED;\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "FCVTMS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTMS  <Hd>, <Hn>\t; Scalar half precision", "FCVTMS  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTMS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTMS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "LD1SB (scalar plus immediate)", "short_desc": "Contiguous load signed bytes to vector (immediate index)", "full_desc": "Contiguous load of signed bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1SB   { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element", "LD1SB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 8;\nboolean unsigned = FALSE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "FRINTA (vector)", "short_desc": "Floating-point Round to Integral, to nearest with ties to Away (vector)", "full_desc": "Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTA  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FRINTA  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "DUP (element)", "short_desc": "Duplicate vector element to vector or scalar", "full_desc": "Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.", "syntax": ["DUP  <V><d>, <Vn>.<T>[<index>]\t; Scalar", "DUP  <Vd>.<T>, <Vn>.<Ts>[<index>]\t; Vector"], "symbols": ["<T>\n", "<T>\n", "<Ts>\n", "<V>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<index>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UNDEFINED;\n\ninteger index = UInt(imm5<4:size+1>);\ninteger idxdsize = if imm5<4> == '1' then 128 else 64; \n\ninteger esize = 8 << size;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nelement = Elem[operand, index, esize];\nfor e = 0 to elements-1\n    Elem[result, e, esize] = element;\nV[d] = result;"}, {"mnemonic": "AND (immediate)", "short_desc": "Bitwise AND with immediate (unpredicated)", "full_desc": "Bitwise AND an immediate with each 64-bit element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is a 64-bit value consisting of a single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction is unpredicated.", "syntax": ["AND     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<const>\nIs a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger dn = UInt(Zdn);\nbits(64) imm;\n(imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 64;\nbits(VL) operand = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(64) element1 = Elem[operand, e, 64];\n    Elem[result, e, 64] = element1 AND imm;\n\nZ[dn] = result;"}, {"mnemonic": "FACLE", "short_desc": "Floating-point absolute compare less than or equal", "full_desc": "Compare active absolute values of floating-point elements in the first source vector being less than or equal to corresponding absolute values of elements in the second source vector, and place the boolean results of the comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Does not set the condition flags.", "syntax": ["FACLE   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than or equal"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."]}, {"mnemonic": "FMAXNMV", "short_desc": "Floating-point maximum number recursive reduction to scalar", "full_desc": "Floating-point maximum number horizontally over all lanes of a vector using a recursive pairwise reduction, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as the default NaN.", "syntax": ["FMAXNMV <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(esize) identity = FPDefaultNaN();\n\nV[d] = ReducePredicated(ReduceOp_FMAXNUM, operand, mask, identity);"}, {"mnemonic": "LDEORH, LDEORAH, LDEORALH, LDEORLH", "short_desc": "Atomic exclusive OR on halfword in memory", "full_desc": "Atomic exclusive OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDEORAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORAH", "LDEORALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORALH", "LDEORH  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORH", "LDEORLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDEORLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SUNPKHI, SUNPKLO", "short_desc": "Signed unpack and extend half of vector", "full_desc": "Unpack elements from the lowest or highest half of the source vector and then sign-extend them to place in elements of twice their size within the destination vector. This instruction is unpredicated.", "syntax": ["SUNPKHI <Zd>.<T>, <Zn>.<Tb>\t; High half", "SUNPKLO <Zd>.<T>, <Zn>.<Tb>\t; Low half"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Tb>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\nboolean unsigned = FALSE;\nboolean hi = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger hsize = esize DIV 2;\nbits(VL) operand = Z[n];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(hsize) element = if hi then Elem[operand, e + elements, hsize] else Elem[operand, e, hsize];\n    Elem[result, e, esize] = Extend(element, esize, unsigned);\n\nZ[d] = result;"}, {"mnemonic": "FCADD", "short_desc": "Floating-point Complex Add", "full_desc": "Floating-point Complex Add.", "syntax": ["FCADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<rotate>\n"], "decode": "if !HaveFCADDExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' then UNDEFINED;\nif Q == '0' && size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\nif !HaveFP16Ext() && esize == 16 then UNDEFINED;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element3;\n\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '0'\n            element1 = FPNeg(Elem[operand2, e*2+1, esize]); \n            element3 = Elem[operand2, e*2, esize];\n        when '1'\n            element1 = Elem[operand2, e*2+1, esize]; \n            element3 = FPNeg(Elem[operand2, e*2, esize]);   \n    Elem[result, e*2,   esize] = FPAdd(Elem[operand1, e*2, esize], element1, FPCR);\n    Elem[result, e*2+1, esize] = FPAdd(Elem[operand1, e*2+1, esize], element3, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ORN (immediate)", "short_desc": "Bitwise inclusive OR with inverted immediate (unpredicated)", "full_desc": "Bitwise inclusive OR an inverted immediate with each 64-bit element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is a 64-bit value consisting of a single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction is unpredicated.", "syntax": ["ORN     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<const>\nIs a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."]}, {"mnemonic": "UZP2", "short_desc": "Unzip vectors (secondary)", "full_desc": "Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UZP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operandl = V[n];\nbits(datasize) operandh = V[m];\nbits(datasize) result;\n\nbits(datasize*2) zipped = operandh:operandl;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\n\nV[d] = result;"}, {"mnemonic": "SUBS (immediate)", "short_desc": "Subtract (immediate), setting flags", "full_desc": "Subtract (immediate), setting flags, subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["SUBS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}\t; 32-bit", "SUBS  <Xd>, <Xn|SP>, #<imm>{, <shift>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn|WSP>\nIs the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase sh of\n    when '0' imm = ZeroExtend(imm12, datasize);\n    when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LD4W (scalar plus scalar)", "short_desc": "Contiguous load four-word structures to four vectors (scalar index)", "full_desc": "Contiguous load four-word structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by four. The index register is not updated by the instruction.", "syntax": ["LD4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "ST4D (scalar plus immediate)", "short_desc": "Contiguous store four-doubleword structures from four vectors (immediate index)", "full_desc": "Contiguous store four-doubleword structures, each from the same element number in four vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 4 in the range -32 to 28 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "LDAXP", "short_desc": "Load-Acquire Exclusive Pair of Registers", "full_desc": "Load-Acquire Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See . The instruction also has memory ordering semantics as described in . For information about memory accesses see .", "syntax": ["LDAXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit", "LDAXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Wt1>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LD3W (scalar plus immediate)", "short_desc": "Contiguous load three-word structures to three vectors (immediate index)", "full_desc": "Contiguous load three-word structures, each to the same element number in three vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 3 in the range -24 to 21 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "FCVTPU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTPU  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTPU  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTPU  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTPU  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTPU  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTPU  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "ST3D (scalar plus scalar)", "short_desc": "Contiguous store three-doubleword structures from three vectors (scalar index)", "full_desc": "Contiguous store three-doubleword structures, each from the same element number in three vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by three. The index register is not updated by the instruction.", "syntax": ["ST3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "REV16 (vector)", "short_desc": "Reverse elements in 16-bit halfwords (vector)", "full_desc": "Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["REV16  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\n// size=esize:   B(0),  H(1),  S(1), D(S)\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\n\n// op=REVx: 64(0), 32(1), 16(2)\nbits(2) op = o0:U; \n\n// => op+size: \n//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X\n//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X\n//    16+B = 2, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n// => 3-(op+size) (index bits in group)\n//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X\n//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X\n//    16+B = 1, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n\n// index bits within group: 1, 2, 3\nif UInt(op)+UInt(size) >= 3 then UNDEFINED;\n\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;"}, {"mnemonic": "ST1B (scalar plus scalar)", "short_desc": "Contiguous store bytes from vector (scalar index)", "full_desc": "Contiguous store of bytes from elements of a vector register to the memory address generated by a 64-bit scalar base and scalar index which is added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements are not written to memory.", "syntax": ["ST1B    { <Zt>.<T> }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8 << UInt(size);\ninteger msize = 8;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nbits(VL) src = Z[t];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;\n    offset = offset + 1;"}, {"mnemonic": "DUPM", "short_desc": "Broadcast logical bitmask immediate to vector (unpredicated)", "full_desc": "Unconditionally broadcast the logical bitmask immediate into each element of the destination vector. This instruction is unpredicated. The immediate is a 64-bit value consisting of a single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits.", "syntax": ["DUPM    <Zd>.<T>, #<const>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<const>\nIs a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger d = UInt(Zd);\nbits(esize) imm;\n(imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);", "operation": "CheckSVEEnabled();\nbits(VL) result = Replicate(imm);\nZ[d] = result;"}, {"mnemonic": "ST1B (vector plus immediate)", "short_desc": "Scatter store bytes from a vector (immediate index)", "full_desc": "Scatter store of bytes from the active elements of a vector register to the memory addresses generated by a vector base plus immediate index. The index is in the range 0 to 31. Inactive elements are not written to memory.", "syntax": ["ST1B    { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element", "ST1B    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 8;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(VL) src = Z[t];\nbits(PL) mask = P[g];\nbits(64) addr;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;"}, {"mnemonic": "DUP (immediate)", "short_desc": "Broadcast signed immediate to vector elements (unpredicated)", "full_desc": "Unconditionally broadcast the signed integer immediate into each element of the destination vector. This instruction is unpredicated.", "syntax": ["DUP     <Zd>.<T>, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<imm>\nIs a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger d = UInt(Zd);\ninteger imm = SInt(imm8);\nif sh == '1' then imm = imm << 8;", "operation": "CheckSVEEnabled();\nbits(VL) result = Replicate(imm<esize-1:0>);\nZ[d] = result;"}, {"mnemonic": "STP (SIMD&FP)", "short_desc": "Store Pair of SIMD&FP registers", "full_desc": "Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP registers to memory. The address used for the store is calculated from a base register value and an immediate offset.", "syntax": ["STP  <St1>, <St2>, [<Xn|SP>], #<imm>\t; 32-bit", "STP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>\t; 64-bit", "STP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>\t; 128-bit", "STP  <St1>, <St2>, [<Xn|SP>, #<imm>]!\t; 32-bit", "STP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!\t; 64-bit", "STP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!\t; 128-bit", "STP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit", "STP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit", "STP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit"], "symbols": ["<Dt1>\nIs the 64-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt2>\nIs the 64-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Qt1>\nIs the 128-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt2>\nIs the 128-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<St1>\nIs the 32-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St2>\nIs the 32-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the \"imm7\" field as <imm>/8.", "<imm>\nFor the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8.", "<imm>\nFor the 128-bit post-index and 128-bit pre-index variant: is the signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, encoded in the \"imm7\" field as <imm>/16.", "<imm>\nFor the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as <imm>/16."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VEC;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UNDEFINED;\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\nboolean tag_checked = wback || n != 31;"}, {"mnemonic": "LDADDH, LDADDAH, LDADDALH, LDADDLH", "short_desc": "Atomic add on halfword in memory", "full_desc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDADDAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDAH", "LDADDALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDALH", "LDADDH  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDH", "LDADDLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDADDLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "USHL", "short_desc": "Unsigned Shift Left (register)", "full_desc": "Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["USHL  <V><d>, <V><n>, <V><m>\t; Scalar", "USHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQINCH (vector)", "short_desc": "Signed saturating increment vector by multiple of 16-bit predicate constraint element count", "full_desc": "Determines the number of active 16-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment all destination vector elements. The results are saturated to the 16-bit signed integer range.", "syntax": ["SQINCH  <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "FCMLT (zero)", "short_desc": "Floating-point Compare Less than zero (vector)", "full_desc": "Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FCMLT  <Hd>, <Hn>, #0.0\t; Scalar half precision", "FCMLT  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision", "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision", "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison = CompareOp_LT;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FRINT64X (scalar)", "short_desc": "Floating-point Round to 64-bit Integer, using current rounding mode (scalar)", "full_desc": "Floating-point Round to 64-bit Integer, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 64-bit integer size using the rounding mode that is determined by the , and writes the result to the SIMD&FP destination register.", "syntax": ["FRINT64X  <Sd>, <Sn>\t; Single-precision", "FRINT64X  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFrintExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '1x' UNDEFINED;\n\ninteger intsize = if op<1> == '0' then 32 else 64;\n\nFPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundIntN(operand, FPCR, rounding, intsize);\n\nV[d] = result;"}, {"mnemonic": "LDAXR", "short_desc": "Load-Acquire Exclusive Register", "full_desc": "Load-Acquire Exclusive Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See . The instruction also has memory ordering semantics as described in . For information about memory accesses see .", "syntax": ["LDAXR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit", "LDAXR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SMIN (immediate)", "short_desc": "Signed minimum with immediate (unpredicated)", "full_desc": "Determine the signed minimum of an immediate and each element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is a signed 8-bit value in the range -128 to +127, inclusive. This instruction is unpredicated.", "syntax": ["SMIN    <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs the signed immediate operand, in the range -128 to 127, encoded in the \"imm8\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\nboolean unsigned = FALSE;\ninteger imm = Int(imm8, unsigned);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    Elem[result, e, esize] = Min(element1, imm)<esize-1:0>;\n\nZ[dn] = result;"}, {"mnemonic": "UADDLV", "short_desc": "Unsigned sum Long across Vector", "full_desc": "Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values.", "syntax": ["UADDLV  <V><d>, <Vn>.<T>\t; Advanced SIMD"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger sum;\n\nsum = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    sum = sum + Int(Elem[operand, e, esize], unsigned);\n\nV[d] = sum<2*esize-1:0>;"}, {"mnemonic": "SUBS (extended register)", "short_desc": "Subtract (extended register), setting flags", "full_desc": "Subtract (extended register), setting flags, subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the  register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result.", "syntax": ["SUBS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\t; 32-bit", "SUBS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn|WSP>\nIs the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<R>\n", "<m>\nIs the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<extend>\n", "<extend>\n", "<amount>\nIs the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when <extend> is absent, is required when <extend> is LSL, and is optional when <extend> is present but not LSL."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then UNDEFINED;", "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "FMLS (by element)", "short_desc": "Floating-point fused Multiply-Subtract from accumulator (by element)", "full_desc": "Floating-point fused Multiply-Subtract from accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and subtracts the results from the vector elements of the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMLS  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision", "FMLS  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nFor the half-precision variant: is the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<Vm>\nFor the single-precision and double-precision variant: is the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<Ts>\n", "<index>\nFor the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields.", "<index>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);\ninteger index = UInt(H:L:M);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "UBFX", "short_desc": "Unsigned Bitfield Extract", "full_desc": "Unsigned Bitfield Extract copies a bitfield of  bits starting from bit position  in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to zero.", "syntax": ["UBFX  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit", "UBFX  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<lsb>\nFor the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.", "<lsb>\nFor the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.", "<width>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<width>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "INCP (scalar)", "short_desc": "Increment scalar by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to increment the scalar destination.", "syntax": ["INCP    <Xdn>, <Pm>.<T>\t; SVE"], "symbols": ["<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Rdn);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) operand1 = X[dn];\nbits(PL) operand2 = P[m];\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\nX[dn] = operand1 + count;"}, {"mnemonic": "MOV (bitmask immediate)", "short_desc": "Move logical bitmask immediate to vector (unpredicated)", "full_desc": "Unconditionally broadcast the logical bitmask immediate into each element of the destination vector. This instruction is unpredicated. The immediate is a 64-bit value consisting of a single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits.", "syntax": ["MOV     <Zd>.<T>, #<const>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<const>\nIs a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."]}, {"mnemonic": "XAR", "short_desc": "Exclusive OR and Rotate", "full_desc": "Exclusive OR and Rotate performs a bitwise exclusive OR of the 128-bit vectors in the two source SIMD&FP registers, rotates each 64-bit element of the resulting 128-bit vector right by the value specified by a 6-bit immediate value, and writes the result to the destination SIMD&FP register.", "syntax": ["XAR  <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<imm6>\nIs a rotation right, encoded in \"imm6\"."], "decode": "if !HaveSHA3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) tmp;\ntmp = Vn EOR Vm; \nV[d] = ROR(tmp<127:64>, UInt(imm6)):ROR(tmp<63:0>, UInt(imm6));"}, {"mnemonic": "FCMLA (vectors)", "short_desc": "Floating-point complex multiply-add with rotate (predicated)", "full_desc": "Multiply the duplicated real components for rotations 0 and 180, or imaginary components for rotations 90 and 270, of the floating-point complex numbers in the first source vector by the corresponding complex number in the second source vector rotated by 0, 90, 180 or 270 degrees in the direction from the positive real axis towards the positive imaginary axis, when considered in polar representation.", "syntax": ["FCMLA   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>, <const>\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\ninteger sel_a = UInt(rot<0>);\ninteger sel_b = UInt(NOT(rot<0>));\nboolean neg_i = (rot<1> == '1');\nboolean neg_r = (rot<0> != rot<1>);", "operation": "CheckSVEEnabled();\ninteger pairs = VL DIV (2 * esize);\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor p = 0 to pairs-1\n    addend_r = Elem[operand3, 2 * p + 0, esize];\n    addend_i = Elem[operand3, 2 * p + 1, esize];\n    elt1_a   = Elem[operand1, 2 * p + sel_a, esize];\n    elt2_a   = Elem[operand2, 2 * p + sel_a, esize];\n    elt2_b   = Elem[operand2, 2 * p + sel_b, esize];\n    if ElemP[mask, 2 * p + 0, esize] == '1' then\n        if neg_r then elt2_a = FPNeg(elt2_a);\n        addend_r = FPMulAdd(addend_r, elt1_a, elt2_a, FPCR<31:0>);\n    if ElemP[mask, 2 * p + 1, esize] == '1' then\n        if neg_i then elt2_b = FPNeg(elt2_b);\n        addend_i = FPMulAdd(addend_i, elt1_a, elt2_b, FPCR<31:0>);\n    Elem[result, 2 * p + 0, esize] = addend_r;\n    Elem[result, 2 * p + 1, esize] = addend_i;\n\nZ[da] = result;"}, {"mnemonic": "ADDG", "short_desc": "Add with Tag", "full_desc": "Add with Tag adds an immediate value scaled by the Tag granule to the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag.", "syntax": ["ADDG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>\t; Integer"], "symbols": ["<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Xd\" field.", "<Xn|SP>\nIs the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<uimm6>\nIs an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the \"uimm6\" field.", "<uimm4>\nIs an unsigned immediate, in the range 0 to 15, encoded in the \"uimm4\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger d = UInt(Xd);\ninteger n = UInt(Xn);\nbits(4) tag_offset = uimm4;\nbits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);\nboolean ADD = TRUE;", "operation": "bits(64) operand1 = if n == 31 then SP[] else X[n];\nbits(4) start_tag = AArch64.AllocationTagFromAddress(operand1);\nbits(16) exclude = GCR_EL1.Exclude;\nbits(64) result;\nbits(4) rtag;\n\nif AArch64.AllocationTagAccessIsEnabled(AccType_NORMAL) then\n    rtag = AArch64.ChooseNonExcludedTag(start_tag, tag_offset, exclude);\nelse\n    rtag = '0000';\n\nif ADD then\n    (result, -) = AddWithCarry(operand1, offset, '0');\nelse\n    (result, -) = AddWithCarry(operand1, NOT(offset), '1');\n\nresult = AArch64.AddressWithAllocationTag(result, AccType_NORMAL, rtag);\n\nif d == 31 then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "FNMSB", "short_desc": "Floating-point negated fused multiply-subtract vectors (predicated), writing multiplicand [Zdn = -Za + Zdn * Zm]", "full_desc": "Multiply the corresponding active floating-point elements of the first and second source vectors and subtract from elements of the third (addend) vector without intermediate rounding. Destructively place the negated results in the destination and first source (multiplicand) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FNMSB   <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Za>\nIs the name of the third source scalable vector register, encoded in the \"Za\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\ninteger a = UInt(Za);\nboolean op1_neg = FALSE;\nboolean op3_neg = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[a];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    bits(esize) element3 = Elem[operand3, e, esize];\n\n    if ElemP[mask, e, esize] == '1' then\n        if op1_neg then element1 = FPNeg(element1);\n        if op3_neg then element3 = FPNeg(element3);\n        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "LDNT1H (scalar plus scalar)", "short_desc": "Contiguous load non-temporal halfwords to vector (scalar index)", "full_desc": "Contiguous load non-temporal of halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 2 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNT1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(64) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = X[m];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "SQDMULL, SQDMULL2 (by element)", "short_desc": "Signed saturating Doubling Multiply Long (by element)", "full_desc": "Signed saturating Doubling Multiply Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.", "syntax": ["SQDMULL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]\t; Scalar", "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Va>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vb>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);\n    Elem[result, e, 2*esize] = product;\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "SQRSHRUN, SQRSHRUN2", "short_desc": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate)", "full_desc": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&FP register. The results are rounded. For truncated results, see .", "syntax": ["SQRSHRUN  <Vb><d>, <Va><n>, #<shift>\t; Scalar", "SQRSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<Vb>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<Va>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then UNDEFINED;\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"}, {"mnemonic": "CMHS (register)", "short_desc": "Compare unsigned Higher or Same (vector)", "full_desc": "Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMHS  <V><d>, <V><n>, <V><m>\t; Scalar", "CMHS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "SQRDMULH (vector)", "short_desc": "Signed saturating Rounding Doubling Multiply returning High half", "full_desc": "Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SQRDMULH  <V><d>, <V><n>, <V><m>\t; Scalar", "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "SXTB", "short_desc": "Signed Extend Byte", "full_desc": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["SXTB  <Wd>, <Wn>\t; 32-bit", "SXTB  <Xd>, <Wn>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "SMINV", "short_desc": "Signed Minimum across Vector", "full_desc": "Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.", "syntax": ["SMINV  <V><d>, <Vn>.<T>\t; Advanced SIMD"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"}, {"mnemonic": "FCVTAU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTAU  <Hd>, <Hn>\t; Scalar half precision", "FCVTAU  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTAU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTAU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "SMAXV", "short_desc": "Signed Maximum across Vector", "full_desc": "Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.", "syntax": ["SMAXV  <V><d>, <Vn>.<T>\t; Advanced SIMD"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"}, {"mnemonic": "LD4D (scalar plus scalar)", "short_desc": "Contiguous load four-doubleword structures to four vectors (scalar index)", "full_desc": "Contiguous load four-doubleword structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by four. The index register is not updated by the instruction.", "syntax": ["LD4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "LDFF1H (scalar plus vector)", "short_desc": "Gather load first-fault unsigned halfwords to vector (vector index)", "full_desc": "Gather load with first-faulting behavior of unsigned halfwords to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 2. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LDFF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\ninteger offs_size = 32;\nboolean unsigned = TRUE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 1;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "ST4W (scalar plus immediate)", "short_desc": "Contiguous store four-word structures from four vectors (immediate index)", "full_desc": "Contiguous store four-word structures, each from the same element number in four vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 4 in the range -32 to 28 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "MVN", "short_desc": "Bitwise NOT (vector)", "full_desc": "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["MVN  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."]}, {"mnemonic": "LD3D (scalar plus immediate)", "short_desc": "Contiguous load three-doubleword structures to three vectors (immediate index)", "full_desc": "Contiguous load three-doubleword structures, each to the same element number in three vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 3 in the range -24 to 21 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "ST3W (scalar plus scalar)", "short_desc": "Contiguous store three-word structures from three vectors (scalar index)", "full_desc": "Contiguous store three-word structures, each from the same element number in three vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by three. The index register is not updated by the instruction.", "syntax": ["ST3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "LDP", "short_desc": "Load Pair of Registers", "full_desc": "Load Pair of Registers calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information about memory accesses, see .", "syntax": ["LDP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>\t; 32-bit", "LDP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>\t; 64-bit", "LDP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!\t; 32-bit", "LDP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!\t; 64-bit", "LDP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\t; 32-bit", "LDP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit"], "symbols": ["<Wt1>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the \"imm7\" field as <imm>/8.", "<imm>\nFor the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_NORMAL;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif L:opc<0> == '01' || opc == '11' then UNDEFINED;\nboolean signed = (opc<0> != '0');\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\nboolean tag_checked = wback || n != 31;"}, {"mnemonic": "UXTH", "short_desc": "Unsigned Extend Halfword", "full_desc": "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register.", "syntax": ["UXTH  <Wd>, <Wn>\t; 32-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "ASR (vectors)", "short_desc": "Arithmetic shift right by vector (predicated)", "full_desc": "Shift right, preserving the sign bit, active elements of the first source vector by corresponding elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. The shift amount operand is a vector of unsigned elements in which all bits are significant, and not used modulo the element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    integer shift = Min(UInt(element2), esize);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = ASR(element1, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "ANDV", "short_desc": "Bitwise AND reduction to scalar", "full_desc": "Bitwise AND horizontally across all lanes of a vector, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as all ones.", "syntax": ["ANDV    <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(esize) result = Ones(esize);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        result = result AND Elem[operand, e, esize];\n\nV[d] = result;"}, {"mnemonic": "FMAX (vector)", "short_desc": "Floating-point Maximum (vector)", "full_desc": "Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "WHILELS", "short_desc": "While incrementing unsigned scalar lower or same as scalar", "full_desc": "Generate a predicate that starting from the lowest numbered element is true while the incrementing value of the first, unsigned scalar operand is lower or same as the second scalar operand and false thereafter up to the highest numbered element.", "syntax": ["WHILELS <Pd>.<T>, <R><n>, <R><m>\t; SVE"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<R>\n", "<n>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field.", "<m>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger rsize = 32 << UInt(sf);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Pd);\nboolean unsigned = TRUE;\nSVECmp op = Cmp_LE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = Ones(PL);\nbits(rsize) operand1 = X[n];\nbits(rsize) operand2 = X[m];\nbits(PL) result;\nboolean last = TRUE;\n\nfor e = 0 to elements-1\n    boolean cond;\n    case op of\n        when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));\n        when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));\n\n    last = last && cond;\n    ElemP[result, e, esize] = if last then '1' else '0';\n    operand1 = operand1 + 1;\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "CSINC", "short_desc": "Conditional Select Increment", "full_desc": "Conditional Select Increment returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register incremented by 1.", "syntax": ["CSINC  <Wd>, <Wn>, <Wm>, <cond>\t; 32-bit", "CSINC  <Xd>, <Xn>, <Xm>, <cond>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"}, {"mnemonic": "PRFB (vector plus immediate)", "short_desc": "Gather prefetch bytes (vector plus immediate)", "full_desc": "Gather prefetch of bytes from the active memory addresses generated by a vector base plus immediate index. The index is in the range 0 to 31. Inactive addresses are not prefetched from memory.", "syntax": ["PRFB    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element", "PRFB    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 0;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) base;\nbits(64) addr;\nbase = Z[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);"}, {"mnemonic": "PRFB (scalar plus scalar)", "short_desc": "Contiguous prefetch bytes (scalar index)", "full_desc": "Contiguous prefetch of byte elements from the memory address generated by a 64-bit scalar base and scalar index which is added to the base address. After each element prefetch the index value is incremented, but the index register is not updated.", "syntax": ["PRFB    <prfop>, <Pg>, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 0;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) offset = X[m];\nbits(64) addr;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + (UInt(offset) << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);\n    offset = offset + 1;"}, {"mnemonic": "UDIV", "short_desc": "Unsigned Divide", "full_desc": "Unsigned Divide divides an unsigned integer register value by another unsigned integer register value, and writes the result to the destination register. The condition flags are not affected.", "syntax": ["UDIV  <Wd>, <Wn>, <Wm>\t; 32-bit", "UDIV  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean unsigned = (o1 == '0');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\n\nif IsZero(operand2) then\n    result = 0;\nelse\n    result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));\n\nX[d] = result<datasize-1:0>;"}, {"mnemonic": "CSETM", "short_desc": "Conditional Set Mask", "full_desc": "Conditional Set Mask sets all bits of the destination register to 1 if the condition is TRUE, and otherwise sets all bits to 0.", "syntax": ["CSETM  <Wd>, <cond>\t; 32-bit", "CSETM  <Xd>, <cond>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "STLXRB", "short_desc": "Store-Release Exclusive Register Byte", "full_desc": "Store-Release Exclusive Register Byte stores a byte from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See . The memory access is atomic. The instruction also has memory ordering semantics as described in . For information about memory accesses see .", "syntax": ["STLXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FRINT64Z (vector)", "short_desc": "Floating-point Round to 64-bit Integer toward Zero (vector)", "full_desc": "Floating-point Round to 64-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINT64Z  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFrintExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then UNDEFINED;\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger intsize = if op == '0' then 32 else 64; \nFPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);\n\nV[d] = result;"}, {"mnemonic": "SADALP", "short_desc": "Signed Add and Accumulate Long Pairwise", "full_desc": "Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.", "syntax": ["SADALP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nif acc then result = V[d];\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    if acc then\n        Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n    else\n        Elem[result, e, 2*esize] = sum;\n\nV[d] = result;"}, {"mnemonic": "LD1RQH (scalar plus immediate)", "short_desc": "Contiguous load and replicate eight halfwords (immediate index)", "full_desc": "Load eight contiguous halfwords to elements of a short, 128-bit (quadword) vector from the memory address generated by a 64-bit scalar base address and immediate index that is a multiple of 16 in the range -128 to +112 added to the base address.", "syntax": ["LD1RQH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate byte offset, a multiple of 16 in the range -128 to 112, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = 128 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low 16 bits only\nbits(128) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * 16;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = Replicate(result, VL DIV 128);"}, {"mnemonic": "EOR (vector)", "short_desc": "Bitwise Exclusive OR (vector)", "full_desc": "Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.", "syntax": ["EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"}, {"mnemonic": "SM3TT1A", "short_desc": "SM3TT1A", "full_desc": "SM3TT1A takes three 128-bit vectors from three source SIMD&FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register.  It performs a three-way exclusive OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:", "syntax": ["SM3TT1A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field.", "<imm2>\nIs a 32-bit element indexed out of <Vm>, encoded in \"imm2\"."], "decode": "if !HaveSM3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger i = UInt(imm2);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) WjPrime;\nbits(128) result; \nbits(32) TT1;\nbits(32) SS2;\n\nWjPrime = Elem[Vm,i,32];\nSS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); \nTT1 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);\nTT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,9); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT1; \nV[d] = result;"}, {"mnemonic": "LD1ROD (scalar plus immediate)", "short_desc": "Contiguous load and replicate four doublewords (immediate index)", "full_desc": "Load four contiguous doublewords to elements of a 256-bit (octaword) vector from the memory address generated by a 64-bit scalar base address and immediate index that is a multiple of 32 in the range -256 to +224 added to the base address.", "syntax": ["LD1ROD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate byte offset, a multiple of 32 in the range -256 to 224, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVEFP64MatMulExt() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\nif VL < 256 then UNDEFINED;\ninteger elements = 256 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low bits only\nbits(256) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * 32;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);"}, {"mnemonic": "FMLA (indexed)", "short_desc": "Floating-point fused multiply-add by indexed elements (Zda = Zda + Zn * Zm[indexed])", "full_desc": "Multiply all floating-point elements within each 128-bit segment of the first source vector by the specified element in the corresponding second source vector segment. The products are then destructively added without intermediate rounding to the corresponding elements of the addend and destination vector.", "syntax": ["FMLA    <Zda>.H, <Zn>.H, <Zm>.H[<imm>]\t; Half-precision", "FMLA    <Zda>.S, <Zn>.S, <Zm>.S[<imm>]\t; Single-precision", "FMLA    <Zda>.D, <Zn>.D, <Zm>.D[<imm>]\t; Double-precision"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nFor the half-precision and single-precision variant: is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zm>\nFor the double-precision variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<imm>\nFor the half-precision variant: is the immediate index, in the range 0 to 7, encoded in the \"i3h:i3l\" fields.", "<imm>\nFor the single-precision variant: is the immediate index, in the range 0 to 3, encoded in the \"i2\" field.", "<imm>\nFor the double-precision variant: is the immediate index, in the range 0 to 1, encoded in the \"i1\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger index = UInt(i3h:i3l);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean op1_neg = FALSE;\nboolean op3_neg = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger eltspersegment = 128 DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result = Z[da];\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = segmentbase + index;\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, s, esize];\n    bits(esize) element3 = Elem[result, e, esize];\n    if op1_neg then element1 = FPNeg(element1);\n    if op3_neg then element3 = FPNeg(element3);\n    Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n\nZ[da] = result;"}, {"mnemonic": "SMULL, SMULL2 (by element)", "short_desc": "Signed Multiply Long (vector, by element)", "full_desc": "Signed Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = product;\n\nV[d] = result;"}, {"mnemonic": "SETFFR", "short_desc": "Initialise the first-fault register to all true", "full_desc": "Initialise the first-fault register () to all true prior to a sequence of first-fault or non-fault loads. This instruction is unpredicated.", "syntax": ["SETFFR\t; SVE"], "symbols": [], "decode": "if !HaveSVE() then UNDEFINED;", "operation": "CheckSVEEnabled();\nFFR[] = Ones(PL);"}, {"mnemonic": "BFMLALB, BFMLALT (by element)", "short_desc": "BFloat16 floating-point widening multiply-add long (by element)", "full_desc": "BFloat16 floating-point widening multiply-add long (by element) widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first source vector, and the indexed element in the second source vector from Bfloat16 to single-precision format. The instruction then multiplies and adds these values to the overlapping single-precision elements of the destination vector.", "syntax": ["BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.H[<index>]\t; Vector"], "symbols": ["<bt>\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<index>\nIs the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields."], "decode": "if !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Rn);\ninteger m = UInt('0':Rm);\ninteger d = UInt(Rd);\ninteger index = UInt(H:L:M);\n\ninteger elements = 128 DIV 32;\ninteger sel = UInt(Q);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(128) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(128) operand3 = V[d];\nbits(128) result;\n\nbits(32) element2 = Elem[operand2, index, 16] : Zeros(16);\n\nfor e = 0 to elements-1\n    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);\n    bits(32) addend = Elem[operand3, e, 32];\n    Elem[result, e, 32] = FPMulAdd(addend, element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ADDP (scalar)", "short_desc": "Add Pair of elements (scalar)", "full_desc": "Add Pair of elements (scalar). This instruction adds two vector elements in the source SIMD&FP register and writes the scalar result into the destination SIMD&FP register.", "syntax": ["ADDP  <V><d>, <Vn>.<T>\t; Advanced SIMD"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then UNDEFINED;\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = ReduceOp_ADD;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "UMLSL, UMLSL2 (vector)", "short_desc": "Unsigned Multiply-Subtract Long (vector)", "full_desc": "Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.", "syntax": ["UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"}, {"mnemonic": "LDR (immediate)", "short_desc": "Load Register (immediate)", "full_desc": "Load Register (immediate) loads a word or doubleword from memory and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see . The Unsigned offset variant scales the immediate offset value by the size of the value accessed before adding it to the base register value.", "syntax": ["LDR  <Wt>, [<Xn|SP>], #<simm>\t; 32-bit", "LDR  <Xt>, [<Xn|SP>], #<simm>\t; 64-bit", "LDR  <Wt>, [<Xn|SP>, #<simm>]!\t; 32-bit", "LDR  <Xt>, [<Xn|SP>, #<simm>]!\t; 64-bit", "LDR  <Wt>, [<Xn|SP>{, #<pimm>}]\t; 32-bit", "LDR  <Xt>, [<Xn|SP>{, #<pimm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>\nFor the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/4.", "<pimm>\nFor the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as <pimm>/8."], "decode": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "UQINCW (scalar)", "short_desc": "Unsigned saturating increment scalar by multiple of 32-bit predicate constraint element count", "full_desc": "Determines the number of active 32-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQINCW  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "UQINCW  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "FMAXV", "short_desc": "Floating-point Maximum across Vector", "full_desc": "Floating-point Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMAXV  <V><d>, <Vn>.<T>\t; Half-precision", "FMAXV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<V>\nFor the half-precision variant: is the destination width specifier, H.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<T>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "SDIV", "short_desc": "Signed divide (predicated)", "full_desc": "Signed divide active elements of the first source vector by corresponding elements of the second source vector and destructively place the quotient in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '0x' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer quotient;\n        if element2 == 0 then\n            quotient = 0;\n        else\n            quotient = RoundTowardsZero(Real(element1) / Real(element2));\n        Elem[result, e, esize] = quotient<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "LDG", "short_desc": "Load Allocation Tag", "full_desc": "Load Allocation Tag loads an Allocation Tag from a memory address, generates a Logical Address Tag from the Allocation Tag and merges it into the destination register. The address used for the load is calculated from the base register and an immediate signed offset scaled by the Tag granule.", "syntax": ["LDG  <Xt>, [<Xn|SP>{, #<simm>}]\t; Integer"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<simm>\nIs the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "if !HaveMTEExt() then UNDEFINED;\ninteger t = UInt(Xt);\ninteger n = UInt(Xn);\nbits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);", "operation": "bits(64) address;\nbits(4) tag;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\naddress = address + offset;\naddress = Align(address, TAG_GRANULE);\n\ntag = AArch64.MemTag[address, AccType_NORMAL];\nX[t] = AArch64.AddressWithAllocationTag(X[t], AccType_NORMAL, tag);"}, {"mnemonic": "UQINCP (scalar)", "short_desc": "Unsigned saturating increment scalar by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to increment the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQINCP  <Wdn>, <Pm>.<T>\t; 32-bit", "UQINCP  <Xdn>, <Pm>.<T>\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Rdn);\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(ssize) operand1 = X[dn];\nbits(PL) operand2 = P[m];\nbits(ssize) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\ninteger element = Int(operand1, unsigned);\n(result, -) = SatQ(element + count, ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "PRFW (scalar plus vector)", "short_desc": "Gather prefetch words (scalar plus vector)", "full_desc": "Gather prefetch of words from the active memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then multiplied by 4. Inactive addresses are not prefetched from memory.", "syntax": ["PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]\t; 32-bit scaled offset", "PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset", "PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger offs_size = 32;\nboolean offs_unsigned = (xs == '0');\ninteger scale = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);"}, {"mnemonic": "FCVTZU (scalar, fixed-point)", "short_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar)", "full_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTZU  <Wd>, <Hn>, #<fbits>\t; Half-precision to 32-bit", "FCVTZU  <Xd>, <Hn>, #<fbits>\t; Half-precision to 64-bit", "FCVTZU  <Wd>, <Sn>, #<fbits>\t; Single-precision to 32-bit", "FCVTZU  <Xd>, <Sn>, #<fbits>\t; Single-precision to 64-bit", "FCVTZU  <Wd>, <Dn>, #<fbits>\t; Double-precision to 32-bit", "FCVTZU  <Xd>, <Dn>, #<fbits>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<fbits>\nFor the double-precision to 32-bit, half-precision to 32-bit and single-precision to 32-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 32, encoded as 64 minus \"scale\".", "<fbits>\nFor the double-precision to 64-bit, half-precision to 64-bit and single-precision to 64-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus \"scale\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase ftype of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\nif sf == '0' && scale<5> == '0' then UNDEFINED;\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"}, {"mnemonic": "LDURH", "short_desc": "Load Register Halfword (unscaled)", "full_desc": "Load Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "SBCS", "short_desc": "Subtract with Carry, setting flags", "full_desc": "Subtract with Carry, setting flags, subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["SBCS  <Wd>, <Wn>, <Wm>\t; 32-bit", "SBCS  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "ORR (vectors, predicated)", "short_desc": "Bitwise inclusive OR vectors (predicated)", "full_desc": "Bitwise inclusive OR active elements of the second source vector with corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["ORR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = element1 OR element2;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "ST1W (scalar plus vector)", "short_desc": "Scatter store words from a vector (vector index)", "full_desc": "Scatter store of words from the active elements of a vector register to the memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 4. Inactive elements are not written to memory.", "syntax": ["ST1W    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]\t; 32-bit scaled offset", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]\t; 32-bit unpacked scaled offset", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "ST1W    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]\t; 64-bit scaled offset", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\ninteger offs_size = 32;\nboolean offs_unsigned = xs == '0';\ninteger scale = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(VL) offset = Z[m];\nbits(VL) src = Z[t];\nbits(PL) mask = P[g];\nbits(64) addr;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;"}, {"mnemonic": "CAS, CASA, CASAL, CASL", "short_desc": "Compare and Swap word or doubleword in memory", "full_desc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.", "syntax": ["CAS  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit CAS", "CASA  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit CASA", "CASAL  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit CASAL", "CASL  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit CASL", "CAS  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit CAS", "CASA  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit CASA", "CASAL  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit CASAL", "CASL  <Xs>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit CASL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\ncomparevalue = X[s];\nnewvalue = X[t];\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);\n\nX[s] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDFF1SH (scalar plus vector)", "short_desc": "Gather load first-fault signed halfwords to vector (vector index)", "full_desc": "Gather load with first-faulting behavior of signed halfwords to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 2. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LDFF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\ninteger offs_size = 32;\nboolean unsigned = FALSE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 1;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "FRINTI (scalar)", "short_desc": "Floating-point Round to Integral, using current rounding mode (scalar)", "full_desc": "Floating-point Round to Integral, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the , and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTI  <Hd>, <Hn>\t; Half-precision", "FRINTI  <Sd>, <Sn>\t; Single-precision", "FRINTI  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "LDLARH", "short_desc": "Load LOAcquire Register Halfword", "full_desc": "Load LOAcquire Register Halfword loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["LDLARH  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "CLS", "short_desc": "Count Leading Sign bits", "full_desc": "Count Leading Sign bits counts the number of leading bits of the source register that have the same value as the most significant bit of the register, and writes the result to the destination register. This count does not include the most significant bit of the source register.", "syntax": ["CLS  <Wd>, <Wn>\t; 32-bit", "CLS  <Xd>, <Xn>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nCountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;", "operation": "integer result;\nbits(datasize) operand1 = X[n];\n\nif opcode == CountOp_CLZ then\n    result = CountLeadingZeroBits(operand1);\nelse\n    result = CountLeadingSignBits(operand1);\n\nX[d] = result<datasize-1:0>;"}, {"mnemonic": "LD2H (scalar plus immediate)", "short_desc": "Contiguous load two-halfword structures to two vectors (immediate index)", "full_desc": "Contiguous load two-halfword structures, each to the same element number in two vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 2 in the range -16 to 14 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD2H    { <Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "BFI", "short_desc": "Bitfield Insert", "full_desc": "Bitfield Insert copies a bitfield of  bits from the least significant bits of the source register to bit position  of the destination register, leaving the other destination bits unchanged.", "syntax": ["BFI  <Wd>, <Wn>, #<lsb>, #<width>\t; 32-bit", "BFI  <Xd>, <Xn>, #<lsb>, #<width>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<lsb>\nFor the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.", "<lsb>\nFor the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<width>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<width>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "FMAXNM (vector)", "short_desc": "Floating-point Maximum Number (vector)", "full_desc": "Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "TBX", "short_desc": "Table vector lookup extension", "full_desc": "Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.", "syntax": ["TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>\t; Two register table", "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>\t; Three register table", "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>\t; Four register table", "TBX  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>\t; Single register table"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nFor the four register table, three register table and two register table variant: is the name of the first SIMD&FP table register, encoded in the \"Rn\" field.", "<Vn>\nFor the single register table variant: is the name of the SIMD&FP table register, encoded in the \"Rn\" field.", "<Vn+1>\nIs the name of the second SIMD&FP table register, encoded as \"Rn\" plus 1 modulo 32.", "<Vn+2>\nIs the name of the third SIMD&FP table register, encoded as \"Rn\" plus 2 modulo 32.", "<Vn+3>\nIs the name of the fourth SIMD&FP table register, encoded as \"Rn\" plus 3 modulo 32.", "<Vm>\nIs the name of the SIMD&FP index register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\ninteger regs = UInt(len) + 1;\nboolean is_tbl = (op == '0');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) indices = V[m];\nbits(128*regs) table = Zeros();\nbits(datasize) result;\ninteger index;\n\n// Create table from registers\nfor i = 0 to regs - 1\n    table<128*i+127:128*i> = V[n];\n    n = (n + 1) MOD 32;\n\nresult = if is_tbl then Zeros() else V[d];\nfor i = 0 to elements - 1\n    index = UInt(Elem[indices, i, 8]);\n    if index < 16 * regs then\n        Elem[result, i, 8] = Elem[table, index, 8];\n\nV[d] = result;"}, {"mnemonic": "LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH", "short_desc": "Atomic bit clear on halfword in memory", "full_desc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDCLRAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRAH", "LDCLRALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRALH", "LDCLRH  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRH", "LDCLRLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDCLRLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STNT1D (scalar plus immediate)", "short_desc": "Contiguous store non-temporal doublewords from vector (immediate index)", "full_desc": "Contiguous store non-temporal of doublewords from elements of a vector register to the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements are not written to memory.", "syntax": ["STNT1D  { <Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nconstant integer mbytes = esize DIV 8;\nbits(VL) src;\nbits(PL) mask = P[g];\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\nsrc = Z[t];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];\n    addr = addr + mbytes;"}, {"mnemonic": "SHA1SU0", "short_desc": "SHA1 schedule update 0", "full_desc": "SHA1 schedule update 0.", "syntax": ["SHA1SU0  <Vd>.4S, <Vn>.4S, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif !HaveSHA1Ext() then UNDEFINED;", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\n\nresult = operand2<63:0> : operand1<127:64>;\nresult = result EOR operand1 EOR operand3;\nV[d] = result;"}, {"mnemonic": "FRINT32X (vector)", "short_desc": "Floating-point Round to 32-bit Integer, using current rounding mode (vector)", "full_desc": "Floating-point Round to 32-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the rounding mode that is determined by the , and writes the result to the SIMD&FP destination register.", "syntax": ["FRINT32X  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFrintExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then UNDEFINED;\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger intsize = if op == '0' then 32 else 64; \nFPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);\n\nV[d] = result;"}, {"mnemonic": "FMINV", "short_desc": "Floating-point Minimum across Vector", "full_desc": "Floating-point Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMINV  <V><d>, <Vn>.<T>\t; Half-precision", "FMINV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<V>\nFor the half-precision variant: is the destination width specifier, H.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<T>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "UADDL, UADDL2", "short_desc": "Unsigned Add Long (vector)", "full_desc": "Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.", "syntax": ["UADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "INS (general)", "short_desc": "Insert vector element from general-purpose register", "full_desc": "Insert vector element from general-purpose register. This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&FP register.", "syntax": ["INS  <Vd>.<Ts>[<index>], <R><n>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ts>\n", "<index>\n", "<R>\n", "<n>\nIs the number [0-30] of the general-purpose source register or ZR (31), encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\n\nif size > 3 then UNDEFINED;\ninteger index = UInt(imm5<4:size+1>);\n\ninteger esize = 8 << size;\ninteger datasize = 128;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(esize) element = X[n];\nbits(datasize) result;\n\nresult = V[d];\nElem[result, index, esize] = element;\nV[d] = result;"}, {"mnemonic": "SMAXV", "short_desc": "Signed maximum reduction to scalar", "full_desc": "Signed maximum horizontally across all lanes of a vector, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as the minimum signed integer for the element size.", "syntax": ["SMAXV   <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\ninteger maximum = if unsigned then 0 else -(2^(esize-1));\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer element = Int(Elem[operand, e, esize], unsigned);\n        maximum = Max(maximum, element);\n\nV[d] = maximum<esize-1:0>;"}, {"mnemonic": "CPY (scalar)", "short_desc": "Copy general-purpose register to vector elements (predicated)", "full_desc": "Copy the general-purpose scalar source register to each active element in the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["CPY     <Zd>.<T>, <Pg>/M, <R><n|SP>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<R>\n", "<n|SP>\nIs the number [0-30] of the general-purpose source register or the name SP (31), encoded in the \"Rn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) operand1;\nif n == 31 then\n    operand1 = SP[];\nelse\n    operand1 = X[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = operand1<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "LSL (vectors)", "short_desc": "Logical shift left by vector (predicated)", "full_desc": "Shift left active elements of the first source vector by corresponding elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. The shift amount operand is a vector of unsigned elements in which all bits are significant, and not used modulo the element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    integer shift = Min(UInt(element2), esize);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = LSL(element1, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "SUBPS", "short_desc": "Subtract Pointer, setting Flags", "full_desc": "Subtract Pointer, setting Flags subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64-bits, and writes the result to the destination register. It updates the condition flags based on the result of the subtraction.", "syntax": ["SUBPS  <Xd>, <Xn|SP>, <Xm|SP>\t; Integer"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Xd\" field.", "<Xn|SP>\nIs the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xm|SP>\nIs the 64-bit name of the second general-purpose source register or stack pointer, encoded in the \"Xm\" field."], "decode": "integer d = UInt(Xd);\ninteger n = UInt(Xn);\ninteger m = UInt(Xm);\nboolean setflags = TRUE;", "operation": "bits(64) operand1 = if n == 31 then SP[] else X[n];\nbits(64) operand2 = if m == 31 then SP[] else X[m];\noperand1 = SignExtend(operand1<55:0>, 64);\noperand2 = SignExtend(operand2<55:0>, 64);\n\nbits(64) result;\nbits(4) nzcv;\n\noperand2 = NOT(operand2);\n(result, nzcv) = AddWithCarry(operand1, operand2, '1');\n\nif setflags then\n    PSTATE.<N,Z,C,V> = nzcv;\nX[d] = result;"}, {"mnemonic": "UMADDL", "short_desc": "Unsigned Multiply-Add Long", "full_desc": "Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register.", "syntax": ["UMADDL  <Xd>, <Wn>, <Wm>, <Xa>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xa>\nIs the 64-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"}, {"mnemonic": "LD1H (scalar plus immediate)", "short_desc": "Contiguous load unsigned halfwords to vector (immediate index)", "full_desc": "Contiguous load of unsigned halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1H    { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element", "LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 16;\nboolean unsigned = TRUE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "RBIT", "short_desc": "Reverse Bits", "full_desc": "Reverse Bits reverses the bit order in a register.", "syntax": ["RBIT  <Wd>, <Wn>\t; 32-bit", "RBIT  <Xd>, <Xn>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;", "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\n\nfor i = 0 to datasize-1\n    result<datasize-1-i> = operand<i>;\n\nX[d] = result;"}, {"mnemonic": "LDXRB", "short_desc": "Load Exclusive Register Byte", "full_desc": "Load Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See . For information about memory accesses see .", "syntax": ["LDXRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FMIN (vectors)", "short_desc": "Floating-point minimum (predicated)", "full_desc": "Determine the minimum of active floating-point elements of the second source vector and corresponding floating-point elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. If either element value is NaN then the result is NaN. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "STSMAX, STSMAXL", "short_desc": "Atomic signed maximum on word or doubleword in memory, without return", "full_desc": "Atomic signed maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.", "syntax": ["STSMAX  <Ws>, [<Xn|SP>]\t; 32-bit LDSMAX alias", "STSMAXL  <Ws>, [<Xn|SP>]\t; 32-bit LDSMAXL alias", "STSMAX  <Xs>, [<Xn|SP>]\t; 64-bit LDSMAX alias", "STSMAXL  <Xs>, [<Xn|SP>]\t; 64-bit LDSMAXL alias"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "CMTST", "short_desc": "Compare bitwise Test bits nonzero (vector)", "full_desc": "Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMTST  <V><d>, <V><n>, <V><m>\t; Scalar", "CMTST  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean and_test = (U == '0');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if and_test then\n        test_passed = !IsZero(element1 AND element2);\n    else\n        test_passed = (element1 == element2);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "UZP1, UZP2 (predicates)", "short_desc": "Concatenate even or odd elements from two predicates", "full_desc": "Concatenate adjacent even or odd-numbered elements from the first and second source predicates and place in elements of the destination predicate. This instruction is unpredicated.", "syntax": ["UZP1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Even", "UZP2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>\t; Odd"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\ninteger part = 0;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nbits(PL*2) zipped = operand2:operand1;\nfor e = 0 to elements-1\n    Elem[result, e, esize DIV 8] = Elem[zipped, 2*e+part, esize DIV 8];\n\nP[d] = result;"}, {"mnemonic": "URSQRTE", "short_desc": "Unsigned Reciprocal Square Root Estimate", "full_desc": "Unsigned Reciprocal Square Root Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse square root for each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.", "syntax": ["URSQRTE  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '1' then UNDEFINED;\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRSqrtEstimate(element);\n\nV[d] = result;"}, {"mnemonic": "REV32 (vector)", "short_desc": "Reverse elements in 32-bit words (vector)", "full_desc": "Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["REV32  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\n// size=esize:   B(0),  H(1),  S(1), D(S)\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\n\n// op=REVx: 64(0), 32(1), 16(2)\nbits(2) op = o0:U; \n\n// => op+size: \n//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X\n//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X\n//    16+B = 2, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n// => 3-(op+size) (index bits in group)\n//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X\n//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X\n//    16+B = 1, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n\n// index bits within group: 1, 2, 3\nif UInt(op)+UInt(size) >= 3 then UNDEFINED;\n\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;"}, {"mnemonic": "UQDECB", "short_desc": "Unsigned saturating decrement scalar by multiple of 8-bit predicate constraint element count", "full_desc": "Determines the number of active 8-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQDECB  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "UQDECB  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "SHRN, SHRN2", "short_desc": "Shift Right Narrow (immediate)", "full_desc": "Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the source SIMD&FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The results are truncated. For rounded results, see .", "syntax": ["SHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then UNDEFINED;\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\nfor e = 0 to elements-1\n    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    Elem[result, e, esize] = element<esize-1:0>;\n\nVpart[d, part] = result;"}, {"mnemonic": "SUDOT", "short_desc": "Signed by unsigned integer indexed dot product", "full_desc": "The signed by unsigned integer indexed dot product instruction computes the dot product of a group of four signed 8-bit integer values held in each 32-bit element of the first source vector multiplied by a group of four unsigned 8-bit integer values in an indexed 32-bit element of the second source vector, and then destructively adds the widened dot product to the corresponding 32-bit element of the destination vector.", "syntax": ["SUDOT   <Zda>.S, <Zn>.B, <Zm>.B[<imm>]\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<imm>\nIs the immediate index of a quadtuplet of four 8-bit elements within each 128-bit vector segment, in the range 0 to 3, encoded in the \"i2\" field."], "decode": "if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;\ninteger esize = 32;\ninteger index = UInt(i2);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger eltspersegment = 128 DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer segmentbase = e - (e MOD eltspersegment);\n    integer s = segmentbase + index;\n    bits(esize) res = Elem[operand3, e, esize];\n    for i = 0 to 3\n        integer element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n        integer element2 = UInt(Elem[operand2, 4 * s + i, esize DIV 4]);\n        res = res + element1 * element2;\n    Elem[result, e, esize] = res;\n\nZ[da] = result;"}, {"mnemonic": "STSMIN, STSMINL", "short_desc": "Atomic signed minimum on word or doubleword in memory, without return", "full_desc": "Atomic signed minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.", "syntax": ["STSMIN  <Ws>, [<Xn|SP>]\t; 32-bit LDSMIN alias", "STSMINL  <Ws>, [<Xn|SP>]\t; 32-bit LDSMINL alias", "STSMIN  <Xs>, [<Xn|SP>]\t; 64-bit LDSMIN alias", "STSMINL  <Xs>, [<Xn|SP>]\t; 64-bit LDSMINL alias"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "FMLS (vector)", "short_desc": "Floating-point fused Multiply-Subtract from accumulator (vector)", "full_desc": "Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.", "syntax": ["FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "NOT (predicate)", "short_desc": "Bitwise invert predicate", "full_desc": "Bitwise invert each active element of the source predicate, and place the results in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Does not set the condition flags.", "syntax": ["NOT     <Pd>.B, <Pg>/Z, <Pn>.B\t; Not setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field."]}, {"mnemonic": "SQINCD (vector)", "short_desc": "Signed saturating increment vector by multiple of 64-bit predicate constraint element count", "full_desc": "Determines the number of active 64-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment all destination vector elements. The results are saturated to the 64-bit signed integer range.", "syntax": ["SQINCD  <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "CMPLS (vectors)", "short_desc": "Compare unsigned lower or same as vector, setting the condition flags", "full_desc": "Compare active unsigned integer elements in the first source vector being lower than or same as corresponding unsigned elements in the second source vector, and place the boolean results of the comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["CMPLS   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Higher or same"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."]}, {"mnemonic": "SM3SS1", "short_desc": "SM3SS1", "full_desc": "SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source SIMD&FP register by 12, and adds that 32-bit value to the two other 32-bit values held in the top 32 bits of each of the 128-bit vectors in the second and third source SIMD&FP registers, rotating this result left by 7 and writing the final result into the top 32 bits of the vector in the destination SIMD&FP register, with the bottom 96 bits of the vector being written to 0.", "syntax": ["SM3SS1  <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Va>\nIs the name of the third SIMD&FP source register, encoded in the \"Ra\" field."], "decode": "if !HaveSM3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger a = UInt(Ra);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) Va = V[a];\nVd<127:96> = ROL((ROL(Vn<127:96>,12) + Vm<127:96> + Va<127:96>) , 7);\nVd<95:0> = Zeros();\nV[d] = Vd;"}, {"mnemonic": "SM3TT1B", "short_desc": "SM3TT1B", "full_desc": "SM3TT1B takes three 128-bit vectors from three source SIMD&FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:", "syntax": ["SM3TT1B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field.", "<imm2>\nIs a 32-bit element indexed out of <Vm>, encoded in \"imm2\"."], "decode": "if !HaveSM3Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger i = UInt(imm2);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) WjPrime;\nbits(128) result; \nbits(32) TT1;\nbits(32) SS2;\n\nWjPrime = Elem[Vm,i,32];\nSS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); \nTT1 = (Vd<127:96> AND Vd<63:32>) OR (Vd<127:96> AND Vd<95:64>) OR (Vd<63:32> AND Vd<95:64>); \nTT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,9); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT1; \nV[d] = result;"}, {"mnemonic": "MOV (from general)", "short_desc": "Move general-purpose register to a vector element", "full_desc": "Move general-purpose register to a vector element. This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&FP register.", "syntax": ["MOV  <Vd>.<Ts>[<index>], <R><n>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ts>\n", "<index>\n", "<R>\n", "<n>\nIs the number [0-30] of the general-purpose source register or ZR (31), encoded in the \"Rn\" field."]}, {"mnemonic": "MOV (register)", "short_desc": "Move (register)", "full_desc": "Move (register) copies the value in a source register to the destination register.", "syntax": ["MOV  <Wd>, <Wm>\t; 32-bit", "MOV  <Xd>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field."]}, {"mnemonic": "SQRDMULH (by element)", "short_desc": "Signed saturating Rounding Doubling Multiply returning High half (by element)", "full_desc": "Signed saturating Rounding Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SQRDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar", "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean round = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    // The following only saturates if element1 and element2 equal -(2^(esize-1))\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "SCVTF (vector, integer)", "short_desc": "Signed integer Convert to Floating-point (vector)", "full_desc": "Signed integer Convert to Floating-point (vector). This instruction converts each element in a vector from signed integer to floating-point using the rounding mode that is specified by the , and writes the result to the SIMD&FP destination register.", "syntax": ["SCVTF  <Hd>, <Hn>\t; Scalar half precision", "SCVTF  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "SCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "SCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nFPRounding rounding = FPRoundingMode(FPCR);\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "SQDMULL, SQDMULL2 (vector)", "short_desc": "Signed saturating Doubling Multiply Long", "full_desc": "Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SQDMULL  <Va><d>, <Vb><n>, <Vb><m>\t; Scalar", "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Va>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vb>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);\n    Elem[result, e, 2*esize] = product;\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "UHADD", "short_desc": "Unsigned Halving Add", "full_desc": "Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    Elem[result, e, esize] = sum<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "FMUL (scalar)", "short_desc": "Floating-point Multiply (scalar)", "full_desc": "Floating-point Multiply (scalar). This instruction multiplies the floating-point values of the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.", "syntax": ["FMUL  <Hd>, <Hn>, <Hm>\t; Half-precision", "FMUL  <Sd>, <Sn>, <Sm>\t; Single-precision", "FMUL  <Dd>, <Dn>, <Dm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean negated = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nresult = FPMul(operand1, operand2, FPCR);\n\nif negated then result = FPNeg(result);\n\nV[d] = result;"}, {"mnemonic": "ADDP (vector)", "short_desc": "Add Pairwise (vector)", "full_desc": "Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["ADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[concat, 2*e, esize];\n    element2 = Elem[concat, (2*e)+1, esize];\n    Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;"}, {"mnemonic": "LD1SH (scalar plus immediate)", "short_desc": "Contiguous load signed halfwords to vector (immediate index)", "full_desc": "Contiguous load of signed halfwords to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\nboolean unsigned = FALSE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "FMOV (register)", "short_desc": "Floating-point Move register without conversion", "full_desc": "Floating-point Move register without conversion. This instruction copies the floating-point value in the SIMD&FP source register to the SIMD&FP destination register.", "syntax": ["FMOV  <Hd>, <Hn>\t; Half-precision", "FMOV  <Sd>, <Sn>\t; Single-precision", "FMOV  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"}, {"mnemonic": "PACDA, PACDZA", "short_desc": "Pointer Authentication Code for Data address, using key A", "full_desc": "Pointer Authentication Code for Data address, using key A. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key A.", "syntax": ["PACDA  <Xd>, <Xn|SP>\t; PACDA", "PACDZA  <Xd>\t; PACDZA"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field."], "decode": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif Z == '0' then // PACDA\n    if n == 31 then source_is_sp = TRUE;\nelse // PACDZA\n    if n != 31 then UNDEFINED;", "operation": "if source_is_sp then\n    X[d] = AddPACDA(X[d], SP[]);\nelse\n    X[d] = AddPACDA(X[d], X[n]);"}, {"mnemonic": "STNP (SIMD&FP)", "short_desc": "Store Pair of SIMD&FP registers, with Non-temporal hint", "full_desc": "Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction stores a pair of SIMD&FP registers to memory, issuing a hint to the memory system that the access is non-temporal. The address used for the store is calculated from an address from a base register value and an immediate offset. For information about non-temporal pair instructions, see .", "syntax": ["STNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit", "STNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit", "STNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit"], "symbols": ["<Dt1>\nIs the 64-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt2>\nIs the 64-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Qt1>\nIs the 128-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt2>\nIs the 128-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<St1>\nIs the 32-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St2>\nIs the 32-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8.", "<imm>\nFor the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as <imm>/16."], "decode": "boolean wback  = FALSE;\nboolean postindex = FALSE;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VECSTREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UNDEFINED;\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\nboolean tag_checked = wback || n != 31;"}, {"mnemonic": "LDFF1D (scalar plus scalar)", "short_desc": "Contiguous load first-fault doublewords to vector (scalar index)", "full_desc": "Contiguous load with first-faulting behavior of doublewords to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 8 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + UInt(offset) * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "LDFF1D (vector plus immediate)", "short_desc": "Gather load first-fault doublewords to vector (immediate index)", "full_desc": "Gather load with first-faulting behavior of doublewords to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 8 in the range 0 to 248. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1D  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 248, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "MADD", "short_desc": "Multiply-Add", "full_desc": "Multiply-Add multiplies two register values, adds a third register value, and writes the result to the destination register.", "syntax": ["MADD  <Wd>, <Wn>, <Wm>, <Wa>\t; 32-bit", "MADD  <Xd>, <Xn>, <Xm>, <Xa>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wa>\nIs the 32-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xa>\nIs the 64-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = if sf == '1' then 64 else 32;\ninteger datasize = destsize;\nboolean sub_op = (o0 == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));\nelse\n    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));\n\nX[d] = result<destsize-1:0>;"}, {"mnemonic": "FMINP (scalar)", "short_desc": "Floating-point Minimum of Pair of elements (scalar)", "full_desc": "Floating-point Minimum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&FP register.", "syntax": ["FMINP  <V><d>, <Vn>.<T>\t; Half-precision", "FMINP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<V>\n", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<T>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then UNDEFINED;\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "RMIF", "short_desc": "Rotate, Mask Insert Flags", "full_desc": "Performs a rotation right of a value held in a general purpose register by an immediate value, and then inserts a selection of the bottom four bits of the result of the rotation into the PSTATE flags, under the control of a second immediate mask.", "syntax": ["RMIF  <Xn>, #<shift>, #<mask>\t; Integer"], "symbols": ["<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<shift>\nIs the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<mask>\nIs the flag bit mask, an immediate in the range 0 to 15, which selects the bits that are inserted into the NZCV condition flags, encoded in the \"mask\" field."], "decode": "if !HaveFlagManipulateExt() || sf != '1' then UNDEFINED;\ninteger lsb = UInt(imm6);\ninteger n = UInt(Rn);", "operation": "bits(4) tmp;\nbits(64) tmpreg = X[n];\ntmp = (tmpreg:tmpreg)<lsb+3:lsb>;\nif mask<3> == '1' then PSTATE.N = tmp<3>;\nif mask<2> == '1' then PSTATE.Z = tmp<2>;\nif mask<1> == '1' then PSTATE.C = tmp<1>;\nif mask<0> == '1' then PSTATE.V = tmp<0>;"}, {"mnemonic": "SMMLA", "short_desc": "Signed integer matrix multiply-accumulate", "full_desc": "The signed integer matrix multiply-accumulate instruction multiplies the 2\u00d78 matrix of signed 8-bit integer values held in each 128-bit segment of the first source vector by the 8\u00d72 matrix of signed 8-bit integer values in the corresponding segment of the second source vector. The resulting 2\u00d72 widened 32-bit integer matrix product is then destructively added to the 32-bit integer matrix accumulator held in the corresponding segment of the addend and destination vector. This is equivalent to performing an 8-way dot product per destination element.", "syntax": ["SMMLA   <Zda>.S, <Zn>.B, <Zm>.B\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean op1_unsigned = FALSE;\nboolean op2_unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger segments = VL DIV 128;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result = Zeros();\nbits(128) op1, op2;\nbits(128) res, addend;\n\nfor s = 0 to segments-1\n    op1    = Elem[operand1, s, 128];\n    op2    = Elem[operand2, s, 128];\n    addend = Elem[operand3, s, 128];\n    res    = MatMulAdd(addend, op1, op2, op1_unsigned, op2_unsigned);\n    Elem[result, s, 128] = res;\n\nZ[da] = result;"}, {"mnemonic": "REV", "short_desc": "Reverse Bytes", "full_desc": "Reverse Bytes reverses the byte order in a register.", "syntax": ["REV  <Wd>, <Wn>\t; 32-bit", "REV  <Xd>, <Xn>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;\n\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UNDEFINED;\n        container_size = 64;", "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n\nX[d] = result;"}, {"mnemonic": "URSHL", "short_desc": "Unsigned Rounding Shift Left (register)", "full_desc": "Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["URSHL  <V><d>, <V><n>, <V><m>\t; Scalar", "URSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "BICS (shifted register)", "short_desc": "Bitwise Bit Clear (shifted register), setting flags", "full_desc": "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["BICS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\t; 32-bit", "BICS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then UNDEFINED;\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"}, {"mnemonic": "LDSETB, LDSETAB, LDSETALB, LDSETLB", "short_desc": "Atomic bit set on byte in memory", "full_desc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDSETAB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETAB", "LDSETALB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETALB", "LDSETB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETB", "LDSETLB  <Ws>, <Wt>, [<Xn|SP>]\t; LDSETLB"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "NGCS", "short_desc": "Negate with Carry, setting flags", "full_desc": "Negate with Carry, setting flags, negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["NGCS  <Wd>, <Wm>\t; 32-bit", "NGCS  <Xd>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field."]}, {"mnemonic": "UQSHL (register)", "short_desc": "Unsigned saturating Shift Left (register)", "full_desc": "Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UQSHL  <V><d>, <V><n>, <V><m>\t; Scalar", "UQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "CASH, CASAH, CASALH, CASLH", "short_desc": "Compare and Swap halfword in memory", "full_desc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.", "syntax": ["CASAH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASAH", "CASALH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASALH", "CASH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASH", "CASLH  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; CASLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\ncomparevalue = X[s];\nnewvalue = X[t];\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);\n\nX[s] = ZeroExtend(data, regsize);"}, {"mnemonic": "LSR (immediate)", "short_desc": "Logical Shift Right (immediate)", "full_desc": "Logical Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSR  <Wd>, <Wn>, #<shift>\t; 32-bit", "LSR  <Xd>, <Xn>, #<shift>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<shift>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, encoded in the \"immr\" field.", "<shift>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the \"immr\" field."]}, {"mnemonic": "WHILELT", "short_desc": "While incrementing signed scalar less than scalar", "full_desc": "Generate a predicate that starting from the lowest numbered element is true while the incrementing value of the first, signed scalar operand is less than the second scalar operand and false thereafter up to the highest numbered element.", "syntax": ["WHILELT <Pd>.<T>, <R><n>, <R><m>\t; SVE"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<R>\n", "<n>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field.", "<m>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger rsize = 32 << UInt(sf);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Pd);\nboolean unsigned = FALSE;\nSVECmp op = Cmp_LT;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = Ones(PL);\nbits(rsize) operand1 = X[n];\nbits(rsize) operand2 = X[m];\nbits(PL) result;\nboolean last = TRUE;\n\nfor e = 0 to elements-1\n    boolean cond;\n    case op of\n        when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));\n        when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));\n\n    last = last && cond;\n    ElemP[result, e, esize] = if last then '1' else '0';\n    operand1 = operand1 + 1;\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "BLR", "short_desc": "Branch with Link to Register", "full_desc": "Branch with Link to Register calls a subroutine at an address in a register, setting register X30 to PC+4.", "syntax": ["BLR  <Xn>\t; Integer"], "symbols": ["<Xn>\nIs the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UNDEFINED;\nelsif pac && !HavePACExt() then \n    UNDEFINED;\n\ncase op of\n    when '00' branch_type = BranchType_INDIR;\n    when '01' branch_type = BranchType_INDCALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UNDEFINED;\n\nif pac then\n    if Z == '0' && m != 31 then\n        UNDEFINED;\n\n    if branch_type == BranchType_RET then\n        if n != 31 then UNDEFINED;\n        n = 30;\n        source_is_sp = TRUE;", "operation": "bits(64) target = X[n];\nboolean auth_then_branch = TRUE;\n\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier, auth_then_branch);\n    else\n        target = AuthIB(target, modifier, auth_then_branch);\n\nif branch_type == BranchType_INDCALL then X[30] = PC[] + 4;\n\n// Value in BTypeNext will be used to set PSTATE.BTYPE\ncase branch_type of\n    when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ\n        if InGuardedPage then\n            if n == 16 || n == 17 then\n                BTypeNext = '01';\n            else\n                BTypeNext = '11';\n        else\n            BTypeNext = '01';\n    when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ\n        BTypeNext = '10';\n    when BranchType_RET             // RET, RETAA, RETAB \n        BTypeNext = '00';\n\nBranchTo(target, branch_type);"}, {"mnemonic": "SHA256SU0", "short_desc": "SHA256 schedule update 0", "full_desc": "SHA256 schedule update 0.", "syntax": ["SHA256SU0  <Vd>.4S, <Vn>.4S\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HaveSHA256Ext() then UNDEFINED;", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand2<31:0> : operand1<127:32>;\nbits(32) elt;\n\nfor e = 0 to 3\n    elt = Elem[T, e, 32];\n    elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);\n    Elem[result, e, 32] = elt + Elem[operand1, e, 32];\nV[d] = result;"}, {"mnemonic": "EOR (immediate)", "short_desc": "Bitwise Exclusive OR (immediate)", "full_desc": "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register value and an immediate value, and writes the result to the destination register.", "syntax": ["EOR  <Wd|WSP>, <Wn>, #<imm>\t; 32-bit", "EOR  <Xd|SP>, <Xn>, #<imm>\t; 64-bit"], "symbols": ["<Wd|WSP>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<imm>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then UNDEFINED;\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "LD2 (multiple structures)", "short_desc": "Load multiple 2-element structures to two registers", "full_desc": "Load multiple 2-element structures to two registers. This instruction loads multiple 2-element structures from memory and writes the result to the two SIMD&FP registers, with de-interleaving.", "syntax": ["LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; No offset", "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Immediate offset", "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UNDEFINED;\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then UNDEFINED;"}, {"mnemonic": "SEL (vectors)", "short_desc": "Conditionally select elements from two vectors", "full_desc": "Read active elements from the first source vector and inactive elements from the second source vector and place in the corresponding elements of the destination vector.", "syntax": ["SEL     <Zd>.<T>, <Pg>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = element1;\n    else\n        Elem[result, e, esize] = element2;\n\nZ[d] = result;"}, {"mnemonic": "BFMLALB, BFMLALT (vector)", "short_desc": "BFloat16 floating-point widening multiply-add long (vector)", "full_desc": "BFloat16 floating-point widening multiply-add long (vector) widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first and second source vectors from Bfloat16 to single-precision format. The instruction then multiplies and adds these values to the overlapping single-precision elements of the destination vector.", "syntax": ["BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.8H\t; Vector"], "symbols": ["<bt>\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveBF16Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger elements = 128 DIV 32;\ninteger sel = UInt(Q);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(128) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(128) operand3 = V[d];\nbits(128) result;\n\nfor e = 0 to elements-1\n    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);\n    bits(32) element2 = Elem[operand2, 2 * e + sel, 16] : Zeros(16);\n    bits(32) addend = Elem[operand3, e, 32];\n    Elem[result, e, 32] = FPMulAdd(addend, element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "LSR (vectors)", "short_desc": "Logical shift right by vector (predicated)", "full_desc": "Shift right, inserting zeroes, active elements of the first source vector by corresponding elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. The shift amount operand is a vector of unsigned elements in which all bits are significant, and not used modulo the element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    integer shift = Min(UInt(element2), esize);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = LSR(element1, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "ASR (register)", "short_desc": "Arithmetic Shift Right (register)", "full_desc": "Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["ASR  <Wd>, <Wn>, <Wm>\t; 32-bit", "ASR  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."]}, {"mnemonic": "UMLSL, UMLSL2 (by element)", "short_desc": "Unsigned Multiply-Subtract Long (vector, by element)", "full_desc": "Unsigned Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"}, {"mnemonic": "STLURH", "short_desc": "Store-Release Register Halfword (unscaled)", "full_desc": "Store-Release Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register.", "syntax": ["STLURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_ORDERED;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "STTRH", "short_desc": "Store Register Halfword (unprivileged)", "full_desc": "Store Register Halfword (unprivileged) stores a halfword from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset.", "syntax": ["STTRH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\n\nunpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');\nunpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';\n\nuser_access_override = HaveUAOExt() && PSTATE.UAO == '1';\nif !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then\n    acctype = AccType_UNPRIV;\nelse\n    acctype = AccType_NORMAL;\n\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "ADCS", "short_desc": "Add with Carry, setting flags", "full_desc": "Add with Carry, setting flags, adds two register values and the Carry flag value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ADCS  <Wd>, <Wn>, <Wm>\t; 32-bit", "ADCS  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "SMULL, SMULL2 (vector)", "short_desc": "Signed Multiply Long (vector)", "full_desc": "Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB", "short_desc": "Authenticate Instruction address, using key B", "full_desc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B.", "syntax": ["AUTIB  <Xd>, <Xn|SP>\t; AUTIB", "AUTIZB  <Xd>\t; AUTIZB", "AUTIB1716\t; AUTIB1716", "AUTIBSP\t; AUTIBSP", "AUTIBZ\t; AUTIBZ"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field."], "decode": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif Z == '0' then // AUTIB\n    if n == 31 then source_is_sp = TRUE;\nelse // AUTIZB\n    if n != 31 then UNDEFINED;", "operation": "auth_then_branch = FALSE;\n\nif HavePACExt() then\n    if source_is_sp then\n        X[d] = AuthIB(X[d], SP[], auth_then_branch);\n    else\n        X[d] = AuthIB(X[d], X[n], auth_then_branch);"}, {"mnemonic": "ST2B (scalar plus scalar)", "short_desc": "Contiguous store two-byte structures from two vectors (scalar index)", "full_desc": "Contiguous store two-byte structures, each from the same element number in two vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register and added to the base address. After each structure access the index value is incremented by two. The index register is not updated by the instruction.", "syntax": ["ST2B    { <Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "MOV (SIMD&FP scalar, predicated)", "short_desc": "Move SIMD&FP scalar register to vector elements (predicated)", "full_desc": "Move the SIMD & floating-point scalar source register to each active element in the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["MOV     <Zd>.<T>, <Pg>/M, <V><n>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<V>\n", "<n>\nIs the number [0-31] of the source SIMD&FP register, encoded in the \"Vn\" field."]}, {"mnemonic": "ASR (immediate, unpredicated)", "short_desc": "Arithmetic shift right by immediate (unpredicated)", "full_desc": "Shift right by immediate, preserving the sign bit, each element of the source vector, and place the results in the corresponding elements of the destination vector. The immediate shift amount is an unsigned value in the range 1 to number of bits per element. This instruction is unpredicated.", "syntax": ["ASR     <Zd>.<T>, <Zn>.<T>, #<const>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<const>\nIs the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\"."], "decode": "if !HaveSVE() then UNDEFINED;\nbits(4) tsize = tszh:tszl;\ncase tsize of\n    when '0000' UNDEFINED;\n    when '0001' esize = 8;\n    when '001x' esize = 16;\n    when '01xx' esize = 32;\n    when '1xxx' esize = 64;\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\ninteger shift = (2 * esize) - UInt(tsize:imm3);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    Elem[result, e, esize] = ASR(element1, shift);\n\nZ[d] = result;"}, {"mnemonic": "SQSUB", "short_desc": "Signed saturating Subtract", "full_desc": "Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SQSUB  <V><d>, <V><n>, <V><m>\t; Scalar", "SQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "DRPS", "short_desc": "Debug restore process state", "syntax": ["DRPS\t; System"], "symbols": [], "decode": "if !Halted() || PSTATE.EL == EL0 then UNDEFINED;", "operation": "DRPSInstruction();"}, {"mnemonic": "FMAXNMP (scalar)", "short_desc": "Floating-point Maximum Number of Pair of elements (scalar)", "full_desc": "Floating-point Maximum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP register.", "syntax": ["FMAXNMP  <V><d>, <Vn>.<T>\t; Half-precision", "FMAXNMP  <V><d>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<V>\n", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<T>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then UNDEFINED;\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "FCPY", "short_desc": "Copy 8-bit floating-point immediate to vector elements (predicated)", "full_desc": "Copy a floating-point immediate into each active element in the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FCPY    <Zd>.<T>, <Pg>/M, #<const>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<const>\nIs a floating-point immediate value expressable as \u00b1n\u00f716\u00d72^r, where n and r are integers such that 16 \u2264 n \u2264 31 and -3 \u2264 r \u2264 4, i.e. a normalized binary floating-point encoding with 1 sign bit, 3-bit exponent, and 4-bit fractional part, encoded in the \"imm8\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger d = UInt(Zd);\nbits(esize) imm = VFPExpandImm(imm8);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = imm;\n\nZ[d] = result;"}, {"mnemonic": "LD1RD", "short_desc": "Load and broadcast doubleword to vector", "full_desc": "Load a single doubleword from a memory address generated by a 64-bit scalar base address plus an immediate offset which is a multiple of 8 in the range 0 to 504.", "syntax": ["LD1RD   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 504, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 64;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\ninteger last = LastActiveElement(mask, esize);\nif last >= 0 then\n    addr = base + offset * mbytes;\n    data = Mem[addr, mbytes, AccType_NORMAL];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "SQNEG", "short_desc": "Signed saturating Negate", "full_desc": "Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.", "syntax": ["SQNEG  <V><d>, <V><n>\t; Scalar", "SQNEG  <Vd>.<T>, <Vn>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         \n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "STXR", "short_desc": "Store Exclusive Register", "full_desc": "Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See . For information about memory accesses see .", "syntax": ["STXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; 32-bit", "STXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SHA512H2", "short_desc": "SHA512 Hash update part 2", "full_desc": "SHA512 Hash update part 2 takes the values from the three 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the sigma0 and majority functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&FP register.", "syntax": ["SHA512H2  <Qd>, <Qn>, <Vm>.2D\t; Advanced SIMD"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Qn>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveSHA512Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vtmp;  \nbits(64) NSigma0;\nbits(64) tmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\n\nNSigma0 =  ROR(Y<63:0>, 28) EOR ROR(Y<63:0>,34) EOR ROR(Y<63:0>,39);\nVtmp<127:64> = (X<63:0> AND Y<127:64>) EOR (X<63:0> AND Y<63:0>) EOR (Y<127:64> AND Y<63:0>);\nVtmp<127:64> = (Vtmp<127:64> + NSigma0 +  W<127:64>);\nNSigma0 =  ROR(Vtmp<127:64>, 28) EOR ROR(Vtmp<127:64>,34) EOR ROR(Vtmp<127:64>,39);\nVtmp<63:0> =   (Vtmp<127:64> AND Y<63:0>) EOR (Vtmp<127:64> AND Y<127:64>) EOR (Y<127:64> AND Y<63:0>);\nVtmp<63:0> =   (Vtmp<63:0> + NSigma0 + W<63:0>);\n\nV[d] = Vtmp;"}, {"mnemonic": "FADDA", "short_desc": "Floating-point add strictly-ordered reduction, accumulating in scalar", "full_desc": "Floating-point add a SIMD&FP scalar source and all active lanes of the vector source and place the result destructively in the SIMD&FP scalar source register. Vector elements are processed strictly in order from low to high, with the scalar source providing the initial value. Inactive elements in the source vector are ignored.", "syntax": ["FADDA   <V><dn>, <Pg>, <V><dn>, <Zm>.<T>\t; SVE"], "symbols": ["<V>\n", "<dn>\nIs the number [0-31] of the source and destination SIMD&FP register, encoded in the \"Vdn\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the source scalable vector register, encoded in the \"Zm\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Vdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(esize) operand1 = V[dn];\nbits(VL) operand2 = Z[m];\nbits(esize) result = operand1;\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        bits(esize) element = Elem[operand2, e, esize];\n        result = FPAdd(result, element, FPCR<31:0>);\n\nV[dn] = result;"}, {"mnemonic": "CMEQ (register)", "short_desc": "Compare bitwise Equal (vector)", "full_desc": "Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["CMEQ  <V><d>, <V><n>, <V><m>\t; Scalar", "CMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean and_test = (U == '0');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if and_test then\n        test_passed = !IsZero(element1 AND element2);\n    else\n        test_passed = (element1 == element2);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FCM<cc> (vectors)", "short_desc": "Floating-point compare vectors", "full_desc": "Compare active floating-point elements in the first source vector with corresponding elements in the second source vector, and place the boolean results of the specified comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Does not set the condition flags.", "syntax": ["FCMEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Equal", "FCMGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than", "FCMGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Greater than or equal", "FCMNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Not equal", "FCMUO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>\t; Unordered"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Pd);\nSVECmp op = Cmp_EQ;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        case op of\n            when Cmp_EQ res = FPCompareEQ(element1, element2, FPCR<31:0>);\n            when Cmp_GE res = FPCompareGE(element1, element2, FPCR<31:0>);\n            when Cmp_GT res = FPCompareGT(element1, element2, FPCR<31:0>);\n            when Cmp_UN res = FPCompareUN(element1, element2, FPCR<31:0>);\n            when Cmp_NE res = FPCompareNE(element1, element2, FPCR<31:0>);\n            when Cmp_LT res = FPCompareGT(element2, element1, FPCR<31:0>);\n            when Cmp_LE res = FPCompareGE(element2, element1, FPCR<31:0>);\n        ElemP[result, e, esize] = if res then '1' else '0';\n    else\n        ElemP[result, e, esize] = '0';\n\nP[d] = result;"}, {"mnemonic": "CCMP (immediate)", "short_desc": "Conditional Compare (immediate)", "full_desc": "Conditional Compare (immediate) sets the value of the condition flags to the result of the comparison of a register value and an immediate value if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMP  <Wn>, #<imm>, #<nzcv>, <cond>\t; 32-bit", "CCMP  <Xn>, #<imm>, #<nzcv>, <cond>\t; 64-bit"], "symbols": ["<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<imm>\nIs a five bit unsigned (positive) immediate encoded in the \"imm5\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\nbits(datasize) imm = ZeroExtend(imm5, datasize);", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "STXP", "short_desc": "Store Exclusive Pair of registers", "full_desc": "Store Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords from two registers to a memory location if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See . A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. For information about memory accesses see .", "syntax": ["STXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\t; 32-bit", "STXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Xt1>\nIs the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>\nIs the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>\nIs the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt2>\nIs the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "UMULH", "short_desc": "Unsigned Multiply High", "full_desc": "Unsigned Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register.", "syntax": ["UMULH  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);           // ignored by UMULH/SMULH\ninteger destsize = 64;\ninteger datasize = destsize;\nboolean unsigned = (U == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\ninteger result;\n\nresult = Int(operand1, unsigned) * Int(operand2, unsigned);\n\nX[d] = result<127:64>;"}, {"mnemonic": "STSMAXB, STSMAXLB", "short_desc": "Atomic signed maximum on byte in memory, without return", "full_desc": "Atomic signed maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.", "syntax": ["STSMAXB  <Ws>, [<Xn|SP>]\t; No memory ordering", "STSMAXLB  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "LDURSH", "short_desc": "Load Register Signed Halfword (unscaled)", "full_desc": "Load Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses, see .", "syntax": ["LDURSH  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDURSH  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "USDOT (vector)", "short_desc": "Dot Product with unsigned and signed integers (vector)", "full_desc": "Dot Product vector form with unsigned and signed integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in the corresponding 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveInt8MatMulExt() then UNDEFINED;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 32;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    bits(32) res = Elem[operand3, e, 32];\n    for b = 0 to 3\n        integer element1 = UInt(Elem[operand1, 4 * e + b, 8]);\n        integer element2 = SInt(Elem[operand2, 4 * e + b, 8]);\n        res = res + element1 * element2;\n    Elem[result, e, 32] = res;\n\nV[d] = result;"}, {"mnemonic": "UMIN", "short_desc": "Unsigned Minimum (vector)", "full_desc": "Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SCVTF", "short_desc": "Signed integer convert to floating-point (predicated)", "full_desc": "Convert to floating-point from the signed integer in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SCVTF   <Zd>.H, <Pg>/M, <Zn>.H\t; 16-bit to half-precision", "SCVTF   <Zd>.H, <Pg>/M, <Zn>.S\t; 32-bit to half-precision", "SCVTF   <Zd>.S, <Pg>/M, <Zn>.S\t; 32-bit to single-precision", "SCVTF   <Zd>.D, <Pg>/M, <Zn>.S\t; 32-bit to double-precision", "SCVTF   <Zd>.H, <Pg>/M, <Zn>.D\t; 64-bit to half-precision", "SCVTF   <Zd>.S, <Pg>/M, <Zn>.D\t; 64-bit to single-precision", "SCVTF   <Zd>.D, <Pg>/M, <Zn>.D\t; 64-bit to double-precision"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\ninteger s_esize = 16;\ninteger d_esize = 16;\nboolean unsigned = FALSE;\nFPRounding rounding = FPRoundingMode(FPCR<31:0>);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        bits(d_esize) fpval = FixedToFP(element<s_esize-1:0>, 0, unsigned, FPCR<31:0>, rounding);\n        Elem[result, e, esize] = ZeroExtend(fpval);\n\nZ[d] = result;"}, {"mnemonic": "FCVT", "short_desc": "Floating-point Convert precision (scalar)", "full_desc": "Floating-point Convert precision (scalar). This instruction converts the floating-point value in the SIMD&FP source register to the precision for the destination register data type using the rounding mode that is determined by the  and writes the result to the SIMD&FP destination register.", "syntax": ["FCVT  <Sd>, <Hn>\t; Half-precision to single-precision", "FCVT  <Dd>, <Hn>\t; Half-precision to double-precision", "FCVT  <Hd>, <Sn>\t; Single-precision to half-precision", "FCVT  <Dd>, <Sn>\t; Single-precision to double-precision", "FCVT  <Hd>, <Dn>\t; Double-precision to half-precision", "FCVT  <Sd>, <Dn>\t; Double-precision to single-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger srcsize;\ninteger dstsize;\n\nif ftype == opc then UNDEFINED;\n\ncase ftype of\n    when '00' srcsize = 32;\n    when '01' srcsize = 64;\n    when '10' UNDEFINED;\n    when '11' srcsize = 16;\ncase opc of\n    when '00' dstsize = 32;\n    when '01' dstsize = 64;\n    when '10' UNDEFINED;\n    when '11' dstsize = 16;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(dstsize) result;\nbits(srcsize) operand = V[n];\n\nresult = FPConvert(operand, FPCR);\nV[d] = result;"}, {"mnemonic": "FRINTN (scalar)", "short_desc": "Floating-point Round to Integral, to nearest with ties to even (scalar)", "full_desc": "Floating-point Round to Integral, to nearest with ties to even (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTN  <Hd>, <Hn>\t; Half-precision", "FRINTN  <Sd>, <Sn>\t; Single-precision", "FRINTN  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "ADD (immediate)", "short_desc": "Add immediate (unpredicated)", "full_desc": "Add an unsigned immediate to each element of the source vector, and destructively place the results in the corresponding elements of the source vector. This instruction is unpredicated.", "syntax": ["ADD     <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger imm = UInt(imm8);\nif sh == '1' then imm = imm << 8;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    Elem[result, e, esize] = element1 + imm;\n\nZ[dn] = result;"}, {"mnemonic": "UCVTF (scalar, integer)", "short_desc": "Unsigned integer Convert to Floating-point (scalar)", "full_desc": "Unsigned integer Convert to Floating-point (scalar). This instruction converts the unsigned integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the , and writes the result to the SIMD&FP destination register.", "syntax": ["UCVTF  <Hd>, <Wn>\t; 32-bit to half-precision", "UCVTF  <Sd>, <Wn>\t; 32-bit to single-precision", "UCVTF  <Dd>, <Wn>\t; 32-bit to double-precision", "UCVTF  <Hd>, <Xn>\t; 64-bit to half-precision", "UCVTF  <Sd>, <Xn>\t; 64-bit to single-precision", "UCVTF  <Dd>, <Xn>\t; 64-bit to double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "LD1RQB (scalar plus immediate)", "short_desc": "Contiguous load and replicate sixteen bytes (immediate index)", "full_desc": "Load sixteen contiguous bytes to elements of a short, 128-bit (quadword) vector from the memory address generated by a 64-bit scalar base address and immediate index that is a multiple of 16 in the range -128 to +112 added to the base address.", "syntax": ["LD1RQB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate byte offset, a multiple of 16 in the range -128 to 112, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = 128 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low 16 bits only\nbits(128) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * 16;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = Replicate(result, VL DIV 128);"}, {"mnemonic": "UQDECH (scalar)", "short_desc": "Unsigned saturating decrement scalar by multiple of 16-bit predicate constraint element count", "full_desc": "Determines the number of active 16-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQDECH  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "UQDECH  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "STLLRH", "short_desc": "Store LORelease Register Halfword", "full_desc": "Store LORelease Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["STLLRH  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FMMLA", "short_desc": "Floating-point matrix multiply-accumulate", "full_desc": "The floating-point matrix multiply-accumulate instruction supports single-precision and double-precision data types in a 2\u00d72 matrix contained in segments of 128 or 256 bits, respectively. It multiplies the 2\u00d72 matrix in each segment of the first source vector by the 2\u00d72 matrix in the corresponding segment of the second source vector. The resulting 2\u00d72 matrix product is then destructively added to the matrix accumulator held in the corresponding segment of the addend and destination vector. This is equivalent to performing a 2-way dot product per destination element. This instruction is unpredicated. The single-precision variant is vector length agnostic. The double-precision variant requires that the current vector length is at least 256 bits, and if the current vector length is not an integer multiple of 256 bits then the trailing bits are set to zero.", "syntax": ["FMMLA   <Zda>.S, <Zn>.S, <Zm>.S\t; 32-bit element", "FMMLA   <Zda>.D, <Zn>.D, <Zm>.D\t; 64-bit element"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVEFP32MatMulExt() then UNDEFINED;\ninteger esize = 32;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\nif VL < esize * 4 then UNDEFINED;\ninteger segments = VL DIV (4 * esize);\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result = Zeros();\nbits(4*esize) op1, op2;\nbits(4*esize) res, addend;\n\nfor s = 0 to segments-1\n    op1    = Elem[operand1, s, 4*esize];\n    op2    = Elem[operand2, s, 4*esize];\n    addend = Elem[operand3, s, 4*esize];\n    res    = FPMatMulAdd(addend, op1, op2, esize, FPCR<31:0>);\n    Elem[result, s, 4*esize] = res;\n\nZ[da] = result;"}, {"mnemonic": "LDFF1W (scalar plus scalar)", "short_desc": "Contiguous load first-fault unsigned words to vector (scalar index)", "full_desc": "Contiguous load with first-faulting behavior of unsigned words to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 4 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]\t; 32-bit element", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + UInt(offset) * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "LDFF1W (vector plus immediate)", "short_desc": "Gather load first-fault unsigned words to vector (immediate index)", "full_desc": "Gather load with first-faulting behavior of unsigned words to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1W  { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]\t; 32-bit element", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "SMNEGL", "short_desc": "Signed Multiply-Negate Long", "full_desc": "Signed Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register.", "syntax": ["SMNEGL  <Xd>, <Wn>, <Wm>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "AND, ANDS (predicates)", "short_desc": "Bitwise AND predicates", "full_desc": "Bitwise AND active elements of the second source predicate with corresponding elements of the first source predicate and place the results in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["AND     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags", "ANDS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bit element1 = ElemP[operand1, e, esize];\n    bit element2 = ElemP[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        ElemP[result, e, esize] = element1 AND element2;\n    else\n        ElemP[result, e, esize] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "UZP1", "short_desc": "Unzip vectors (primary)", "full_desc": "Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UZP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operandl = V[n];\nbits(datasize) operandh = V[m];\nbits(datasize) result;\n\nbits(datasize*2) zipped = operandh:operandl;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\n\nV[d] = result;"}, {"mnemonic": "LD1 (single structure)", "short_desc": "Load one single-element structure to one lane of one register", "full_desc": "Load one single-element structure to one lane of one register. This instruction loads a single-element structure from memory and writes the result to the specified lane of the SIMD&FP register without affecting the other bits of the register.", "syntax": ["LD1  { <Vt>.B }[<index>], [<Xn|SP>]\t; 8-bit", "LD1  { <Vt>.H }[<index>], [<Xn|SP>]\t; 16-bit", "LD1  { <Vt>.S }[<index>], [<Xn|SP>]\t; 32-bit", "LD1  { <Vt>.D }[<index>], [<Xn|SP>]\t; 64-bit", "LD1  { <Vt>.B }[<index>], [<Xn|SP>], #1\t; 8-bit, immediate offset", "LD1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset", "LD1  { <Vt>.H }[<index>], [<Xn|SP>], #2\t; 16-bit, immediate offset", "LD1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset", "LD1  { <Vt>.S }[<index>], [<Xn|SP>], #4\t; 32-bit, immediate offset", "LD1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset", "LD1  { <Vt>.D }[<index>], [<Xn|SP>], #8\t; 64-bit, immediate offset", "LD1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<index>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<index>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<index>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<index>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "MAD", "short_desc": "Multiply-add vectors (predicated), writing multiplicand [Zdn = Za + Zdn * Zm]", "full_desc": "Multiply the corresponding active elements of the first and second source vectors and add to elements of the third (addend) vector. Destructively place the results in the destination and first source (multiplicand) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["MAD     <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Za>\nIs the name of the third source scalable vector register, encoded in the \"Za\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\ninteger a = UInt(Za);\nboolean sub_op = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[a];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = UInt(Elem[operand1, e, esize]);\n    integer element2 = UInt(Elem[operand2, e, esize]);\n    if ElemP[mask, e, esize] == '1' then\n        integer product = element1 * element2;\n        if sub_op then\n            Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n        else\n            Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "LD1RW", "short_desc": "Load and broadcast unsigned word to vector", "full_desc": "Load a single unsigned word from a memory address generated by a 64-bit scalar base address plus an immediate offset which is a multiple of 4 in the range 0 to 252.", "syntax": ["LD1RW   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 32-bit element", "LD1RW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 252, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 32;\nboolean unsigned = TRUE;\ninteger offset = UInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\ninteger last = LastActiveElement(mask, esize);\nif last >= 0 then\n    addr = base + offset * mbytes;\n    data = Mem[addr, mbytes, AccType_NORMAL];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "USDOT (vectors)", "short_desc": "Unsigned by signed integer dot product", "full_desc": "The unsigned by signed integer dot product instruction computes the dot product of a group of four unsigned 8-bit integer values held in each 32-bit element of the first source vector multiplied by a group of four signed 8-bit integer values in the corresponding 32-bit element of the second source vector, and then destructively adds the widened dot product to the corresponding 32-bit element of the destination vector.", "syntax": ["USDOT   <Zda>.S, <Zn>.B, <Zm>.B\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;\ninteger esize = 32;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) res = Elem[operand3, e, esize];\n    for i = 0 to 3\n        integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n        integer element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        res = res + element1 * element2;\n    Elem[result, e, esize] = res;\n\nZ[da] = result;"}, {"mnemonic": "MOV (predicate, unpredicated)", "short_desc": "Move predicate (unpredicated)", "full_desc": "Read all elements from the source predicate and place in the destination predicate. This instruction is unpredicated. Does not set the condition flags.", "syntax": ["MOV     <Pd>.B, <Pn>.B\t; Not setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field."]}, {"mnemonic": "RET", "short_desc": "Return from subroutine", "full_desc": "Return from subroutine branches unconditionally to an address in a register, with a hint that this is a subroutine return.", "syntax": ["RET  {<Xn>}\t; Integer"], "symbols": ["<Xn>\nIs the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field. Defaults to X30 if absent."], "decode": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UNDEFINED;\nelsif pac && !HavePACExt() then \n    UNDEFINED;\n\ncase op of\n    when '00' branch_type = BranchType_INDIR;\n    when '01' branch_type = BranchType_INDCALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UNDEFINED;\n\nif pac then\n    if Z == '0' && m != 31 then\n        UNDEFINED;\n\n    if branch_type == BranchType_RET then\n        if n != 31 then UNDEFINED;\n        n = 30;\n        source_is_sp = TRUE;", "operation": "bits(64) target = X[n];\nboolean auth_then_branch = TRUE;\n\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier, auth_then_branch);\n    else\n        target = AuthIB(target, modifier, auth_then_branch);\n\nif branch_type == BranchType_INDCALL then X[30] = PC[] + 4;\n\n// Value in BTypeNext will be used to set PSTATE.BTYPE\ncase branch_type of\n    when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ\n        if InGuardedPage then\n            if n == 16 || n == 17 then\n                BTypeNext = '01';\n            else\n                BTypeNext = '11';\n        else\n            BTypeNext = '01';\n    when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ\n        BTypeNext = '10';\n    when BranchType_RET             // RET, RETAA, RETAB \n        BTypeNext = '00';\n\nBranchTo(target, branch_type);"}, {"mnemonic": "CMP<cc> (wide elements)", "short_desc": "Compare vector to 64-bit wide elements", "full_desc": "Compare active integer elements in the first source vector with overlapping 64-bit doubleword elements in the second source vector, and place the boolean results of the specified comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["CMPEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Equal", "CMPGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Greater than", "CMPGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Greater than or equal", "CMPHI   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Higher", "CMPHS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Higher or same", "CMPLT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Less than", "CMPLE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Less than or equal", "CMPLO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Lower", "CMPLS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Lower or same", "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D\t; Not equal"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Pd);\nSVECmp op = Cmp_EQ;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, (e * esize) DIV 64, 64], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        boolean cond;\n        case op of\n            when Cmp_EQ cond = element1 == element2;\n            when Cmp_NE cond = element1 != element2;\n            when Cmp_GE cond = element1 >= element2;\n            when Cmp_LT cond = element1 <  element2;\n            when Cmp_GT cond = element1 >  element2;\n            when Cmp_LE cond = element1 <= element2;\n        ElemP[result, e, esize] = if cond then '1' else '0';\n    else\n        ElemP[result, e, esize] = '0';\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "UCVTF (vector, fixed-point)", "short_desc": "Unsigned fixed-point Convert to Floating-point (vector)", "full_desc": "Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the , and writes the result to the SIMD&FP destination register.", "syntax": ["UCVTF  <V><d>, <V><n>, #<fbits>\t; Scalar", "UCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<fbits>\n", "<fbits>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FCMGE (zero)", "short_desc": "Floating-point Compare Greater than or Equal to zero (vector)", "full_desc": "Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FCMGE  <Hd>, <Hn>, #0.0\t; Scalar half precision", "FCMGE  <V><d>, <V><n>, #0.0\t; Scalar single-precision and double-precision", "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector half precision", "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FMOV (general)", "short_desc": "Floating-point Move to or from general-purpose register without conversion", "full_desc": "Floating-point Move to or from general-purpose register without conversion. This instruction transfers the contents of a SIMD&FP register to a general-purpose register, or the contents of a general-purpose register to a SIMD&FP register.", "syntax": ["FMOV  <Wd>, <Hn>\t; Half-precision to 32-bit", "FMOV  <Xd>, <Hn>\t; Half-precision to 64-bit", "FMOV  <Hd>, <Wn>\t; 32-bit to half-precision", "FMOV  <Sd>, <Wn>\t; 32-bit to single-precision", "FMOV  <Wd>, <Sn>\t; Single-precision to 32-bit", "FMOV  <Hd>, <Xn>\t; 64-bit to half-precision", "FMOV  <Dd>, <Xn>\t; 64-bit to double-precision", "FMOV  <Vd>.D[1], <Xn>\t; 64-bit to top half of 128-bit", "FMOV  <Xd>, <Dn>\t; Double-precision to 64-bit", "FMOV  <Xd>, <Vn>.D[1]\t; Top half of 128-bit to 64-bit"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "MOV (scalar)", "short_desc": "Move vector element to scalar", "full_desc": "Move vector element to scalar. This instruction duplicates the specified vector element in the SIMD&FP source register into a scalar, and writes the result to the SIMD&FP destination register.", "syntax": ["MOV  <V><d>, <Vn>.<T>[<index>]\t; Scalar"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<index>\n"]}, {"mnemonic": "DVP", "short_desc": "Data Value Prediction Restriction by Context", "full_desc": "Data Value Prediction Restriction by Context prevents data value predictions, based on information gathered from earlier execution within an particular execution context, from allowing later speculative execution within that context to be observable through side-channels.", "syntax": ["DVP  RCTX, <Xt>\t; System"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."]}, {"mnemonic": "FRINT32Z (scalar)", "short_desc": "Floating-point Round to 32-bit Integer toward Zero (scalar)", "full_desc": "Floating-point Round to 32-bit Integer toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINT32Z  <Sd>, <Sn>\t; Single-precision", "FRINT32Z  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFrintExt() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '1x' UNDEFINED;\n\ninteger intsize = if op<1> == '0' then 32 else 64;\n\nFPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundIntN(operand, FPCR, rounding, intsize);\n\nV[d] = result;"}, {"mnemonic": "LD1RSW", "short_desc": "Load and broadcast signed word to vector", "full_desc": "Load a single signed word from a memory address generated by a 64-bit scalar base address plus an immediate offset which is a multiple of 4 in the range 0 to 252.", "syntax": ["LD1RSW  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 252, defaulting to 0, encoded in the \"imm6\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 32;\nboolean unsigned = FALSE;\ninteger offset = UInt(imm6);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\ninteger last = LastActiveElement(mask, esize);\nif last >= 0 then\n    addr = base + offset * mbytes;\n    data = Mem[addr, mbytes, AccType_NORMAL];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "MVN", "short_desc": "Bitwise NOT", "full_desc": "Bitwise NOT writes the bitwise inverse of a register value to the destination register.", "syntax": ["MVN  <Wd>, <Wm>{, <shift> #<amount>}\t; 32-bit", "MVN  <Xd>, <Xm>{, <shift> #<amount>}\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<amount>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,"]}, {"mnemonic": "FMLSL, FMLSL2 (by element)", "short_desc": "Floating-point fused Multiply-Subtract Long from accumulator (by element)", "full_desc": "Floating-point fused Multiply-Subtract Long from accumulator (by element). This instruction multiplies the negated vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.", "syntax": ["FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]\t; FMLSL", "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]\t; FMLSL2"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<index>\nIs the element index, encoded in the \"H:L:M\" fields."], "decode": "if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.\nif sz == '1' then UNDEFINED;\ninteger index = UInt(H:L:M); \n\ninteger esize = 32;\ninteger datasize = if Q=='1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (S == '1');\ninteger part = 0;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize DIV 2) operand1 = Vpart[n,part];\nbits(128) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize DIV 2) element1;\nbits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize DIV 2];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"}, {"mnemonic": "SQDECP (vector)", "short_desc": "Signed saturating decrement vector by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to decrement all destination vector elements. The results are saturated to the element signed integer range.", "syntax": ["SQDECP  <Zdn>.<T>, <Pm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Zdn);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(PL) operand2 = P[m];\nbits(VL) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\nfor e = 0 to elements-1\n    integer element = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element - count, esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "ANDS (immediate)", "short_desc": "Bitwise AND (immediate), setting flags", "full_desc": "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register. It updates the condition flags based on the result.", "syntax": ["ANDS  <Wd>, <Wn>, #<imm>\t; 32-bit", "ANDS  <Xd>, <Xn>, #<imm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<imm>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then UNDEFINED;\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "ROR (register)", "short_desc": "Rotate Right (register)", "full_desc": "Rotate Right (register) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted.", "syntax": ["ROR  <Wd>, <Wn>, <Wm>\t; 32-bit", "ROR  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."]}, {"mnemonic": "SABAL, SABAL2", "short_desc": "Signed Absolute difference and Accumulate Long", "full_desc": "Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.", "syntax": ["SABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"}, {"mnemonic": "LDFF1SB (scalar plus vector)", "short_desc": "Gather load first-fault signed bytes to vector (vector index)", "full_desc": "Gather load with first-faulting behavior of signed bytes to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally sign or zero-extended from 32 to 64 bits. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LDFF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LDFF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 8;\ninteger offs_size = 32;\nboolean unsigned = FALSE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 0;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "SUBR (immediate)", "short_desc": "Reversed subtract from immediate (unpredicated)", "full_desc": "Reversed subtract from an unsigned immediate each element of the source vector, and destructively place the results in the corresponding elements of the source vector. This instruction is unpredicated.", "syntax": ["SUBR    <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field.", "<shift>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size:sh == '001' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\ninteger imm = UInt(imm8);\nif sh == '1' then imm = imm << 8;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = UInt(Elem[operand1, e, esize]);\n    Elem[result, e, esize] = (imm - element1)<esize-1:0>;\n\nZ[dn] = result;"}, {"mnemonic": "FCVTAS (scalar)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTAS  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTAS  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTAS  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTAS  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTAS  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTAS  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "LD2B (scalar plus immediate)", "short_desc": "Contiguous load two-byte structures to two vectors (immediate index)", "full_desc": "Contiguous load two-byte structures, each to the same element number in two vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 2 in the range -16 to 14 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD2B    { <Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 8;\ninteger offset = SInt(imm4);\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "LSR (immediate, unpredicated)", "short_desc": "Logical shift right by immediate (unpredicated)", "full_desc": "Shift right by immediate, inserting zeroes, each element of the source vector, and place the results in the corresponding elements of the destination vector. The immediate shift amount is an unsigned value in the range 1 to number of bits per element. This instruction is unpredicated.", "syntax": ["LSR     <Zd>.<T>, <Zn>.<T>, #<const>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<const>\nIs the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\"."], "decode": "if !HaveSVE() then UNDEFINED;\nbits(4) tsize = tszh:tszl;\ncase tsize of\n    when '0000' UNDEFINED;\n    when '0001' esize = 8;\n    when '001x' esize = 16;\n    when '01xx' esize = 32;\n    when '1xxx' esize = 64;\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\ninteger shift = (2 * esize) - UInt(tsize:imm3);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    Elem[result, e, esize] = LSR(element1, shift);\n\nZ[d] = result;"}, {"mnemonic": "NOP", "short_desc": "No Operation", "full_desc": "No Operation does nothing, other than advance the value of the program counter by 4. This instruction can be used for instruction alignment purposes.", "syntax": ["NOP\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "EOR (vectors, unpredicated)", "short_desc": "Bitwise exclusive OR vectors (unpredicated)", "full_desc": "Bitwise exclusive OR all elements of the second source vector with corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["EOR     <Zd>.D, <Zn>.D, <Zm>.D\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\n\nZ[d] = operand1 EOR operand2;"}, {"mnemonic": "SMIN (vectors)", "short_desc": "Signed minimum vectors (predicated)", "full_desc": "Determine the signed minimum of active elements of the second source vector and corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["SMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer minimum = Min(element1, element2);\n        Elem[result, e, esize] = minimum<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "FCVTZU (vector, fixed-point)", "short_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTZU  <V><d>, <V><n>, #<fbits>\t; Scalar", "FCVTZU  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<fbits>\n", "<fbits>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "SMAX (immediate)", "short_desc": "Signed maximum with immediate (unpredicated)", "full_desc": "Determine the signed maximum of an immediate and each element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is a signed 8-bit value in the range -128 to +127, inclusive. This instruction is unpredicated.", "syntax": ["SMAX    <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs the signed immediate operand, in the range -128 to 127, encoded in the \"imm8\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\nboolean unsigned = FALSE;\ninteger imm = Int(imm8, unsigned);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    Elem[result, e, esize] = Max(element1, imm)<esize-1:0>;\n\nZ[dn] = result;"}, {"mnemonic": "LDNT1B (scalar plus scalar)", "short_desc": "Contiguous load non-temporal bytes to vector (scalar index)", "full_desc": "Contiguous load non-temporal of bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNT1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(64) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = X[m];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];\n    else\n        Elem[result, e, esize] = Zeros();\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "FNMLA", "short_desc": "Floating-point negated fused multiply-add vectors (predicated), writing addend [Zda = -Zda + -Zn * Zm]", "full_desc": "Multiply the corresponding active floating-point elements of the first and second source vectors and add to elements of the third source (addend) vector without intermediate rounding. Destructively place the negated results in the destination and third source (addend) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FNMLA   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean op1_neg = TRUE;\nboolean op3_neg = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    bits(esize) element3 = Elem[operand3, e, esize];\n\n    if ElemP[mask, e, esize] == '1' then\n        if op1_neg then element1 = FPNeg(element1);\n        if op3_neg then element3 = FPNeg(element3);\n        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element3;\n\nZ[da] = result;"}, {"mnemonic": "ESB", "short_desc": "Error Synchronization Barrier", "full_desc": "Error Synchronization Barrier is an error synchronization event that might also update DISR_EL1 and VDISR_EL2.", "syntax": ["ESB\t; System"], "symbols": [], "decode": "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 110'\n        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_DGH;\n    when '0000 111' SEE \"XPACLRI\";\n    when '0001 xxx'\n        case op2 of\n            when '000' SEE \"PACIA1716\";\n            when '010' SEE \"PACIB1716\";\n            when '100' SEE \"AUTIA1716\";\n            when '110' SEE \"AUTIB1716\";\n            otherwise EndOfInstruction();                          // Instruction executes as NOP\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0010 010'\n        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP\n        op = SystemHintOp_TSB;\n    when '0010 100'\n        op = SystemHintOp_CSDB;\n    when '0011 xxx'\n        case op2 of\n            when '000' SEE \"PACIAZ\";\n            when '001' SEE \"PACIASP\";\n            when '010' SEE \"PACIBZ\";\n            when '011' SEE \"PACIBSP\";\n            when '100' SEE \"AUTIAZ\";\n            when '101' SEE \"AUTHASP\";\n            when '110' SEE \"AUTIBZ\";\n            when '111' SEE \"AUTIBSP\";\n    when '0100 xx0'\n        op = SystemHintOp_BTI;\n        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE\n        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));\n    otherwise EndOfInstruction();                                 // Instruction executes as NOP", "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_DGH\n        Hint_DGH();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            trap = FALSE;\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                if HaveTWEDExt() then\n                    sctlr = SCTLR[];\n                    trap  = sctlr.nTWE == '0';\n                    target_el = EL1;\n                else\n                    AArch64.CheckForWFxTrap(EL1, TRUE);\n\n            if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                if HaveTWEDExt() then\n                    trap = HCR_EL2.TWE == '1';\n                    target_el = EL2;\n                else\n                    AArch64.CheckForWFxTrap(EL2, TRUE);\n\n            if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                if HaveTWEDExt() then\n                    trap = SCR_EL3.TWE == '1';\n                    target_el = EL3;\n                else\n                    AArch64.CheckForWFxTrap(EL3, TRUE);\n\n            if HaveTWEDExt() && trap && PSTATE.EL != EL3 then\n                (delay_enabled, delay) = WFETrapDelay(target_el);    // (If trap delay is enabled, Delay amount)\n                if !AArch64.WaitForEventUntilDelay(delay_enabled, delay) then\n                    // Event did not arrive until delay expired\n                    AArch64.WFxTrap(target_el, TRUE);                // Trap WFE\n            else\n                WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    when SystemHintOp_TSB\n        TraceSynchronizationBarrier();\n\n    when SystemHintOp_CSDB\n        ConsumptionOfSpeculativeDataBarrier();\n\n    when SystemHintOp_BTI\n        SetBTypeNext('00');\n\n    otherwise // do nothing"}, {"mnemonic": "NOR, NORS", "short_desc": "Bitwise NOR predicates", "full_desc": "Bitwise NOR active elements of the second source predicate with corresponding elements of the first source predicate and place the results in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Optionally sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["NOR     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Not setting the condition flags", "NORS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B\t; Setting the condition flags"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>\nIs the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>\nIs the name of the second source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8;\ninteger g = UInt(Pg);\ninteger n = UInt(Pn);\ninteger m = UInt(Pm);\ninteger d = UInt(Pd);\nboolean setflags = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand1 = P[n];\nbits(PL) operand2 = P[m];\nbits(PL) result;\n\nfor e = 0 to elements-1\n    bit element1 = ElemP[operand1, e, esize];\n    bit element2 = ElemP[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        ElemP[result, e, esize] = NOT(element1 OR element2);\n    else\n        ElemP[result, e, esize] = '0';\n\nif setflags then\n    PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "USUBW, USUBW2", "short_desc": "Unsigned Subtract Wide", "full_desc": "Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.", "syntax": ["USUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Tb>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQDECW (vector)", "short_desc": "Signed saturating decrement vector by multiple of 32-bit predicate constraint element count", "full_desc": "Determines the number of active 32-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement all destination vector elements. The results are saturated to the 32-bit signed integer range.", "syntax": ["SQDECW  <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "PACDB, PACDZB", "short_desc": "Pointer Authentication Code for Data address, using key B", "full_desc": "Pointer Authentication Code for Data address, using key B. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key B.", "syntax": ["PACDB  <Xd>, <Xn|SP>\t; PACDB", "PACDZB  <Xd>\t; PACDZB"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field."], "decode": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif Z == '0' then // PACDB\n    if n == 31 then source_is_sp = TRUE;\nelse // PACDZB\n    if n != 31 then UNDEFINED;", "operation": "if source_is_sp then\n    X[d] = AddPACDB(X[d], SP[]);\nelse\n    X[d] = AddPACDB(X[d], X[n]);"}, {"mnemonic": "CPP", "short_desc": "Cache Prefetch Prediction Restriction by Context", "full_desc": "Cache Prefetch Prediction Restriction by Context prevents cache allocation predictions, based on information gathered from earlier execution within a particular execution context, from allowing later speculative execution within that context to be observable through side-channels.", "syntax": ["CPP  RCTX, <Xt>\t; System"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."]}, {"mnemonic": "COMPACT", "short_desc": "Shuffle active elements of vector to the right and fill with zero", "full_desc": "Read the active elements from the source vector and pack them into the lowest-numbered elements of the destination vector. Then set any remaining elements of the destination vector to zero.", "syntax": ["COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '0x' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) result;\ninteger x = 0;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Zeros();\n    if ElemP[mask, e, esize] == '1' then\n        bits(esize) element = Elem[operand1, e, esize];\n        Elem[result, x, esize] = element;\n        x = x + 1;\n\nZ[d] = result;"}, {"mnemonic": "LDFF1SW (vector plus immediate)", "short_desc": "Gather load first-fault signed words to vector (immediate index)", "full_desc": "Gather load with first-faulting behavior of signed words to active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1SW { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 32;\nboolean unsigned = FALSE;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "LDFF1SW (scalar plus scalar)", "short_desc": "Contiguous load first-fault signed words to vector (scalar index)", "full_desc": "Contiguous load with first-faulting behavior of signed words to elements of a vector register from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 4 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 32;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nbits(64) offset = X[m];\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + UInt(offset) * mbytes;\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    offset = offset + 1;\n\nZ[t] = result;"}, {"mnemonic": "SBFM", "short_desc": "Signed Bitfield Move", "full_desc": "Signed Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly.", "syntax": ["SBFM  <Wd>, <Wn>, #<immr>, #<imms>\t; 32-bit", "SBFM  <Xd>, <Xn>, #<immr>, #<imms>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<immr>\nFor the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the \"immr\" field.", "<immr>\nFor the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the \"immr\" field.", "<imms>\nFor the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31, encoded in the \"imms\" field.", "<imms>\nFor the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the \"imms\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\n\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    // SBFM\n    when '01' inzero = FALSE; extend = FALSE;   // BFM\n    when '10' inzero = TRUE;  extend = FALSE;   // UBFM\n    when '11' UNDEFINED;\n\nif sf == '1' && N != '1' then UNDEFINED;\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;\n\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);", "operation": "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\n\n// perform bitfield move on low bits\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\n\n// determine extension bits (sign, zero or dest register)\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\n\n// combine extension bits and result bits\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);"}, {"mnemonic": "ST1H (vector plus immediate)", "short_desc": "Scatter store halfwords from a vector (immediate index)", "full_desc": "Scatter store of halfwords from the active elements of a vector register to the memory addresses generated by a vector base plus immediate index. The index is a multiple of 2 in the range 0 to 62. Inactive elements are not written to memory.", "syntax": ["ST1H    { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element", "ST1H    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Zn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) base = Z[n];\nbits(VL) src = Z[t];\nbits(PL) mask = P[g];\nbits(64) addr;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;"}, {"mnemonic": "SLI", "short_desc": "Shift Left and Insert (immediate)", "full_desc": "Shift Left and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register, left shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the left of each vector element in the source register are lost.", "syntax": ["SLI  <V><d>, <V><n>, #<shift>\t; Scalar", "SLI  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSL(Ones(esize), shift);\nbits(esize) shifted;\n\nfor e = 0 to elements-1\n    shifted = LSL(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nV[d] = result;"}, {"mnemonic": "ST1H (scalar plus scalar)", "short_desc": "Contiguous store halfwords from vector (scalar index)", "full_desc": "Contiguous store of halfwords from elements of a vector register to the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 2 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements are not written to memory.", "syntax": ["ST1H    { <Zt>.<T> }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 8 << UInt(size);\ninteger msize = 16;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nbits(VL) src = Z[t];\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;\n    offset = offset + 1;"}, {"mnemonic": "STADDH, STADDLH", "short_desc": "Atomic add on halfword in memory, without return", "full_desc": "Atomic add on halfword in memory, without return, atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory.", "syntax": ["STADDH  <Ws>, [<Xn|SP>]\t; No memory ordering", "STADDLH  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "SYSL", "short_desc": "System instruction with result", "full_desc": "System instruction with result. For more information, see  for the encodings of System instructions.", "syntax": ["SYSL  <Xt>, #<op1>, <Cn>, <Cm>, #<op2>\t; System"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rt\" field.", "<op1>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cn>\nIs a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<Cm>\nIs a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field."], "decode": "AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 1;\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean has_result = (L == '1');", "operation": "if has_result then\n    // No architecturally defined instructions here.\n    X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"}, {"mnemonic": "FRSQRTS", "short_desc": "Floating-point reciprocal square root step (unpredicated)", "full_desc": "Multiply corresponding floating-point elements of the first and second source vectors, subtract the products from 3.0 and divide the results by 2.0 without any intermediate rounding and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["FRSQRTS <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);\n\nZ[d] = result;"}, {"mnemonic": "USRA", "short_desc": "Unsigned Shift Right and Accumulate (immediate)", "full_desc": "Unsigned Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see .", "syntax": ["USRA  <V><d>, <V><n>, #<shift>\t; Scalar", "USRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "PRFH (scalar plus scalar)", "short_desc": "Contiguous prefetch halfwords (scalar index)", "full_desc": "Contiguous prefetch of halfword elements from the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 2 and added to the base address. After each element prefetch the index value is incremented, but the index register is not updated.", "syntax": ["PRFH    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger esize = 16;\ninteger g = UInt(Pg);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 1;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(64) base;\nbits(64) offset = X[m];\nbits(64) addr;\n\nif n == 31 then\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = base + (UInt(offset) << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);\n    offset = offset + 1;"}, {"mnemonic": "PRFH (vector plus immediate)", "short_desc": "Gather prefetch halfwords (vector plus immediate)", "full_desc": "Gather prefetch of halfwords from the active memory addresses generated by a vector base plus immediate index. The index is a multiple of 2 in the range 0 to 62. Inactive addresses are not prefetched from memory.", "syntax": ["PRFH    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]\t; 32-bit element", "PRFH    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]\t; 64-bit element"], "symbols": ["<prfop>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>\nIs the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger level = UInt(prfop<2:1>);\nboolean stream = (prfop<0> == '1');\npref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;\ninteger scale = 1;\ninteger offset = UInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) base;\nbits(64) addr;\nbase = Z[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);\n        Hint_Prefetch(addr, pref_hint, level, stream);"}, {"mnemonic": "HVC", "short_desc": "Hypervisor Call", "full_desc": "Hypervisor Call causes an exception to EL2. Non-secure software executing at EL1 can use this instruction to call the hypervisor to request a service.", "syntax": ["HVC  #<imm>\t; System"], "symbols": ["<imm>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "bits(16) imm = imm16;", "operation": "if !HaveEL(EL2) || PSTATE.EL == EL0 || (PSTATE.EL == EL1 && (!IsSecureEL2Enabled() && IsSecure())) then\n    UNDEFINED;\n\nhvc_enable = if HaveEL(EL3) then SCR_EL3.HCE else NOT(HCR_EL2.HCD);\n\nif hvc_enable == '0' then\n    UNDEFINED;\nelse\n    AArch64.CallHypervisor(imm);"}, {"mnemonic": "LDAPURH", "short_desc": "Load-Acquire RCpc Register Halfword (unscaled)", "full_desc": "Load-Acquire RCpc Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register.", "syntax": ["LDAPURH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_ORDERED;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "INDEX (scalar, immediate)", "short_desc": "Create index starting from general-purpose register and incremented by immediate", "full_desc": "Populates the destination vector by setting the first element to the first signed scalar integer operand and monotonically incrementing the value by the second signed immediate integer operand for each subsequent element. The scalar source operand is a general-purpose register in which only the least significant bits corresponding to the vector element size are used and any remaining bits are ignored. This instruction is unpredicated.", "syntax": ["INDEX   <Zd>.<T>, <R><n>, #<imm>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<R>\n", "<n>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field.", "<imm>\nIs the signed immediate operand, in the range -16 to 15, encoded in the \"imm5\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Rn);\ninteger d = UInt(Zd);\ninteger imm = SInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(esize) operand1 = X[n];\ninteger element1 = SInt(operand1);\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer index = element1 + e * imm;\n    Elem[result, e, esize] = index<esize-1:0>;\n\nZ[d] = result;"}, {"mnemonic": "ORV", "short_desc": "Bitwise inclusive OR reduction to scalar", "full_desc": "Bitwise inclusive OR horizontally across all lanes of a vector, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as zero.", "syntax": ["ORV     <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(esize) result = Zeros(esize);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        result = result OR Elem[operand, e, esize];\n\nV[d] = result;"}, {"mnemonic": "FACLT", "short_desc": "Floating-point absolute compare less than", "full_desc": "Compare active absolute values of floating-point elements in the first source vector being less than corresponding absolute values of elements in the second source vector, and place the boolean results of the comparison in the corresponding elements of the destination predicate. Inactive elements in the destination predicate register are set to zero. Does not set the condition flags.", "syntax": ["FACLT   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>\t; Greater than"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."]}, {"mnemonic": "AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA", "short_desc": "Authenticate Instruction address, using key A", "full_desc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A.", "syntax": ["AUTIA  <Xd>, <Xn|SP>\t; AUTIA", "AUTIZA  <Xd>\t; AUTIZA", "AUTIA1716\t; AUTIA1716", "AUTIASP\t; AUTIASP", "AUTIAZ\t; AUTIAZ"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field."], "decode": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif Z == '0' then // AUTIA\n    if n == 31 then source_is_sp = TRUE;\nelse // AUTIZA\n    if n != 31 then UNDEFINED;", "operation": "auth_then_branch = FALSE;\n\nif HavePACExt() then\n    if source_is_sp then\n        X[d] = AuthIA(X[d], SP[], auth_then_branch);\n    else\n        X[d] = AuthIA(X[d], X[n], auth_then_branch);"}, {"mnemonic": "SHA1P", "short_desc": "SHA1 hash update (parity)", "full_desc": "SHA1 hash update (parity).", "syntax": ["SHA1P  <Qd>, <Sn>, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif !HaveSHA1Ext() then UNDEFINED;", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAparity(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;"}, {"mnemonic": "LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH", "short_desc": "Atomic unsigned minimum on halfword in memory", "full_desc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDUMINAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINAH", "LDUMINALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINALH", "LDUMINH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINH", "LDUMINLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMINLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "STTR", "short_desc": "Store Register (unprivileged)", "full_desc": "Store Register (unprivileged) stores a word or doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset.", "syntax": ["STTR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "STTR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\n\nunpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');\nunpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';\n\nuser_access_override = HaveUAOExt() && PSTATE.UAO == '1';\nif !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then\n    acctype = AccType_UNPRIV;\nelse\n    acctype = AccType_NORMAL;\n\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "SMULL", "short_desc": "Signed Multiply Long", "full_desc": "Signed Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register.", "syntax": ["SMULL  <Xd>, <Wn>, <Wm>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "SVC", "short_desc": "Supervisor Call", "full_desc": "Supervisor Call causes an exception to be taken to EL1.", "syntax": ["SVC  #<imm>\t; System"], "symbols": ["<imm>\nIs a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."], "decode": "bits(16) imm = imm16;", "operation": "AArch64.CheckForSVCTrap(imm);\nAArch64.CallSupervisor(imm);"}, {"mnemonic": "LDFF1B (scalar plus vector)", "short_desc": "Gather load first-fault unsigned bytes to vector (vector index)", "full_desc": "Gather load with first-faulting behavior of unsigned bytes to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally sign or zero-extended from 32 to 64 bits. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LDFF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LDFF1B  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LDFF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger msize = 8;\ninteger offs_size = 32;\nboolean unsigned = TRUE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 0;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean first = TRUE;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = Z[m];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        if first then\n            // Mem[] will not return if a fault is detected for the first active element\n            data = Mem[addr, mbytes, AccType_NORMAL];\n            first = FALSE;\n        else\n            // MemNF[] will return fault=TRUE if access is not performed for any reason\n            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\nZ[t] = result;"}, {"mnemonic": "SWP, SWPA, SWPAL, SWPL", "short_desc": "Swap word or doubleword in memory", "full_desc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.", "syntax": ["SWP  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit SWP", "SWPA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit SWPA", "SWPAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit SWPAL", "SWPL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit SWPL", "SWP  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit SWP", "SWPA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit SWPA", "SWPAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit SWPAL", "SWPL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit SWPL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nbits(datasize) store_value;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nstore_value = X[s];\ndata = MemAtomic(address, MemAtomicOp_SWP, store_value, ldacctype, stacctype);\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "LDARB", "short_desc": "Load-Acquire Register Byte", "full_desc": "Load-Acquire Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["LDARB  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FMUL (vectors, unpredicated)", "short_desc": "Floating-point multiply vectors (unpredicated)", "full_desc": "Multiply all elements of the first source vector by corresponding floating-point elements of the second source vector and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["FMUL    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMul(element1, element2, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "ROR (immediate)", "short_desc": "Rotate right (immediate)", "full_desc": "Rotate right (immediate) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left.", "syntax": ["ROR  <Wd>, <Ws>, #<shift>\t; 32-bit", "ROR  <Xd>, <Xs>, #<shift>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Ws>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xs>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<shift>\nFor the 32-bit variant: is the amount by which to rotate, in the range 0 to 31, encoded in the \"imms\" field.", "<shift>\nFor the 64-bit variant: is the amount by which to rotate, in the range 0 to 63, encoded in the \"imms\" field."]}, {"mnemonic": "FMINNM (scalar)", "short_desc": "Floating-point Minimum Number (scalar)", "full_desc": "Floating-point Minimum Number (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the smaller of the two floating-point values to the destination SIMD&FP register.", "syntax": ["FMINNM  <Hd>, <Hn>, <Hm>\t; Half-precision", "FMINNM  <Sd>, <Sn>, <Sm>\t; Single-precision", "FMINNM  <Dd>, <Dn>, <Dm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SQDECH (vector)", "short_desc": "Signed saturating decrement vector by multiple of 16-bit predicate constraint element count", "full_desc": "Determines the number of active 16-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement all destination vector elements. The results are saturated to the 16-bit signed integer range.", "syntax": ["SQDECH  <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 16;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "LD1RQW (scalar plus scalar)", "short_desc": "Contiguous load and replicate four words (scalar index)", "full_desc": "Load four contiguous words to elements of a short, 128-bit (quadword) vector from the memory address generated by a 64-bit scalar base address and scalar index which is multiplied by 4 and added to the base address.", "syntax": ["LD1RQW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;", "operation": "CheckSVEEnabled();\ninteger elements = 128 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low 16 bits only\nbits(64) offset;\nbits(128) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = X[m];\n\naddr = base + UInt(offset) * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = Replicate(result, VL DIV 128);"}, {"mnemonic": "LSL (immediate, unpredicated)", "short_desc": "Logical shift left by immediate (unpredicated)", "full_desc": "Shift left by immediate each element of the source vector, and place the results in the corresponding elements of the destination vector. The immediate shift amount is an unsigned value in the range 0 to number of bits per element minus 1. This instruction is unpredicated.", "syntax": ["LSL     <Zd>.<T>, <Zn>.<T>, #<const>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<const>\nIs the immediate shift amount, in the range 0 to number of bits per element minus 1, encoded in \"tsz:imm3\"."], "decode": "if !HaveSVE() then UNDEFINED;\nbits(4) tsize = tszh:tszl;\ncase tsize of\n    when '0000' UNDEFINED;\n    when '0001' esize = 8;\n    when '001x' esize = 16;\n    when '01xx' esize = 32;\n    when '1xxx' esize = 64;\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);\ninteger shift = UInt(tsize:imm3) - esize;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    Elem[result, e, esize] = LSL(element1, shift);\n\nZ[d] = result;"}, {"mnemonic": "CTERMEQ, CTERMNE", "short_desc": "Compare and terminate loop", "full_desc": "Detect termination conditions in serialized vector loops. Tests whether the comparison between the scalar source operands holds true and if not tests the state of the  condition flag (C) which indicates whether the previous flag-setting predicate instruction selected the last element of the vector partition.", "syntax": ["CTERMEQ <R><n>, <R><m>\t; Equal", "CTERMNE <R><n>, <R><m>\t; Not equal"], "symbols": ["<R>\n", "<n>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field.", "<m>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32 << UInt(sz);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nSVECmp op = Cmp_EQ;", "operation": "CheckSVEEnabled();\nbits(esize) operand1 = X[n];\nbits(esize) operand2 = X[m];\ninteger element1 = UInt(operand1);\ninteger element2 = UInt(operand2);\nboolean term;\n\ncase op of\n    when Cmp_EQ term = element1 == element2;\n    when Cmp_NE term = element1 != element2;\nif term then\n    PSTATE.N = '1';\n    PSTATE.V = '0';\nelse\n    PSTATE.N = '0';\n    PSTATE.V = (NOT PSTATE.C);"}, {"mnemonic": "STXRB", "short_desc": "Store Exclusive Register Byte", "full_desc": "Store Exclusive Register Byte stores a byte from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See . The memory access is atomic.", "syntax": ["STXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "BR", "short_desc": "Branch to Register", "full_desc": "Branch to Register branches unconditionally to an address in a register, with a hint that this is not a subroutine return.", "syntax": ["BR  <Xn>\t; Integer"], "symbols": ["<Xn>\nIs the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UNDEFINED;\nelsif pac && !HavePACExt() then \n    UNDEFINED;\n\ncase op of\n    when '00' branch_type = BranchType_INDIR;\n    when '01' branch_type = BranchType_INDCALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UNDEFINED;\n\nif pac then\n    if Z == '0' && m != 31 then\n        UNDEFINED;\n\n    if branch_type == BranchType_RET then\n        if n != 31 then UNDEFINED;\n        n = 30;\n        source_is_sp = TRUE;", "operation": "bits(64) target = X[n];\nboolean auth_then_branch = TRUE;\n\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier, auth_then_branch);\n    else\n        target = AuthIB(target, modifier, auth_then_branch);\n\nif branch_type == BranchType_INDCALL then X[30] = PC[] + 4;\n\n// Value in BTypeNext will be used to set PSTATE.BTYPE\ncase branch_type of\n    when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ\n        if InGuardedPage then\n            if n == 16 || n == 17 then\n                BTypeNext = '01';\n            else\n                BTypeNext = '11';\n        else\n            BTypeNext = '01';\n    when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ\n        BTypeNext = '10';\n    when BranchType_RET             // RET, RETAA, RETAB \n        BTypeNext = '00';\n\nBranchTo(target, branch_type);"}, {"mnemonic": "UABD", "short_desc": "Unsigned absolute difference (predicated)", "full_desc": "Compute the absolute difference between unsigned integer values in active elements of the second source vector and corresponding elements of the first source vector and destructively place the difference in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["UABD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    integer element2 = Int(Elem[operand2, e, esize], unsigned);\n    if ElemP[mask, e, esize] == '1' then\n        integer absdiff = Abs(element1 - element2);\n        Elem[result, e, esize] = absdiff<esize-1:0>;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "SXTL, SXTL2", "short_desc": "Signed extend Long", "full_desc": "Signed extend Long. This instruction duplicates each vector element in the lower or upper half of the source SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.", "syntax": ["SXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n"]}, {"mnemonic": "FMOV (vector, immediate)", "short_desc": "Floating-point move immediate (vector)", "full_desc": "Floating-point move immediate (vector). This instruction copies an immediate floating-point constant into every element of the SIMD&FP destination register.", "syntax": ["FMOV  <Vd>.<T>, #<imm>\t; Half-precision", "FMOV  <Vd>.<T>, #<imm>\t; Single-precision", "FMOV  <Vd>.2D, #<imm>\t; Double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<imm>\nIs a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded in \"a:b:c:d:e:f:g:h\". For details of the range of constants available and the encoding of , see ."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\n\nimm8 = a:b:c:d:e:f:g:h;\nimm16 = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,2):imm8<5:0>:Zeros(6);\n\nimm = Replicate(imm16, datasize DIV 16);", "operation": "CheckFPAdvSIMDEnabled64();\n\nV[rd] = imm;"}, {"mnemonic": "BIT", "short_desc": "Bitwise Insert if True", "full_desc": "Bitwise Insert if True. This instruction inserts each bit from the first source SIMD&FP register into the SIMD&FP destination register if the corresponding bit of the second source SIMD&FP register is 1, otherwise leaves the bit in the destination register unchanged.", "syntax": ["BIT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"}, {"mnemonic": "LASTA (SIMD&FP scalar)", "short_desc": "Extract element after last to SIMD&FP scalar register", "full_desc": "If there is an active element then extract the element after the last active element modulo the number of elements from the final source vector register. If there are no active elements, extract element zero. Then place the extracted element in the destination SIMD&FP scalar register.", "syntax": ["LASTA   <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);\nboolean isBefore = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\ninteger last = LastActiveElement(mask, esize);\n\nif isBefore then\n    if last < 0 then last = elements - 1;\nelse\n    last = last + 1;\n    if last >= elements then last = 0;\nV[d] = Elem[operand, last, esize];"}, {"mnemonic": "AUTDB, AUTDZB", "short_desc": "Authenticate Data address, using key B", "full_desc": "Authenticate Data address, using key B. This instruction authenticates a data address, using a modifier and key B.", "syntax": ["AUTDB  <Xd>, <Xn|SP>\t; AUTDB", "AUTDZB  <Xd>\t; AUTDZB"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field."], "decode": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif Z == '0' then // AUTDB\n    if n == 31 then source_is_sp = TRUE;\nelse // AUTDZB\n    if n != 31 then UNDEFINED;", "operation": "auth_then_branch = FALSE;\n\nif HavePACExt() then\n    if source_is_sp then\n        X[d] = AuthDB(X[d], SP[], auth_then_branch);\n    else\n        X[d] = AuthDB(X[d], X[n], auth_then_branch);"}, {"mnemonic": "FRINTP (scalar)", "short_desc": "Floating-point Round to Integral, toward Plus infinity (scalar)", "full_desc": "Floating-point Round to Integral, toward Plus infinity (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTP  <Hd>, <Hn>\t; Half-precision", "FRINTP  <Sd>, <Sn>\t; Single-precision", "FRINTP  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "STUR", "short_desc": "Store Register (unscaled)", "full_desc": "Store Register (unscaled) calculates an address from a base register value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory accesses, see .", "syntax": ["STUR  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "STUR  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "LD2W (scalar plus scalar)", "short_desc": "Contiguous load two-word structures to two vectors (scalar index)", "full_desc": "Contiguous load two-word structures, each to the same element number in two vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by two. The index register is not updated by the instruction.", "syntax": ["LD2W    { <Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "FMAXNMP (vector)", "short_desc": "Floating-point Maximum Number Pairwise (vector)", "full_desc": "Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "ST2D (scalar plus immediate)", "short_desc": "Contiguous store two-doubleword structures from two vectors (immediate index)", "full_desc": "Contiguous store two-doubleword structures, each from the same element number in two vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 2 in the range -16 to 14 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST2D    { <Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "FSQRT (scalar)", "short_desc": "Floating-point Square Root (scalar)", "full_desc": "Floating-point Square Root (scalar). This instruction calculates the square root of the value in the SIMD&FP source register and writes the result to the SIMD&FP destination register.", "syntax": ["FSQRT  <Hd>, <Hn>\t; Half-precision", "FSQRT  <Sd>, <Sn>\t; Single-precision", "FSQRT  <Dd>, <Dn>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"}, {"mnemonic": "FRSQRTE", "short_desc": "Floating-point reciprocal square root estimate (unpredicated)", "full_desc": "Find the approximate reciprocal square root of each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["FRSQRTE <Zd>.<T>, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand = Z[n];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR<31:0>);\n\nZ[d] = result;"}, {"mnemonic": "SADDL, SADDL2", "short_desc": "Signed Add Long (vector)", "full_desc": "Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.  The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.", "syntax": ["SADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH", "short_desc": "Atomic unsigned maximum on halfword in memory", "full_desc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDUMAXAH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXAH", "LDUMAXALH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXALH", "LDUMAXH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXH", "LDUMAXLH  <Ws>, <Wt>, [<Xn|SP>]\t; LDUMAXLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FMUL (by element)", "short_desc": "Floating-point Multiply (by element)", "full_desc": "Floating-point Multiply (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMUL  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision", "FMUL  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nFor the half-precision variant: is the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<Vm>\nFor the single-precision and double-precision variant: is the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<Ts>\n", "<index>\nFor the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields.", "<index>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);\ninteger index = UInt(H:L:M);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if mulx_op then\n        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "LASTB (scalar)", "short_desc": "Extract last element to general-purpose register", "full_desc": "If there is an active element then extract the last active element from the final source vector register. If there are no active elements, extract the highest-numbered element. Then zero-extend and place the extracted element in the destination general-purpose register.", "syntax": ["LASTB   <R><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<R>\n", "<d>\nIs the number [0-30] of the destination general-purpose register or the name ZR (31), encoded in the \"Rd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger rsize = if esize < 64 then 32 else 64;\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Rd);\nboolean isBefore = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(rsize) result;\ninteger last = LastActiveElement(mask, esize);\n\nif isBefore then\n    if last < 0 then last = elements - 1;\nelse\n    last = last + 1;\n    if last >= elements then last = 0;\nresult = ZeroExtend(Elem[operand, last, esize]);\n\nX[d] = result;"}, {"mnemonic": "STEOR, STEORL", "short_desc": "Atomic exclusive OR on word or doubleword in memory, without return", "full_desc": "Atomic exclusive OR on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory.", "syntax": ["STEOR  <Ws>, [<Xn|SP>]\t; 32-bit LDEOR alias", "STEORL  <Ws>, [<Xn|SP>]\t; 32-bit LDEORL alias", "STEOR  <Xs>, [<Xn|SP>]\t; 64-bit LDEOR alias", "STEORL  <Xs>, [<Xn|SP>]\t; 64-bit LDEORL alias"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "ST2 (single structure)", "short_desc": "Store single 2-element structure from one lane of two registers", "full_desc": "Store single 2-element structure from one lane of two registers. This instruction stores a 2-element structure to memory from corresponding elements of two SIMD&FP registers.", "syntax": ["ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]\t; 8-bit", "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]\t; 16-bit", "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]\t; 32-bit", "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]\t; 64-bit", "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2\t; 8-bit, immediate offset", "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>\t; 8-bit, register offset", "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4\t; 16-bit, immediate offset", "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>\t; 16-bit, register offset", "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8\t; 32-bit, immediate offset", "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>\t; 32-bit, register offset", "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16\t; 64-bit, immediate offset", "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>\t; 64-bit, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<index>\nFor the 8-bit variant: is the element index, encoded in \"Q:S:size\".", "<index>\nFor the 16-bit variant: is the element index, encoded in \"Q:S:size<1>\".", "<index>\nFor the 32-bit variant: is the element index, encoded in \"Q:S\".", "<index>\nFor the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UNDEFINED;\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UNDEFINED;\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UNDEFINED;\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UNDEFINED;\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;"}, {"mnemonic": "SRI", "short_desc": "Shift Right and Insert (immediate)", "full_desc": "Shift Right and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the right of each vector element of the source register are lost.", "syntax": ["SRI  <V><d>, <V><n>, #<shift>\t; Scalar", "SRI  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSR(Ones(esize), shift);\nbits(esize) shifted;\n\nfor e = 0 to elements-1\n    shifted = LSR(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nV[d] = result;"}, {"mnemonic": "FCVTMU (vector)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTMU  <Hd>, <Hn>\t; Scalar half precision", "FCVTMU  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTMU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTMU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FACGT", "short_desc": "Floating-point Absolute Compare Greater than (vector)", "full_desc": "Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FACGT  <Hd>, <Hn>, <Hm>\t; Scalar half precision", "FACGT  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision", "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision", "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "EOR (immediate)", "short_desc": "Bitwise exclusive OR with immediate (unpredicated)", "full_desc": "Bitwise exclusive OR an immediate with each 64-bit element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is a 64-bit value consisting of a single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction is unpredicated.", "syntax": ["EOR     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<const>\nIs a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger dn = UInt(Zdn);\nbits(64) imm;\n(imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV 64;\nbits(VL) operand = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(64) element1 = Elem[operand, e, 64];\n    Elem[result, e, 64] = element1 EOR imm;\n\nZ[dn] = result;"}, {"mnemonic": "LDNF1SB", "short_desc": "Contiguous load non-fault signed bytes to vector (immediate index)", "full_desc": "Contiguous load with non-faulting behavior of signed bytes to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNF1SB { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 16-bit element", "LDNF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 32-bit element", "LDNF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; 64-bit element"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger msize = 8;\nboolean unsigned = FALSE;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(VL) orig = Z[t];\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\nboolean fault = FALSE;\nboolean faulted = FALSE;\nboolean unknown = FALSE;\n\nif n == 31 then\n    if ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        // MemNF[] will return fault=TRUE if access is not performed for any reason\n        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];\n    else\n        (data, fault) = (Zeros(msize), FALSE);\n\n    // FFR elements set to FALSE following a supressed access/fault\n    faulted = faulted || fault;\n    if faulted then\n        ElemFFR[e, esize] = '0';\n\n    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE\n    unknown = unknown || ElemFFR[e, esize] == '0';\n    if unknown then\n        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then\n            Elem[result, e, esize] = Extend(data, esize, unsigned);\n        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then\n            Elem[result, e, esize] = Zeros();\n        else  // merge\n            Elem[result, e, esize] = Elem[orig, e, esize];\n    else\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "REV64", "short_desc": "Reverse Bytes", "full_desc": "Reverse Bytes reverses the byte order in a 64-bit general-purpose register.", "syntax": ["REV64  <Xd>, <Xn>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."]}, {"mnemonic": "PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA", "short_desc": "Pointer Authentication Code for Instruction address, using key A", "full_desc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A.", "syntax": ["PACIA  <Xd>, <Xn|SP>\t; PACIA", "PACIZA  <Xd>\t; PACIZA", "PACIA1716\t; PACIA1716", "PACIASP\t; PACIASP", "PACIAZ\t; PACIAZ"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field."], "decode": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif Z == '0' then // PACIA\n    if n == 31 then source_is_sp = TRUE;\nelse // PACIZA\n    if n != 31 then UNDEFINED;", "operation": "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AddPACIA(X[d], SP[]);\n    else\n        X[d] = AddPACIA(X[d], X[n]);"}, {"mnemonic": "FRECPS", "short_desc": "Floating-point Reciprocal Step", "full_desc": "Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FRECPS  <Hd>, <Hn>, <Hm>\t; Scalar half precision", "FRECPS  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision", "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision", "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRecipStepFused(element1, element2);\n\nV[d] = result;"}, {"mnemonic": "MSUB", "short_desc": "Multiply-Subtract", "full_desc": "Multiply-Subtract multiplies two register values, subtracts the product from a third register value, and writes the result to the destination register.", "syntax": ["MSUB  <Wd>, <Wn>, <Wm>, <Wa>\t; 32-bit", "MSUB  <Xd>, <Xn>, <Xm>, <Xa>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wa>\nIs the 32-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xa>\nIs the 64-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = if sf == '1' then 64 else 32;\ninteger datasize = destsize;\nboolean sub_op = (o0 == '1');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));\nelse\n    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));\n\nX[d] = result<destsize-1:0>;"}, {"mnemonic": "BSL", "short_desc": "Bitwise Select", "full_desc": "Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.", "syntax": ["BSL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"}, {"mnemonic": "UMINV", "short_desc": "Unsigned Minimum across Vector", "full_desc": "Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.", "syntax": ["UMINV  <V><d>, <Vn>.<T>\t; Advanced SIMD"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"}, {"mnemonic": "CINV", "short_desc": "Conditional Invert", "full_desc": "Conditional Invert returns, in the destination register, the bitwise inversion of the value of the source register if the condition is TRUE, and otherwise returns the value of the source register.", "syntax": ["CINV  <Wd>, <Wn>, <cond>\t; 32-bit", "CINV  <Xd>, <Xn>, <cond>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "ADDV", "short_desc": "Add across Vector", "full_desc": "Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.", "syntax": ["ADDV  <V><d>, <Vn>.<T>\t; Advanced SIMD"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then UNDEFINED;\nif size == '11' then UNDEFINED;\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = ReduceOp_ADD;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "UQDECW (scalar)", "short_desc": "Unsigned saturating decrement scalar by multiple of 32-bit predicate constraint element count", "full_desc": "Determines the number of active 32-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to decrement the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQDECW  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "UQDECW  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 32;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "FMLA (vectors)", "short_desc": "Floating-point fused multiply-add vectors (predicated), writing addend [Zda = Zda + Zn * Zm]", "full_desc": "Multiply the corresponding active floating-point elements of the first and second source vectors and add to elements of the third source (addend) vector without intermediate rounding. Destructively place the results in the destination and third source (addend) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMLA    <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);\nboolean op1_neg = FALSE;\nboolean op3_neg = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    bits(esize) element3 = Elem[operand3, e, esize];\n\n    if ElemP[mask, e, esize] == '1' then\n        if op1_neg then element1 = FPNeg(element1);\n        if op3_neg then element3 = FPNeg(element3);\n        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element3;\n\nZ[da] = result;"}, {"mnemonic": "SUDOT (by element)", "short_desc": "Dot product with signed and unsigned integers (vector, by element)", "full_desc": "Dot product index form with signed and unsigned integers. This instruction performs the dot product of the four signed 8-bit integer values in each 32-bit element of the first source register with the four unsigned 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination vector.", "syntax": ["SUDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP third source and destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<index>\nIs the immediate index of a quadtuplet of four 8-bit elements in the range 0 to 3, encoded in the \"H:L\" fields."], "decode": "if !HaveInt8MatMulExt() then UNDEFINED;\nboolean op1_unsigned = (US == '1');\nboolean op2_unsigned = (US == '0');\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\ninteger d = UInt(Rd);\ninteger i = UInt(H:L);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 32;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128)      operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    bits(32) res = Elem[operand3, e, 32];\n    for b = 0 to 3\n        integer element1 = Int(Elem[operand1, 4 * e + b, 8], op1_unsigned);\n        integer element2 = Int(Elem[operand2, 4 * i + b, 8], op2_unsigned);\n        res = res + element1 * element2;\n    Elem[result, e, 32] = res;\nV[d] = result;"}, {"mnemonic": "FMINV", "short_desc": "Floating-point minimum recursive reduction to scalar", "full_desc": "Floating-point minimum horizontally over all lanes of a vector using a recursive pairwise reduction, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as +Infinity.", "syntax": ["FMINV   <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(esize) identity = FPInfinity('0');\n\nV[d] = ReducePredicated(ReduceOp_FMIN, operand, mask, identity);"}, {"mnemonic": "MVNI", "short_desc": "Move inverted Immediate (vector)", "full_desc": "Move inverted Immediate (vector). This instruction places the inverse of an immediate constant into every vector element of the destination SIMD&FP register.", "syntax": ["MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 16-bit shifted immediate", "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}\t; 32-bit shifted immediate", "MVNI  <Vd>.<T>, #<imm8>, MSL #<amount>\t; 32-bit shifting ones"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<imm8>\nIs an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\".", "<amount>\n", "<amount>\n", "<amount>\n"], "decode": "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UNDEFINED;\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"}, {"mnemonic": "LDNT1W (scalar plus immediate)", "short_desc": "Contiguous load non-temporal words to vector (immediate index)", "full_desc": "Contiguous load non-temporal of words to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNT1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "UMNEGL", "short_desc": "Unsigned Multiply-Negate Long", "full_desc": "Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register.", "syntax": ["UMNEGL  <Xd>, <Wn>, <Wm>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."]}, {"mnemonic": "ST4H (scalar plus scalar)", "short_desc": "Contiguous store four-halfword structures from four vectors (scalar index)", "full_desc": "Contiguous store four-halfword structures, each from the same element number in four vector registers to the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by four. The index register is not updated by the instruction.", "syntax": ["ST4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;\n    offset = offset + nreg;"}, {"mnemonic": "MOV (immediate, unpredicated)", "short_desc": "Move signed immediate to vector elements (unpredicated)", "full_desc": "Unconditionally broadcast the signed integer immediate into each element of the destination vector. This instruction is unpredicated.", "syntax": ["MOV     <Zd>.<T>, #<imm>{, <shift>}\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<imm>\nIs a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<shift>\n"]}, {"mnemonic": "SDIV", "short_desc": "Signed Divide", "full_desc": "Signed Divide divides a signed integer register value by another signed integer register value, and writes the result to the destination register. The condition flags are not affected.", "syntax": ["SDIV  <Wd>, <Wn>, <Wm>\t; 32-bit", "SDIV  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean unsigned = (o1 == '0');", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\n\nif IsZero(operand2) then\n    result = 0;\nelse\n    result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));\n\nX[d] = result<datasize-1:0>;"}, {"mnemonic": "SBC", "short_desc": "Subtract with Carry", "full_desc": "Subtract with Carry subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register.", "syntax": ["SBC  <Wd>, <Wn>, <Wm>\t; 32-bit", "SBC  <Xd>, <Xn>, <Xm>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"}, {"mnemonic": "FSUBR (immediate)", "short_desc": "Floating-point reversed subtract from immediate (predicated)", "full_desc": "Reversed subtract from an immediate each active floating-point element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate may take the value +0.5 or +1.0 only. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FSUBR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\nbits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPSub(imm, element1, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "ADD (vectors, unpredicated)", "short_desc": "Add vectors (unpredicated)", "full_desc": "Add all elements of the second source vector to corresponding elements of the first source vector and place the results in the corresponding elements of the destination vector. This instruction is unpredicated.", "syntax": ["ADD     <Zd>.<T>, <Zn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = element1 + element2;\n\nZ[d] = result;"}, {"mnemonic": "Shared Pseudocode Functions", "short_desc": "This page displays common pseudocode functions shared by many pages", "syntax": [], "symbols": [], "operation": "// AArch32.VCRMatch()\n// ==================\n\nboolean AArch32.VCRMatch(bits(32) vaddress)\n\n    if UsingAArch32() && ELUsingAArch32(EL1) && IsZero(vaddress<1:0>) && PSTATE.EL != EL2 then\n        // Each bit position in this string corresponds to a bit in DBGVCR and an exception vector.\n        match_word = Zeros(32);\n\n        if vaddress<31:5> == ExcVectorBase()<31:5> then\n            if HaveEL(EL3) && !IsSecure() then\n                match_word<UInt(vaddress<4:2>) + 24> = '1';     // Non-secure vectors\n            else\n                match_word<UInt(vaddress<4:2>) + 0> = '1';      // Secure vectors (or no EL3)\n\n        if HaveEL(EL3) && ELUsingAArch32(EL3) && IsSecure() && vaddress<31:5> == MVBAR<31:5> then\n            match_word<UInt(vaddress<4:2>) + 8> = '1';          // Monitor vectors\n\n        // Mask out bits not corresponding to vectors.\n        if !HaveEL(EL3) then\n            mask = '00000000':'00000000':'00000000':'11011110'; // DBGVCR[31:8] are RES0\n        elsif !ELUsingAArch32(EL3) then\n            mask = '11011110':'00000000':'00000000':'11011110'; // DBGVCR[15:8] are RES0\n        else\n            mask = '11011110':'00000000':'11011100':'11011110';\n\n        match_word = match_word AND DBGVCR AND mask;\n        match = !IsZero(match_word);\n\n        // Check for UNPREDICTABLE case - match on Prefetch Abort and Data Abort vectors\n        if !IsZero(match_word<28:27,12:11,4:3>) && DebugTarget() == PSTATE.EL then\n            match = ConstrainUnpredictableBool(Unpredictable_VCMATCHDAPA);\n    else\n        match = FALSE;\n\n    return match;"}, {"mnemonic": "INS (element)", "short_desc": "Insert vector element from another vector element", "full_desc": "Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.", "syntax": ["INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ts>\n", "<index1>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<index2>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UNDEFINED;\n\ninteger dst_index = UInt(imm5<4:size+1>);\ninteger src_index = UInt(imm4<3:size>);\ninteger idxdsize = if imm4<3> == '1' then 128 else 64; \n// imm4<size-1:0> is IGNORED \n\ninteger esize = 8 << size;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(128) result;\n\nresult = V[d];\nElem[result, dst_index, esize] = Elem[operand, src_index, esize];\nV[d] = result;"}, {"mnemonic": "STSMINB, STSMINLB", "short_desc": "Atomic signed minimum on byte in memory, without return", "full_desc": "Atomic signed minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.", "syntax": ["STSMINB  <Ws>, [<Xn|SP>]\t; No memory ordering", "STSMINLB  <Ws>, [<Xn|SP>]\t; Release"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."]}, {"mnemonic": "LDTRH", "short_desc": "Load Register Halfword (unprivileged)", "full_desc": "Load Register Halfword (unprivileged) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.", "syntax": ["LDTRH  <Wt>, [<Xn|SP>{, #<simm>}]\t; Unscaled offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\n\nunpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');\nunpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';\n\nuser_access_override = HaveUAOExt() && PSTATE.UAO == '1';\nif !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then\n    acctype = AccType_UNPRIV;\nelse\n    acctype = AccType_NORMAL;\n\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "ST3H (scalar plus immediate)", "short_desc": "Contiguous store three-halfword structures from three vectors (immediate index)", "full_desc": "Contiguous store three-halfword structures, each from the same element number in three vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 3 in the range -24 to 21 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "LDUR (SIMD&FP)", "short_desc": "Load SIMD&FP Register (unscaled offset)", "full_desc": "Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.", "syntax": ["LDUR  <Bt>, [<Xn|SP>{, #<simm>}]\t; 8-bit", "LDUR  <Ht>, [<Xn|SP>{, #<simm>}]\t; 16-bit", "LDUR  <St>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDUR  <Dt>, [<Xn|SP>{, #<simm>}]\t; 64-bit", "LDUR  <Qt>, [<Xn|SP>{, #<simm>}]\t; 128-bit"], "symbols": ["<Bt>\nIs the 8-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Ht>\nIs the 16-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt>\nIs the 128-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UNDEFINED;\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "SCVTF (vector, fixed-point)", "short_desc": "Signed fixed-point Convert to Floating-point (vector)", "full_desc": "Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the , and writes the result to the SIMD&FP destination register.", "syntax": ["SCVTF  <V><d>, <V><n>, #<fbits>\t; Scalar", "SCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<fbits>\n", "<fbits>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FMAX (scalar)", "short_desc": "Floating-point Maximum (scalar)", "full_desc": "Floating-point Maximum (scalar). This instruction compares the two source SIMD&FP registers, and writes the larger of the two floating-point values to the destination SIMD&FP register.", "syntax": ["FMAX  <Hd>, <Hn>, <Hm>\t; Half-precision", "FMAX  <Sd>, <Sn>, <Sm>\t; Single-precision", "FMAX  <Dd>, <Dn>, <Dm>\t; Double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "UMINV", "short_desc": "Unsigned minimum reduction to scalar", "full_desc": "Unsigned minimum horizontally across all lanes of a vector, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as the maximum unsigned integer for the element size.", "syntax": ["UMINV   <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\ninteger minimum = if unsigned then (2^esize - 1) else (2^(esize-1) - 1);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer element = Int(Elem[operand, e, esize], unsigned);\n        minimum = Min(minimum, element);\n\nV[d] = minimum<esize-1:0>;"}, {"mnemonic": "SHA512SU0", "short_desc": "SHA512 Schedule Update 0", "full_desc": "SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the gamma0 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register.", "syntax": ["SHA512SU0  <Vd>.2D, <Vn>.2D\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP source and destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the second SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveSHA512Ext() then UNDEFINED;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(64) sig0;\nbits(128) Vtmp;\nbits(128) X = V[n];\nbits(128) W = V[d]; \nsig0 = ROR(W<127:64>, 1) EOR ROR(W<127:64>, 8) EOR ('0000000':W<127:71>);\nVtmp<63:0> = W<63:0> + sig0;\nsig0 = ROR(X<63:0>, 1) EOR ROR(X<63:0>, 8) EOR ('0000000':X<63:7>);\nVtmp<127:64> = W<127:64> + sig0;\nV[d] = Vtmp;"}, {"mnemonic": "DCPS1", "short_desc": "Debug Change PE State to EL1.", "full_desc": "Debug Change PE State to EL1, when executed in Debug state:", "syntax": ["DCPS1  {#<imm>}\t; System"], "symbols": ["<imm>\nIs an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the \"imm16\" field."], "decode": "bits(2) target_level = LL;\nif LL == '00' then UNDEFINED;\nif !Halted() then UNDEFINED;", "operation": "DCPSInstruction(target_level);"}, {"mnemonic": "LDAXRB", "short_desc": "Load-Acquire Exclusive Register Byte", "full_desc": "Load-Acquire Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See . The instruction also has memory ordering semantics as described in . For information about memory accesses see .", "syntax": ["LDAXRB  <Wt>, [<Xn|SP>{,#0}]\t; No offset"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UNDEFINED;\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FRINTX (vector)", "short_desc": "Floating-point Round to Integral exact, using current rounding mode (vector)", "full_desc": "Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the , and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTX  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FRINTX  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "UMAXV", "short_desc": "Unsigned Maximum across Vector", "full_desc": "Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.", "syntax": ["UMAXV  <V><d>, <Vn>.<T>\t; Advanced SIMD"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"}, {"mnemonic": "EORV", "short_desc": "Bitwise exclusive OR reduction to scalar", "full_desc": "Bitwise exclusive OR horizontally across all lanes of a vector, and place the result in the SIMD&FP scalar destination register. Inactive elements in the source vector are treated as zero.", "syntax": ["EORV    <V><d>, <Pg>, <Zn>.<T>\t; SVE"], "symbols": ["<V>\n", "<d>\nIs the number [0-31] of the destination SIMD&FP register, encoded in the \"Vd\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Vd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand = Z[n];\nbits(esize) result = Zeros(esize);\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        result = result EOR Elem[operand, e, esize];\n\nV[d] = result;"}, {"mnemonic": "FDIVR", "short_desc": "Floating-point reversed divide by vector (predicated)", "full_desc": "Reversed divide active floating-point elements of the second source vector by corresponding floating-point elements of the first source vector and destructively place the quotient in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPDiv(element2, element1, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "DCPS3", "short_desc": "Debug Change PE State to EL3", "full_desc": "Debug Change PE State to EL3, when executed in Debug state:", "syntax": ["DCPS3  {#<imm>}\t; System"], "symbols": ["<imm>\nIs an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the \"imm16\" field."], "decode": "bits(2) target_level = LL;\nif LL == '00' then UNDEFINED;\nif !Halted() then UNDEFINED;", "operation": "DCPSInstruction(target_level);"}, {"mnemonic": "FCVTZU (vector, integer)", "short_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector)", "full_desc": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTZU  <Hd>, <Hn>\t; Scalar half precision", "FCVTZU  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTZU  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTZU  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "PNEXT", "short_desc": "Find next active predicate", "full_desc": "An instruction used to construct a loop which iterates over all active elements in a predicate. If all source predicate elements are false it sets the first active predicate element in the destination predicate to true. Otherwise it determines the next active predicate element following the last true source predicate element, and if one is found sets the corresponding destination predicate element to true. All other destination predicate elements are set to false. Sets the  (N),  (Z),  (C) condition flags based on the predicate result, and the V flag to zero.", "syntax": ["PNEXT   <Pdn>.<T>, <Pg>, <Pdn>.<T>\t; SVE"], "symbols": ["<Pdn>\nIs the name of the source and destination scalable predicate register, encoded in the \"Pdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register, encoded in the \"Pg\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Pdn);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(PL) operand = P[dn];\nbits(PL) result;\n\ninteger next = LastActiveElement(operand, esize) + 1;\n\nwhile next < elements && (ElemP[mask, next, esize] == '0') do\n    next = next + 1;\n\nresult = Zeros();\nif next < elements then\n    ElemP[result, next, esize] = '1';\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[dn] = result;"}, {"mnemonic": "LDNT1D (scalar plus immediate)", "short_desc": "Contiguous load non-temporal doublewords to vector (immediate index)", "full_desc": "Contiguous load non-temporal of doublewords to elements of a vector register from the memory address generated by a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address. Inactive elements will not read Device memory or signal a fault, and are set to zero in the destination vector.", "syntax": ["LDNT1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger offset = SInt(imm4);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(VL) result;\nconstant integer mbytes = esize DIV 8;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = result;"}, {"mnemonic": "FCCMP", "short_desc": "Floating-point Conditional quiet Compare (scalar)", "full_desc": "Floating-point Conditional quiet Compare (scalar). This instruction compares the two SIMD&FP source register values and writes the result to the .{N, Z, C, V} flags. If the condition does not pass then the .{N, Z, C, V} flags are set to the flag bit specifier.", "syntax": ["FCCMP  <Hn>, <Hm>, #<nzcv>, <cond>\t; Half-precision", "FCCMP  <Sn>, <Sm>, #<nzcv>, <cond>\t; Single-precision", "FCCMP  <Dn>, <Dm>, #<nzcv>, <cond>\t; Double-precision"], "symbols": ["<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean signal_all_nans = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = V[m];\n\nif ConditionHolds(condition) then\n    flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "MOV (scalar, predicated)", "short_desc": "Move general-purpose register to vector elements (predicated)", "full_desc": "Move the general-purpose scalar source register to each active element in the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["MOV     <Zd>.<T>, <Pg>/M, <R><n|SP>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<R>\n", "<n|SP>\nIs the number [0-30] of the general-purpose source register or the name SP (31), encoded in the \"Rn\" field."]}, {"mnemonic": "SQSHL (register)", "short_desc": "Signed saturating Shift Left (register)", "full_desc": "Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SQSHL  <V><d>, <V><n>, <V><m>\t; Scalar", "SQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "MSB", "short_desc": "Multiply-subtract vectors (predicated), writing multiplicand [Zdn = Za - Zdn * Zm]", "full_desc": "Multiply the corresponding active elements of the first and second source vectors and subtract from elements of the third (addend) vector. Destructively place the results in the destination and first source (multiplicand) vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["MSB     <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Za>\nIs the name of the third source scalable vector register, encoded in the \"Za\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\ninteger a = UInt(Za);\nboolean sub_op = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[a];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = UInt(Elem[operand1, e, esize]);\n    integer element2 = UInt(Elem[operand2, e, esize]);\n    if ElemP[mask, e, esize] == '1' then\n        integer product = element1 * element2;\n        if sub_op then\n            Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n        else\n            Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "AND (immediate)", "short_desc": "Bitwise AND (immediate)", "full_desc": "Bitwise AND (immediate) performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register.", "syntax": ["AND  <Wd|WSP>, <Wn>, #<imm>\t; 32-bit", "AND  <Xd|SP>, <Xn>, #<imm>\t; 64-bit"], "symbols": ["<Wd|WSP>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\".", "<imm>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then UNDEFINED;\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);", "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"}, {"mnemonic": "CLASTB (scalar)", "short_desc": "Conditionally extract last element to general-purpose register", "full_desc": "From the source vector register extract the last active element, and then zero-extend that element to destructively place in the destination and first source general-purpose register. If there are no active elements then destructively zero-extend the least significant element-size bits of the destination and first source general-purpose register.", "syntax": ["CLASTB  <R><dn>, <Pg>, <R><dn>, <Zm>.<T>\t; SVE"], "symbols": ["<R>\n", "<dn>\nIs the number [0-30] of the source and destination general-purpose register or the name ZR (31), encoded in the \"Rdn\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the source scalable vector register, encoded in the \"Zm\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Rdn);\ninteger m = UInt(Zm);\ninteger csize = if esize < 64 then 32 else 64;\nboolean isBefore = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(esize) operand1 = X[dn];\nbits(VL) operand2 = Z[m];\nbits(csize) result;\ninteger last = LastActiveElement(mask, esize);\n\nif last < 0 then\n    result = ZeroExtend(operand1);\nelse\n    if !isBefore then\n        last = last + 1;\n        if last >= elements then last = 0;\n    result = ZeroExtend(Elem[operand2, last, esize]);\n\nX[dn] = result;"}, {"mnemonic": "LSL (immediate)", "short_desc": "Logical Shift Left (immediate)", "full_desc": "Logical Shift Left (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSL  <Wd>, <Wn>, #<shift>\t; 32-bit", "LSL  <Xd>, <Xn>, #<shift>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<shift>\nFor the 32-bit variant: is the shift amount, in the range 0 to 31.", "<shift>\nFor the 64-bit variant: is the shift amount, in the range 0 to 63."]}, {"mnemonic": "FCADD", "short_desc": "Floating-point complex add with rotate (predicated)", "full_desc": "Add the real and imaginary components of the active floating-point complex numbers from the first source vector to the complex numbers from the second source vector which have first been rotated by 90 or 270 degrees in the direction from the positive real axis towards the positive imaginary axis, when considered in polar representation, equivalent to multiplying the complex numbers in the second source vector by \u00b1 beforehand. Destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FCADD   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>, <const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);\nboolean sub_i = (rot == '0');\nboolean sub_r = (rot == '1');", "operation": "CheckSVEEnabled();\ninteger pairs = VL DIV (2 * esize);\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor p = 0 to pairs-1\n    acc_r  = Elem[operand1, 2 * p + 0, esize];\n    acc_i  = Elem[operand1, 2 * p + 1, esize];\n    elt2_r = Elem[operand2, 2 * p + 0, esize];\n    elt2_i = Elem[operand2, 2 * p + 1, esize];\n    if ElemP[mask, 2 * p + 0, esize] == '1' then\n        if sub_i then elt2_i = FPNeg(elt2_i);\n        acc_r = FPAdd(acc_r, elt2_i, FPCR<31:0>);\n    if ElemP[mask, 2 * p + 1, esize] == '1' then\n        if sub_r then elt2_r = FPNeg(elt2_r);\n        acc_i = FPAdd(acc_i, elt2_r, FPCR<31:0>);\n    Elem[result, 2 * p + 0, esize] = acc_r;\n    Elem[result, 2 * p + 1, esize] = acc_i;\n\nZ[dn] = result;"}, {"mnemonic": "WHILELO", "short_desc": "While incrementing unsigned scalar lower than scalar", "full_desc": "Generate a predicate that starting from the lowest numbered element is true while the incrementing value of the first, unsigned scalar operand is lower than the second scalar operand and false thereafter up to the highest numbered element.", "syntax": ["WHILELO <Pd>.<T>, <R><n>, <R><m>\t; SVE"], "symbols": ["<Pd>\nIs the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T>\n", "<R>\n", "<n>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field.", "<m>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger rsize = 32 << UInt(sf);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Pd);\nboolean unsigned = TRUE;\nSVECmp op = Cmp_LT;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = Ones(PL);\nbits(rsize) operand1 = X[n];\nbits(rsize) operand2 = X[m];\nbits(PL) result;\nboolean last = TRUE;\n\nfor e = 0 to elements-1\n    boolean cond;\n    case op of\n        when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));\n        when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));\n\n    last = last && cond;\n    ElemP[result, e, esize] = if last then '1' else '0';\n    operand1 = operand1 + 1;\n\nPSTATE.<N,Z,C,V> = PredTest(mask, result, esize);\nP[d] = result;"}, {"mnemonic": "FCVTN, FCVTN2", "short_desc": "Floating-point Convert to lower precision Narrow (vector)", "full_desc": "Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the SIMD&FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the .", "syntax": ["FCVTN{2}  <Vd>.<Tb>, <Vn>.<Ta>\t; Vector single-precision and double-precision"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Tb>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Ta>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16 << UInt(sz);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);\n\nVpart[d, part] = result;"}, {"mnemonic": "LDRAA, LDRAB", "short_desc": "Load Register, with pointer authentication", "full_desc": "Load Register, with pointer authentication. This instruction authenticates an address from a base register using a modifier of zero and the specified key, adds an immediate offset to the authenticated address, and loads a 64-bit doubleword from memory at this resulting address into a register.", "syntax": ["LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]\t; Key A, offset", "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]!\t; Key A, pre-indexed", "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]\t; Key B, offset", "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]!\t; Key B, pre-indexed"], "symbols": ["<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, a multiple of 8 in the range -4096 to 4088, defaulting to 0 and encoded in the \"S:imm9\" field as <simm>/8."], "decode": "if !HavePACExt() || size != '11' then UNDEFINED;\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\nboolean wback = (W == '1');\nboolean use_key_a = (M == '0');\nbits(10) S10 = S:imm9;\ninteger scale = 3;\nbits(64) offset = LSL(SignExtend(S10, 64), scale);\nboolean tag_checked = wback || n != 31;", "operation": "bits(64) address;\nbits(64) data;\nboolean wb_unknown = FALSE;\nboolean auth_then_branch = TRUE;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UNDEFINED;\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    address = SP[];\nelse\n    address = X[n];\n\nif use_key_a then\n    address = AuthDA(address, X[31], auth_then_branch);\nelse\n    address = AuthDB(address, X[31], auth_then_branch);\n\nif n == 31 then\n    CheckSPAlignment();\n\naddress = address + offset;\ndata = Mem[address, 8, AccType_NORMAL];\nX[t] = data;\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"}, {"mnemonic": "LSR (immediate, predicated)", "short_desc": "Logical shift right by immediate (predicated)", "full_desc": "Shift right by immediate, inserting zeroes, each active element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate shift amount is an unsigned value in the range 1 to number of bits per element. Inactive elements in the destination vector register remain unmodified.", "syntax": ["LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\nIs the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\"."], "decode": "if !HaveSVE() then UNDEFINED;\nbits(4) tsize = tszh:tszl;\ncase tsize of\n    when '0000' UNDEFINED;\n    when '0001' esize = 8;\n    when '001x' esize = 16;\n    when '01xx' esize = 32;\n    when '1xxx' esize = 64;\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger shift = (2 * esize) - UInt(tsize:imm3);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(PL) mask = P[g];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = LSR(element1, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "AUTDA, AUTDZA", "short_desc": "Authenticate Data address, using key A", "full_desc": "Authenticate Data address, using key A. This instruction authenticates a data address, using a modifier and key A.", "syntax": ["AUTDA  <Xd>, <Xn|SP>\t; AUTDA", "AUTDZA  <Xd>\t; AUTDZA"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field."], "decode": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif Z == '0' then // AUTDA\n    if n == 31 then source_is_sp = TRUE;\nelse // AUTDZA\n    if n != 31 then UNDEFINED;", "operation": "auth_then_branch = FALSE;\n\nif HavePACExt() then\n    if source_is_sp then\n        X[d] = AuthDA(X[d], SP[], auth_then_branch);\n    else\n        X[d] = AuthDA(X[d], X[n], auth_then_branch);"}, {"mnemonic": "SHA1C", "short_desc": "SHA1 hash update (choose)", "full_desc": "SHA1 hash update (choose).", "syntax": ["SHA1C  <Qd>, <Sn>, <Vm>.4S\t; Advanced SIMD"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP source and destination, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the third SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif !HaveSHA1Ext() then UNDEFINED;", "operation": "AArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;"}, {"mnemonic": "FMULX (by element)", "short_desc": "Floating-point Multiply extended (by element)", "full_desc": "Floating-point Multiply extended (by element). This instruction multiplies the floating-point values in the vector elements in the first source SIMD&FP register by the specified floating-point value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FMULX  <Hd>, <Hn>, <Vm>.H[<index>]\t; Scalar, half-precision", "FMULX  <V><d>, <V><n>, <Vm>.<Ts>[<index>]\t; Scalar, single-precision and double-precision", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]\t; Vector, half-precision", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]\t; Vector, single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nFor the half-precision variant: is the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<Vm>\nFor the single-precision and double-precision variant: is the name of the second SIMD&FP source register, encoded in the \"M:Rm\" fields.", "<Ts>\n", "<index>\nFor the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields.", "<index>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger d = UInt(Rd);\ninteger index = UInt(H:L:M);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if mulx_op then\n        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "LSLR", "short_desc": "Reversed logical shift left by vector (predicated)", "full_desc": "Reversed shift left active elements of the second source vector by corresponding elements of the first source vector and destructively place the results in the corresponding elements of the first source vector. The shift amount operand is a vector of unsigned elements in which all bits are significant, and not used modulo the element size. Inactive elements in the destination vector register remain unmodified.", "syntax": ["LSLR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    integer shift = Min(UInt(element1), esize);\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = LSL(element2, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "INCD, INCH, INCW (vector)", "short_desc": "Increment vector by multiple of predicate constraint element count", "full_desc": "Determines the number of active elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment all destination vector elements.", "syntax": ["INCD    <Zdn>.D{, <pattern>{, MUL #<imm>}}\t; Doubleword", "INCH    <Zdn>.H{, <pattern>{, MUL #<imm>}}\t; Halfword", "INCW    <Zdn>.S{, <pattern>{, MUL #<imm>}}\t; Word"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Zdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\ninteger count = DecodePredCount(pat, esize);\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[operand1, e, esize] + (count * imm);\n\nZ[dn] = result;"}, {"mnemonic": "LDAPURSH", "short_desc": "Load-Acquire RCpc Register Signed Halfword (unscaled)", "full_desc": "Load-Acquire RCpc Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register.", "syntax": ["LDAPURSH  <Wt>, [<Xn|SP>{, #<simm>}]\t; 32-bit", "LDAPURSH  <Xt>, [<Xn|SP>{, #<simm>}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>\nIs the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."], "decode": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_ORDERED;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UNDEFINED;\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UNDEFINED;\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;\nboolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);"}, {"mnemonic": "SSRA", "short_desc": "Signed Shift Right and Accumulate (immediate)", "full_desc": "Signed Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see .", "syntax": ["SSRA  <V><d>, <V><n>, #<shift>\t; Scalar", "SSRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "DECP (vector)", "short_desc": "Decrement vector by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to decrement all destination vector elements.", "syntax": ["DECP    <Zdn>.<T>, <Pm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Zdn);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(PL) operand2 = P[m];\nbits(VL) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[operand1, e, esize] - count;\n\nZ[dn] = result;"}, {"mnemonic": "FMLA (vector)", "short_desc": "Floating-point fused Multiply-Add to accumulator (vector)", "full_desc": "Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.", "syntax": ["FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Half-precision", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (a == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SWPH, SWPAH, SWPALH, SWPLH", "short_desc": "Swap halfword in memory", "full_desc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.", "syntax": ["SWPAH  <Ws>, <Wt>, [<Xn|SP>]\t; SWPAH", "SWPALH  <Ws>, <Wt>, [<Xn|SP>]\t; SWPALH", "SWPH  <Ws>, <Wt>, [<Xn|SP>]\t; SWPH", "SWPLH  <Ws>, <Wt>, [<Xn|SP>]\t; SWPLH"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nbits(datasize) store_value;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nstore_value = X[s];\ndata = MemAtomic(address, MemAtomicOp_SWP, store_value, ldacctype, stacctype);\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "FRINTN (vector)", "short_desc": "Floating-point Round to Integral, to nearest with ties to even (vector)", "full_desc": "Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.", "syntax": ["FRINTN  <Vd>.<T>, <Vn>.<T>\t; Half-precision", "FRINTN  <Vd>.<T>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UNDEFINED;\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"}, {"mnemonic": "LD4H (scalar plus immediate)", "short_desc": "Contiguous load four-halfword structures to four vectors (immediate index)", "full_desc": "Contiguous load four-halfword structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 4 in the range -32 to 28 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["LD4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt4>\nIs the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger offset = SInt(imm4);\ninteger nreg = 4;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..3] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "UQINCD (scalar)", "short_desc": "Unsigned saturating increment scalar by multiple of 64-bit predicate constraint element count", "full_desc": "Determines the number of active 64-bit elements implied by the named predicate constraint, multiplies that by an immediate in the range 1 to 16 inclusive, and then uses the result to increment the scalar destination. The result is saturated to the general-purpose register's unsigned integer range.", "syntax": ["UQINCD  <Wdn>{, <pattern>{, MUL #<imm>}}\t; 32-bit", "UQINCD  <Xdn>{, <pattern>{, MUL #<imm>}}\t; 64-bit"], "symbols": ["<Wdn>\nIs the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>\nIs the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern>\n", "<imm>\nIs the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 64;\ninteger dn = UInt(Rdn);\nbits(5) pat = pattern;\ninteger imm = UInt(imm4) + 1;\nboolean unsigned = TRUE;\ninteger ssize = 32;", "operation": "CheckSVEEnabled();\ninteger count = DecodePredCount(pat, esize);\nbits(ssize) operand1 = X[dn];\nbits(ssize) result;\n\ninteger element1 = Int(operand1, unsigned);\n(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);\nX[dn] = Extend(result, 64, unsigned);"}, {"mnemonic": "LDP (SIMD&FP)", "short_desc": "Load Pair of SIMD&FP registers", "full_desc": "Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP registers from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.", "syntax": ["LDP  <St1>, <St2>, [<Xn|SP>], #<imm>\t; 32-bit", "LDP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>\t; 64-bit", "LDP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>\t; 128-bit", "LDP  <St1>, <St2>, [<Xn|SP>, #<imm>]!\t; 32-bit", "LDP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!\t; 64-bit", "LDP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!\t; 128-bit", "LDP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]\t; 32-bit", "LDP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\t; 64-bit", "LDP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]\t; 128-bit"], "symbols": ["<Dt1>\nIs the 64-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Dt2>\nIs the 64-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Qt1>\nIs the 128-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<Qt2>\nIs the 128-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<St1>\nIs the 32-bit name of the first SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<St2>\nIs the 32-bit name of the second SIMD&FP register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nFor the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as <imm>/4.", "<imm>\nFor the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the \"imm7\" field as <imm>/8.", "<imm>\nFor the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as <imm>/8.", "<imm>\nFor the 128-bit post-index and 128-bit pre-index variant: is the signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, encoded in the \"imm7\" field as <imm>/16.", "<imm>\nFor the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as <imm>/16."], "decode": "boolean wback  = TRUE;\nboolean postindex = TRUE;", "operation": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VEC;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UNDEFINED;\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\nboolean tag_checked = wback || n != 31;"}, {"mnemonic": "CLREX", "short_desc": "Clear Exclusive", "full_desc": "Clear Exclusive clears the local monitor of the executing PE.", "syntax": ["CLREX  {#<imm>}\t; System"], "symbols": ["<imm>\nIs an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the \"CRm\" field."], "decode": "// CRm field is ignored", "operation": "ClearExclusiveLocal(ProcessorID());"}, {"mnemonic": "FABS", "short_desc": "Floating-point absolute value (predicated)", "full_desc": "Take the absolute value of each active floating-point element of the source vector, and place the results in the corresponding elements of the destination vector. This clears the sign bit and cannot signal a floating-point exception. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FABS    <Zd>.<T>, <Pg>/M, <Zn>.<T>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>\nIs the name of the source scalable vector register, encoded in the \"Zn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Zn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand  = Z[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    bits(esize) element = Elem[operand, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPAbs(element);\n\nZ[d] = result;"}, {"mnemonic": "UMULL, UMULL2 (vector)", "short_desc": "Unsigned Multiply long (vector)", "full_desc": "Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.", "syntax": ["UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>\t; Three registers, not all the same type"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB", "short_desc": "Pointer Authentication Code for Instruction address, using key B", "full_desc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B.", "syntax": ["PACIB  <Xd>, <Xn|SP>\t; PACIB", "PACIZB  <Xd>\t; PACIZB", "PACIB1716\t; PACIB1716", "PACIBSP\t; PACIBSP", "PACIBZ\t; PACIBZ"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field."], "decode": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UNDEFINED;\n\nif Z == '0' then // PACIB\n    if n == 31 then source_is_sp = TRUE;\nelse // PACIZB\n    if n != 31 then UNDEFINED;", "operation": "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AddPACIB(X[d], SP[]);\n    else\n        X[d] = AddPACIB(X[d], X[n]);"}, {"mnemonic": "LD3H (scalar plus scalar)", "short_desc": "Contiguous load three-halfword structures to three vectors (scalar index)", "full_desc": "Contiguous load three-halfword structures, each to the same element number in three vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by three. The index register is not updated by the instruction.", "syntax": ["LD3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Zt3>\nIs the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;\ninteger nreg = 3;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..2] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "SMLSL, SMLSL2 (by element)", "short_desc": "Signed Multiply-Subtract Long (vector, by element)", "full_desc": "Signed Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"}, {"mnemonic": "CLASTA (SIMD&FP scalar)", "short_desc": "Conditionally extract element after last to SIMD&FP scalar register", "full_desc": "From the source vector register extract the element after the last active element, or if the last active element is the final element extract element zero, and then zero-extend that element to destructively place in the destination and first source SIMD & floating-point scalar register. If there are no active elements then destructively zero-extend the least significant element-size bits of the destination and first source SIMD & floating-point scalar register.", "syntax": ["CLASTA  <V><dn>, <Pg>, <V><dn>, <Zm>.<T>\t; SVE"], "symbols": ["<V>\n", "<dn>\nIs the number [0-31] of the source and destination SIMD&FP register, encoded in the \"Vdn\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the source scalable vector register, encoded in the \"Zm\" field.", "<T>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Vdn);\ninteger m = UInt(Zm);\nboolean isBefore = FALSE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(esize) operand1 = V[dn];\nbits(VL) operand2 = Z[m];\nbits(esize) result;\ninteger last = LastActiveElement(mask, esize);\n\nif last < 0 then\n    result = ZeroExtend(operand1);\nelse\n    if !isBefore then\n        last = last + 1;\n        if last >= elements then last = 0;\n    result = Elem[operand2, last, esize];\n\nV[dn] = result;"}, {"mnemonic": "LD1SH (scalar plus vector)", "short_desc": "Gather load signed halfwords to vector (vector index)", "full_desc": "Gather load of signed halfwords to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 2. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\ninteger offs_size = 32;\nboolean unsigned = FALSE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 1;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset = Z[m];\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "LDAPRH", "short_desc": "Load-Acquire RCpc Register Halfword", "full_desc": "Load-Acquire RCpc Register Halfword derives an address from a base register value, loads a halfword from the derived address in memory, zero-extends it and writes it to a register.", "syntax": ["LDAPRH  <Wt>, [<Xn|SP> {,#0}]\t; Integer"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = AccType_ORDERED;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = Mem[address, dbytes, acctype];\nX[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "REV32", "short_desc": "Reverse bytes in 32-bit words", "full_desc": "Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a register.", "syntax": ["REV32  <Xd>, <Xn>\t; 64-bit"], "symbols": ["<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;\n\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UNDEFINED;\n        container_size = 64;", "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n\nX[d] = result;"}, {"mnemonic": "MOV (bitmask immediate)", "short_desc": "Move (bitmask immediate)", "full_desc": "Move (bitmask immediate) writes a bitmask immediate value to a register.", "syntax": ["MOV  <Wd|WSP>, #<imm>\t; 32-bit", "MOV  <Xd|SP>, #<imm>\t; 64-bit"], "symbols": ["<Wd|WSP>\nIs the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xd|SP>\nIs the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<imm>\nFor the 32-bit variant: is the bitmask immediate, encoded in \"imms:immr\", but excluding values which could be encoded by MOVZ or MOVN.", "<imm>\nFor the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\", but excluding values which could be encoded by MOVZ or MOVN."]}, {"mnemonic": "SMINP", "short_desc": "Signed Minimum Pairwise", "full_desc": "Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "FCMPE", "short_desc": "Floating-point signaling Compare (scalar)", "full_desc": "Floating-point signaling Compare (scalar). This instruction compares the two SIMD&FP source register values, or the first SIMD&FP source register value and zero. It writes the result to the .{N, Z, C, V} flags.", "syntax": ["FCMPE  <Hn>, <Hm>\t; Half-precision", "FCMPE  <Hn>, #0.0\t; Half-precision, zero", "FCMPE  <Sn>, <Sm>\t; Single-precision", "FCMPE  <Sn>, #0.0\t; Single-precision, zero", "FCMPE  <Dn>, <Dm>\t; Double-precision", "FCMPE  <Dn>, #0.0\t; Double-precision, zero"], "symbols": ["<Dn>\nFor the double-precision variant: is the 64-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nFor the double-precision, zero variant: is the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Hn>\nFor the half-precision variant: is the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nFor the half-precision, zero variant: is the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Sn>\nFor the single-precision variant: is the 32-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Sn>\nFor the single-precision, zero variant: is the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);   // ignored when opc<0> == '1'\n\ninteger datasize;\ncase ftype of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UNDEFINED;\n\nboolean signal_all_nans = (opc<1> == '1');\nboolean cmp_with_zero = (opc<0> == '1');", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = if cmp_with_zero then FPZero('0') else V[m];\n\nPSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);"}, {"mnemonic": "SMIN", "short_desc": "Signed Minimum (vector)", "full_desc": "Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "ADD (vector)", "short_desc": "Add (vector)", "full_desc": "Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["ADD  <V><d>, <V><n>, <V><m>\t; Scalar", "ADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;"}, {"mnemonic": "CCMN (register)", "short_desc": "Conditional Compare Negative (register)", "full_desc": "Conditional Compare Negative (register) sets the value of the condition flags to the result of the comparison of a register value and the inverse of another register value if the condition is TRUE, and an immediate value otherwise.", "syntax": ["CCMN  <Wn>, <Wm>, #<nzcv>, <cond>\t; 32-bit", "CCMN  <Xn>, <Xm>, #<nzcv>, <cond>\t; 64-bit"], "symbols": ["<Wn>\nIs the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>\nIs the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>\nIs the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<nzcv>\nIs the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>\nIs one of the standard conditions, encoded in the \"cond\" field in the standard way."], "decode": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;", "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"}, {"mnemonic": "FCMGE (register)", "short_desc": "Floating-point Compare Greater than or Equal (vector)", "full_desc": "Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.", "syntax": ["FCMGE  <Hd>, <Hn>, <Hm>\t; Scalar half precision", "FCMGE  <V><d>, <V><n>, <V><m>\t; Scalar single-precision and double-precision", "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector half precision", "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Hm>\nIs the 16-bit name of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"}, {"mnemonic": "FSUB (immediate)", "short_desc": "Floating-point subtract immediate (predicated)", "full_desc": "Subtract an immediate from each active floating-point element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate may take the value +0.5 or +1.0 only. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FSUB    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\n"], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\nbits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPSub(element1, imm, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "LD1ROH (scalar plus scalar)", "short_desc": "Contiguous load and replicate sixteen halfwords (scalar index)", "full_desc": "Load sixteen contiguous halfwords to elements of a 256-bit (octaword) vector from the memory address generated by a 64-bit scalar base address and scalar index which is multiplied by 2 and added to the base address.", "syntax": ["LD1ROH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVEFP64MatMulExt() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;", "operation": "CheckSVEEnabled();\nif VL < 256 then UNDEFINED;\ninteger elements = 256 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low bits only\nbits(64) offset;\nbits(256) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\noffset = X[m];\n\naddr = base + UInt(offset) * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);"}, {"mnemonic": "UCVTF (scalar, fixed-point)", "short_desc": "Unsigned fixed-point Convert to Floating-point (scalar)", "full_desc": "Unsigned fixed-point Convert to Floating-point (scalar). This instruction converts the unsigned value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the , and writes the result to the SIMD&FP destination register.", "syntax": ["UCVTF  <Hd>, <Wn>, #<fbits>\t; 32-bit to half-precision", "UCVTF  <Sd>, <Wn>, #<fbits>\t; 32-bit to single-precision", "UCVTF  <Dd>, <Wn>, #<fbits>\t; 32-bit to double-precision", "UCVTF  <Hd>, <Xn>, #<fbits>\t; 64-bit to half-precision", "UCVTF  <Sd>, <Xn>, #<fbits>\t; 64-bit to single-precision", "UCVTF  <Dd>, <Xn>, #<fbits>\t; 64-bit to double-precision"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<fbits>\nFor the 32-bit to double-precision, 32-bit to half-precision and 32-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 32, encoded as 64 minus \"scale\".", "<fbits>\nFor the 64-bit to double-precision, 64-bit to half-precision and 64-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus \"scale\"."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase ftype of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UNDEFINED;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\nif sf == '0' && scale<5> == '0' then UNDEFINED;\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"}, {"mnemonic": "LD1RQD (scalar plus scalar)", "short_desc": "Contiguous load and replicate two doublewords (scalar index)", "full_desc": "Load two contiguous doublewords to elements of a short, 128-bit (quadword) vector from the memory address generated by a 64-bit scalar base address and scalar index which is multiplied by 8 and added to the base address.", "syntax": ["LD1RQD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;", "operation": "CheckSVEEnabled();\ninteger elements = 128 DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g]; // low 16 bits only\nbits(64) offset;\nbits(128) result;\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\noffset = X[m];\n\naddr = base + UInt(offset) * mbytes;\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n    else\n        Elem[result, e, esize] = Zeros();\n    addr = addr + mbytes;\n\nZ[t] = Replicate(result, VL DIV 128);"}, {"mnemonic": "UQRSHL", "short_desc": "Unsigned saturating Rounding Shift Left (register)", "full_desc": "Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["UQRSHL  <V><d>, <V><n>, <V><m>\t; Scalar", "UQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "UMIN (immediate)", "short_desc": "Unsigned minimum with immediate (unpredicated)", "full_desc": "Determine the unsigned minimum of an immediate and each element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is an unsigned 8-bit value in the range 0 to 255, inclusive. This instruction is unpredicated.", "syntax": ["UMIN    <Zdn>.<T>, <Zdn>.<T>, #<imm>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<imm>\nIs the unsigned immediate operand, in the range 0 to 255, encoded in the \"imm8\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger dn = UInt(Zdn);\nboolean unsigned = TRUE;\ninteger imm = Int(imm8, unsigned);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer element1 = Int(Elem[operand1, e, esize], unsigned);\n    Elem[result, e, esize] = Min(element1, imm)<esize-1:0>;\n\nZ[dn] = result;"}, {"mnemonic": "UADDLP", "short_desc": "Unsigned Add Long Pairwise", "full_desc": "Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.", "syntax": ["UADDLP  <Vd>.<Ta>, <Vn>.<Tb>\t; Vector"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nif acc then result = V[d];\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    if acc then\n        Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n    else\n        Elem[result, e, 2*esize] = sum;\n\nV[d] = result;"}, {"mnemonic": "FMINNMV", "short_desc": "Floating-point Minimum Number across Vector", "full_desc": "Floating-point Minimum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.", "syntax": ["FMINNMV  <V><d>, <Vn>.<T>\t; Half-precision", "FMINNMV  <V><d>, <Vn>.<T>\t; Single-precision and double-precision"], "symbols": ["<V>\nFor the half-precision variant: is the destination width specifier, H.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<T>\n", "<T>\n"], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"}, {"mnemonic": "CINC", "short_desc": "Conditional Increment", "full_desc": "Conditional Increment returns, in the destination register, the value of the source register incremented by 1 if the condition is TRUE, and otherwise returns the value of the source register.", "syntax": ["CINC  <Wd>, <Wn>, <cond>\t; 32-bit", "CINC  <Xd>, <Xn>, <cond>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>\nIs the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>\nIs the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<cond>\nIs one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."]}, {"mnemonic": "SQRDMLSH (vector)", "short_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector)", "full_desc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.", "syntax": ["SQRDMLSH  <V><d>, <V><n>, <V><m>\t; Scalar", "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<m>\nIs the number of the second SIMD&FP source register, encoded in the \"Rm\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "if !HaveQRDMLAHExt() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "STLR", "short_desc": "Store-Release Register", "full_desc": "Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in . For information about memory accesses, see .", "syntax": ["STLR  <Wt>, [<Xn|SP>{,#0}]\t; 32-bit", "STLR  <Xt>, [<Xn|SP>{,#0}]\t; 64-bit"], "symbols": ["<Wt>\nIs the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "BFMMLA", "short_desc": "BFloat16 floating-point matrix multiply-accumulate", "full_desc": "This BFloat16 floating-point (BF16) matrix multiply-accumulate instruction multiplies the 2\u00d74 matrix of BF16 values held in each 128-bit segment of the first source vector by the 4\u00d72 BF16 matrix in the corresponding segment of the second source vector. The resulting 2\u00d72 single-precision (FP32) matrix product is then destructively added to the FP32 matrix accumulator held in the corresponding segment of the addend and destination vector. This is equivalent to performing a 4-way dot product per destination element.", "syntax": ["BFMMLA  <Zda>.S, <Zn>.H, <Zm>.H\t; SVE"], "symbols": ["<Zda>\nIs the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>\nIs the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;\ninteger n = UInt(Zn);\ninteger m = UInt(Zm);\ninteger da = UInt(Zda);", "operation": "CheckSVEEnabled();\ninteger segments =  VL DIV 128;\nbits(VL) operand1 = Z[n];\nbits(VL) operand2 = Z[m];\nbits(VL) operand3 = Z[da];\nbits(VL) result;\nbits(128) op1, op2;\nbits(128) res, addend;\n\nfor s = 0 to segments-1\n    op1    = Elem[operand1, s, 128];\n    op2    = Elem[operand2, s, 128];\n    addend = Elem[operand3, s, 128];\n    res    = BFMatMulAdd(addend, op1, op2);\n    Elem[result, s, 128] = res;\n\nZ[da] = result;"}, {"mnemonic": "UCVTF (vector, integer)", "short_desc": "Unsigned integer Convert to Floating-point (vector)", "full_desc": "Unsigned integer Convert to Floating-point (vector). This instruction converts each element in a vector from an unsigned integer value to a floating-point value using the rounding mode that is specified by the , and writes the result to the SIMD&FP destination register.", "syntax": ["UCVTF  <Hd>, <Hn>\t; Scalar half precision", "UCVTF  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "UCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "UCVTF  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nFPRounding rounding = FPRoundingMode(FPCR);\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "FRECPE", "short_desc": "Floating-point Reciprocal Estimate", "full_desc": "Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["FRECPE  <Hd>, <Hn>\t; Scalar half precision", "FRECPE  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FRECPE  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FRECPE  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecipEstimate(element, FPCR);\n\nV[d] = result;"}, {"mnemonic": "SRSRA", "short_desc": "Signed Rounding Shift Right and Accumulate (immediate)", "full_desc": "Signed Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see .", "syntax": ["SRSRA  <V><d>, <V><n>, #<shift>\t; Scalar", "SRSRA  <Vd>.<T>, <Vn>.<T>, #<shift>\t; Vector"], "symbols": ["<V>\n", "<d>\nIs the number of the SIMD&FP destination register, in the \"Rd\" field.", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<shift>\n", "<shift>\n"], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then UNDEFINED;\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "SQDMLSL, SQDMLSL2 (by element)", "short_desc": "Signed saturating Doubling Multiply-Subtract Long (by element)", "full_desc": "Signed saturating Doubling Multiply-Subtract Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values.", "syntax": ["SQDMLSL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]\t; Scalar", "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]\t; Vector"], "symbols": ["2\n", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Ta>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Tb>\n", "<Va>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Vb>\n", "<n>\nIs the number of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\n", "<Ts>\n", "<index>\n"], "decode": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o2 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"}, {"mnemonic": "DMB", "short_desc": "Data Memory Barrier", "full_desc": "Data Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see .", "syntax": ["DMB  <option>|#<imm>\t; System"], "symbols": ["<option>\nSpecifies the limitation on the barrier operation. Values are:", "<imm>\nIs a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"CRm\" field."], "decode": "case CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable; \n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\ncase CRm<1:0> of\n    when '00' types = MBReqTypes_All; domain = MBReqDomain_FullSystem;\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;", "operation": "DataMemoryBarrier(domain, types);"}, {"mnemonic": "FMUL (vectors, predicated)", "short_desc": "Floating-point multiply vectors (predicated)", "full_desc": "Multiply active floating-point elements of the first source vector by corresponding floating-point elements of the second source vector and destructively place the results in the corresponding elements of the first source vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["FMUL    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>\nIs the name of the second source scalable vector register, encoded in the \"Zm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger m = UInt(Zm);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(VL) operand1 = Z[dn];\nbits(VL) operand2 = Z[m];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    bits(esize) element2 = Elem[operand2, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = FPMul(element1, element2, FPCR<31:0>);\n    else\n        Elem[result, e, esize] = element1;\n\nZ[dn] = result;"}, {"mnemonic": "FCVTAU (scalar)", "short_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar)", "full_desc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.", "syntax": ["FCVTAU  <Wd>, <Hn>\t; Half-precision to 32-bit", "FCVTAU  <Xd>, <Hn>\t; Half-precision to 64-bit", "FCVTAU  <Wd>, <Sn>\t; Single-precision to 32-bit", "FCVTAU  <Xd>, <Sn>\t; Single-precision to 64-bit", "FCVTAU  <Wd>, <Dn>\t; Double-precision to 32-bit", "FCVTAU  <Xd>, <Dn>\t; Double-precision to 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Dn>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase ftype of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UNDEFINED;\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UNDEFINED;\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UNDEFINED;\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64;  // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UNDEFINED;\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UNDEFINED;", "operation": "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        bit Z;\n        fltval = V[n];\n        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);\n        PSTATE.<N,Z,C,V> = '0':Z:'00';\n        X[d] = intval;"}, {"mnemonic": "SRHADD", "short_desc": "Signed Rounding Halving Add", "full_desc": "Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SRHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;\n\nV[d] = result;"}, {"mnemonic": "LD2D (scalar plus scalar)", "short_desc": "Contiguous load two-doubleword structures to two vectors (scalar index)", "full_desc": "Contiguous load two-doubleword structures, each to the same element number in two vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register scaled by the element size ( option) and added to the base address. After each structure access the index value is incremented by two. The index register is not updated by the instruction.", "syntax": ["LD2D    { <Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 64;\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nbits(64) offset = X[m];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];\n        else\n            Elem[values[r], e, esize] = Zeros();\n        addr = addr + mbytes;\n    offset = offset + nreg;\n\nfor r = 0 to nreg-1\n    Z[(t+r) MOD 32] = values[r];"}, {"mnemonic": "EON", "short_desc": "Bitwise exclusive OR with inverted immediate (unpredicated)", "full_desc": "Bitwise exclusive OR an inverted immediate with each 64-bit element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate is a 64-bit value consisting of a single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction is unpredicated.", "syntax": ["EON     <Zdn>.<T>, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<const>\nIs a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."]}, {"mnemonic": "ST2W (scalar plus immediate)", "short_desc": "Contiguous store two-word structures from two vectors (immediate index)", "full_desc": "Contiguous store two-word structures, each from the same element number in two vector registers to the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 2 in the range -16 to 14 that is multiplied by the vector's in-memory size, irrespective of predication,", "syntax": ["ST2W    { <Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]\t; SVE"], "symbols": ["<Zt1>\nIs the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt2>\nIs the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\nIs the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger offset = SInt(imm4);\ninteger nreg = 2;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\narray [0..1] of bits(VL) values;\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);\n    base = SP[];\nelse\n    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n    base = X[n];\n\nfor r = 0 to nreg-1\n    values[r] = Z[(t+r) MOD 32];\n\naddr = base + offset * elements * nreg * mbytes;\nfor e = 0 to elements-1\n    for r = 0 to nreg-1\n        if ElemP[mask, e, esize] == '1' then\n            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];\n        addr = addr + mbytes;"}, {"mnemonic": "ST1 (multiple structures)", "short_desc": "Store multiple single-element structures from one, two, three, or four registers", "full_desc": "Store multiple single-element structures from one, two, three, or four registers. This instruction stores elements to memory from one, two, three, or four SIMD&FP registers, without interleaving. Every element of each register is stored.", "syntax": ["ST1  { <Vt>.<T> }, [<Xn|SP>]\t; One register", "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\t; Two registers", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\t; Three registers", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]\t; Four registers", "ST1  { <Vt>.<T> }, [<Xn|SP>], <imm>\t; One register, immediate offset", "ST1  { <Vt>.<T> }, [<Xn|SP>], <Xm>\t; One register, register offset", "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>\t; Two registers, immediate offset", "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>\t; Two registers, register offset", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>\t; Three registers, immediate offset", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>\t; Three registers, register offset", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>\t; Four registers, immediate offset", "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>\t; Four registers, register offset"], "symbols": ["<Vt>\nIs the name of the first or only SIMD&FP register to be transferred, encoded in the \"Rt\" field.", "<T>\n", "<Vt2>\nIs the name of the second SIMD&FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Vt3>\nIs the name of the third SIMD&FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Vt4>\nIs the name of the fourth SIMD&FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>\n", "<imm>\n", "<imm>\n", "<imm>\n", "<Xm>\nIs the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."], "decode": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;\nboolean tag_checked = wback || n != 31;", "operation": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UNDEFINED;\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then UNDEFINED;"}, {"mnemonic": "BFC", "short_desc": "Bitfield Clear", "full_desc": "Bitfield Clear sets a bitfield of  bits at bit position  of the destination register to zero, leaving the other destination bits unchanged.", "syntax": ["BFC  <Wd>, #<lsb>, #<width>\t; 32-bit", "BFC  <Xd>, #<lsb>, #<width>\t; 64-bit"], "symbols": ["<Wd>\nIs the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>\nIs the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>\nFor the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.", "<lsb>\nFor the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<width>\nFor the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.", "<width>\nFor the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>."]}, {"mnemonic": "DUP (general)", "short_desc": "Duplicate general-purpose register to vector", "full_desc": "Duplicate general-purpose register to vector. This instruction duplicates the contents of the source general-purpose register into a scalar or each element in a vector, and writes the result to the SIMD&FP destination register.", "syntax": ["DUP  <Vd>.<T>, <R><n>\t; Advanced SIMD"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<R>\n", "<n>\nIs the number [0-30] of the general-purpose source register or ZR (31), encoded in the \"Rn\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UNDEFINED;\n\n// imm5<4:size+1> is IGNORED\n\nif size == 3 && Q == '0' then UNDEFINED;\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;", "operation": "CheckFPAdvSIMDEnabled64();\nbits(esize) element = X[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = element;\nV[d] = result;"}, {"mnemonic": "FCVTAS (vector)", "short_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector)", "full_desc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.", "syntax": ["FCVTAS  <Hd>, <Hn>\t; Scalar half precision", "FCVTAS  <V><d>, <V><n>\t; Scalar single-precision and double-precision", "FCVTAS  <Vd>.<T>, <Vn>.<T>\t; Vector half precision", "FCVTAS  <Vd>.<T>, <Vn>.<T>\t; Vector single-precision and double-precision"], "symbols": ["<Hd>\nIs the 16-bit name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<Hn>\nIs the 16-bit name of the SIMD&FP source register, encoded in the \"Rn\" field.", "<V>\n", "<d>\nIs the number of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<n>\nIs the number of the SIMD&FP source register, encoded in the \"Rn\" field.", "<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<T>\n", "<Vn>\nIs the name of the SIMD&FP source register, encoded in the \"Rn\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"}, {"mnemonic": "LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL", "short_desc": "Atomic signed maximum on word or doubleword in memory", "full_desc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.", "syntax": ["LDSMAX  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMAX", "LDSMAXA  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMAXA", "LDSMAXAL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMAXAL", "LDSMAXL  <Ws>, <Wt>, [<Xn|SP>]\t; 32-bit LDSMAXL", "LDSMAX  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMAX", "LDSMAXA  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMAXA", "LDSMAXAL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMAXAL", "LDSMAXL  <Xs>, <Xt>, [<Xn|SP>]\t; 64-bit LDSMAXL"], "symbols": ["<Ws>\nIs the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>\nIs the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xs>\nIs the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>\nIs the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."], "decode": "if !HaveAtomicExt() then UNDEFINED;\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nboolean tag_checked = n != 31;", "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\n\nif HaveMTEExt() then\n    SetTagCheckedInstruction(tag_checked);\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = MemAtomic(address, op, value, ldacctype, stacctype);\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"}, {"mnemonic": "SMAXP", "short_desc": "Signed Maximum Pairwise", "full_desc": "Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.", "syntax": ["SMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>\t; Three registers of the same type"], "symbols": ["<Vd>\nIs the name of the SIMD&FP destination register, encoded in the \"Rd\" field.", "<T>\n", "<Vn>\nIs the name of the first SIMD&FP source register, encoded in the \"Rn\" field.", "<Vm>\nIs the name of the second SIMD&FP source register, encoded in the \"Rm\" field."], "decode": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');", "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"}, {"mnemonic": "LD1H (scalar plus vector)", "short_desc": "Gather load unsigned halfwords to vector (vector index)", "full_desc": "Gather load of unsigned halfwords to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 2. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.", "syntax": ["LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]\t; 32-bit scaled offset", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]\t; 32-bit unpacked scaled offset", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]\t; 32-bit unpacked unscaled offset", "LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]\t; 32-bit unscaled offset", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]\t; 64-bit scaled offset", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]\t; 64-bit unscaled offset"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>\nIs the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<mod>\n"], "decode": "if !HaveSVE() then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Zm);\ninteger g = UInt(Pg);\ninteger esize = 32;\ninteger msize = 16;\ninteger offs_size = 32;\nboolean unsigned = TRUE;\nboolean offs_unsigned = xs == '0';\ninteger scale = 1;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(VL) offset = Z[m];\nbits(PL) mask = P[g];\nbits(VL) result;\nbits(msize) data;\nconstant integer mbytes = msize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);\n        addr = base + (off << scale);\n        data = Mem[addr, mbytes, AccType_NORMAL];\n        Elem[result, e, esize] = Extend(data, esize, unsigned);\n    else\n        Elem[result, e, esize] = Zeros();\n\nZ[t] = result;"}, {"mnemonic": "UQDECP (vector)", "short_desc": "Unsigned saturating decrement vector by count of true predicate elements", "full_desc": "Counts the number of true elements in the source predicate and then uses the result to decrement all destination vector elements. The results are saturated to the element unsigned integer range.", "syntax": ["UQDECP  <Zdn>.<T>, <Pm>.<T>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pm>\nIs the name of the source scalable predicate register, encoded in the \"Pm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif size == '00' then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Pm);\ninteger dn = UInt(Zdn);\nboolean unsigned = TRUE;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(PL) operand2 = P[m];\nbits(VL) result;\ninteger count = 0;\n\nfor e = 0 to elements-1\n    if ElemP[operand2, e, esize] == '1' then\n        count = count + 1;\n\nfor e = 0 to elements-1\n    integer element = Int(Elem[operand1, e, esize], unsigned);\n    (Elem[result, e, esize], -) = SatQ(element - count, esize, unsigned);\n\nZ[dn] = result;"}, {"mnemonic": "CPY (SIMD&FP scalar)", "short_desc": "Copy SIMD&FP scalar register to vector elements (predicated)", "full_desc": "Copy the SIMD & floating-point scalar source register to each active element in the destination vector. Inactive elements in the destination vector register remain unmodified.", "syntax": ["CPY     <Zd>.<T>, <Pg>/M, <V><n>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<V>\n", "<n>\nIs the number [0-31] of the source SIMD&FP register, encoded in the \"Vn\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger g = UInt(Pg);\ninteger n = UInt(Vn);\ninteger d = UInt(Zd);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(PL) mask = P[g];\nbits(esize) operand1 = V[n];\nbits(VL) result = Z[d];\n\nfor e = 0 to elements-1\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = operand1;\n\nZ[d] = result;"}, {"mnemonic": "STNT1H (scalar plus scalar)", "short_desc": "Contiguous store non-temporal halfwords from vector (scalar index)", "full_desc": "Contiguous store non-temporal of halfwords from elements of a vector register to the memory address generated by a 64-bit scalar base and scalar index which is multiplied by 2 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements are not written to memory.", "syntax": ["STNT1H  { <Zt>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]\t; SVE"], "symbols": ["<Zt>\nIs the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>\nIs the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>\nIs the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\nif Rm == '11111' then UNDEFINED;\ninteger t = UInt(Zt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger g = UInt(Pg);\ninteger esize = 16;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(64) base;\nbits(64) addr;\nbits(64) offset = X[m];\nbits(VL) src;\nbits(PL) mask = P[g];\nconstant integer mbytes = esize DIV 8;\n\nif HaveMTEExt() then SetTagCheckedInstruction(TRUE);\n\nif n == 31 then\n    if LastActiveElement(mask, esize) >= 0 || \n          ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then \n        CheckSPAlignment();\n    base = SP[];\nelse\n    base = X[n];\n\nsrc = Z[t];\nfor e = 0 to elements-1\n    addr = base + UInt(offset) * mbytes;\n    if ElemP[mask, e, esize] == '1' then\n        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];\n    offset = offset + 1;"}, {"mnemonic": "DCPS2", "short_desc": "Debug Change PE State to EL2.", "full_desc": "Debug Change PE State to EL2, when executed in Debug state:", "syntax": ["DCPS2  {#<imm>}\t; System"], "symbols": ["<imm>\nIs an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the \"imm16\" field."], "decode": "bits(2) target_level = LL;\nif LL == '00' then UNDEFINED;\nif !Halted() then UNDEFINED;", "operation": "DCPSInstruction(target_level);"}, {"mnemonic": "LSL (immediate, predicated)", "short_desc": "Logical shift left by immediate (predicated)", "full_desc": "Shift left by immediate each active element of the source vector, and destructively place the results in the corresponding elements of the source vector. The immediate shift amount is an unsigned value in the range 0 to number of bits per element minus 1. Inactive elements in the destination vector register remain unmodified.", "syntax": ["LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>\t; SVE"], "symbols": ["<Zdn>\nIs the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T>\n", "<Pg>\nIs the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>\nIs the immediate shift amount, in the range 0 to number of bits per element minus 1, encoded in \"tsz:imm3\"."], "decode": "if !HaveSVE() then UNDEFINED;\nbits(4) tsize = tszh:tszl;\ncase tsize of\n    when '0000' UNDEFINED;\n    when '0001' esize = 8;\n    when '001x' esize = 16;\n    when '01xx' esize = 32;\n    when '1xxx' esize = 64;\ninteger g = UInt(Pg);\ninteger dn = UInt(Zdn);\ninteger shift = UInt(tsize:imm3) - esize;", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(VL) operand1 = Z[dn];\nbits(PL) mask = P[g];\nbits(VL) result;\n\nfor e = 0 to elements-1\n    bits(esize) element1 = Elem[operand1, e, esize];\n    if ElemP[mask, e, esize] == '1' then\n        Elem[result, e, esize] = LSL(element1, shift);\n    else\n        Elem[result, e, esize] = Elem[operand1, e, esize];\n\nZ[dn] = result;"}, {"mnemonic": "INDEX (immediate, scalar)", "short_desc": "Create index starting from immediate and incremented by general-purpose register", "full_desc": "Populates the destination vector by setting the first element to the first signed immediate integer operand and monotonically incrementing the value by the second signed scalar integer operand for each subsequent element. The scalar source operand is a general-purpose register in which only the least significant bits corresponding to the vector element size are used and any remaining bits are ignored. This instruction is unpredicated.", "syntax": ["INDEX   <Zd>.<T>, #<imm>, <R><m>\t; SVE"], "symbols": ["<Zd>\nIs the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T>\n", "<imm>\nIs the signed immediate operand, in the range -16 to 15, encoded in the \"imm5\" field.", "<R>\n", "<m>\nIs the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field."], "decode": "if !HaveSVE() then UNDEFINED;\ninteger esize = 8 << UInt(size);\ninteger m = UInt(Rm);\ninteger d = UInt(Zd);\ninteger imm = SInt(imm5);", "operation": "CheckSVEEnabled();\ninteger elements = VL DIV esize;\nbits(esize) operand2 = X[m];\ninteger element2 = SInt(operand2);\nbits(VL) result;\n\nfor e = 0 to elements-1\n    integer index = imm + e * element2;\n    Elem[result, e, esize] = index<esize-1:0>;\n\nZ[d] = result;"}]