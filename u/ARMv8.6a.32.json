[{"mnemonic": "UHSAX", "short_desc": "Unsigned Halving Subtract and Add with Exchange", "full_desc": "Unsigned Halving Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one unsigned 16-bit integer subtraction and one unsigned 16-bit addition, halves the results, and writes the results to the destination register.", "syntax": ["UHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum  = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);\n    diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);\n    R[d]<15:0>  = sum<16:1>;\n    R[d]<31:16> = diff<16:1>;"}, {"mnemonic": "VZIP (alias)", "short_desc": "Vector Zip", "syntax": ["VZIP{<c>}{<q>}.32 <Dd>, <Dm>\t; 64-bit SIMD vector", "VZIP{<c>}{<q>}.32 <Dd>, <Dm>\t; 64-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."]}, {"mnemonic": "TSB CSYNC", "short_desc": "Trace Synchronization Barrier", "full_desc": "Trace Synchronization Barrier. This instruction is a barrier that synchronizes the trace operations of instructions.", "syntax": ["TSB{<c>}{<q>} CSYNC\t; A1", "TSB{<c>}{<q>} CSYNC\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "if !HaveSelfHostedTrace() then EndOfInstruction(); // Instruction executes as NOP\nif cond != '1110' then UNPREDICTABLE;              // ESB must be encoded with AL condition", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    TraceSynchronizationBarrier();"}, {"mnemonic": "VCVTT", "short_desc": "Convert to or from a half-precision value in the top half of a single-precision register", "full_desc": "Convert to or from a half-precision value in the top half of a single-precision register does one of the following:", "syntax": ["VCVTT{<c>}{<q>}.F32.F16 <Sd>, <Sm>\t; Half-precision to single-precision", "VCVTT{<c>}{<q>}.F64.F16 <Dd>, <Sm>\t; Half-precision to double-precision", "VCVTT{<c>}{<q>}.F16.F32 <Sd>, <Sm>\t; Single-precision to half-precision", "VCVTT{<c>}{<q>}.F16.F64 <Sd>, <Dm>\t; Double-precision to half-precision", "VCVTT{<c>}{<q>}.F32.F16 <Sd>, <Sm>\t; Half-precision to single-precision", "VCVTT{<c>}{<q>}.F64.F16 <Dd>, <Sm>\t; Half-precision to double-precision", "VCVTT{<c>}{<q>}.F16.F32 <Sd>, <Sm>\t; Single-precision to half-precision", "VCVTT{<c>}{<q>}.F16.F64 <Sd>, <Dm>\t; Double-precision to half-precision"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "uses_double = (sz == '1'); convert_from_half = (op == '0');\nlowbit = (if T == '1' then 16 else 0);\nif uses_double then\n    if convert_from_half then\n        d = UInt(D:Vd); m = UInt(Vm:M);\n    else\n        d = UInt(Vd:D); m = UInt(M:Vm);\nelse\n    d = UInt(Vd:D); m = UInt(Vm:M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\n    bits(16) hp;\n    if convert_from_half then\n        hp = S[m]<lowbit+15:lowbit>;\n        if uses_double then\n            D[d] = FPConvert(hp, FPSCR);\n        else\n            S[d] = FPConvert(hp, FPSCR);\n    else\n        if uses_double then\n            hp = FPConvert(D[m], FPSCR);\n        else\n            hp = FPConvert(S[m], FPSCR);\n        S[d]<lowbit+15:lowbit> = hp;"}, {"mnemonic": "VCVT (from single-precision to BFloat16, Advanced SIMD)", "short_desc": "Vector Convert from single-precision to BFloat16", "full_desc": "Vector Convert from single-precision to BFloat16 converts each 32-bit element in a vector from single-precision floating-point to BFloat16 format, and writes the result into a second vector. The result vector elements are half the width of the source vector elements.", "syntax": ["VCVT{<c>}{<q>}.BF16.F32 <Dd>, <Qm>\t; A1", "VCVT{<c>}{<q>}.BF16.F32 <Dd>, <Qm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAArch32BF16Ext() then UNDEFINED;\nif Vm<0> == '1' then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger m = UInt(M:Vm);", "operation": "bits(128) operand;\nbits(64) result;\n\nif ConditionPassed() then\n    EncodingSpecificOperations();\n    CheckAdvSIMDEnabled();\n\n    operand = Q[m>>1];\n    for e = 0 to 3\n        bits(32) op = Elem[operand, e, 32];\n        Elem[result, e, 16] = FPConvertBF(op, StandardFPSCRValue());\n    D[d] = result;"}, {"mnemonic": "MRS (Banked register)", "short_desc": "Move Banked or Special register to general-purpose register", "full_desc": "Move to Register from Banked or Special register moves the value from the Banked general-purpose register or  of the specified mode, or the value of , to a general-purpose register.", "syntax": ["MRS{<c>}{<q>} <Rd>, <banked_reg>\t; A1", "MRS{<c>}{<q>} <Rd>, <banked_reg>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<banked_reg>\n"], "decode": "d = UInt(Rd);  read_spsr = (R == '1');\nif d == 15 then UNPREDICTABLE;\nSYSm = M:M1;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if PSTATE.EL == EL0 then\n       UNPREDICTABLE;\n    else\n        mode = PSTATE.M;\n        if read_spsr then\n            SPSRaccessValid(SYSm, mode);           // Check for UNPREDICTABLE cases\n            case SYSm of\n                when '01110'  R[d] = SPSR_fiq;\n                when '10000'  R[d] = SPSR_irq;\n                when '10010'  R[d] = SPSR_svc;\n                when '10100'  R[d] = SPSR_abt;\n                when '10110'  R[d] = SPSR_und;\n                when '11100'\n                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();\n                    R[d] = SPSR_mon;\n                when '11110'  R[d] = SPSR_hyp;\n        else\n            BankedRegisterAccessValid(SYSm, mode); // Check for UNPREDICTABLE cases\n            case SYSm of\n                when '00xxx'                       // Access the User mode registers\n                    m = UInt(SYSm<2:0>) + 8;\n                    R[d] = Rmode[m,M32_User];\n                when '01xxx'                       // Access the FIQ mode registers\n                    m = UInt(SYSm<2:0>) + 8;\n                    R[d] = Rmode[m,M32_FIQ];\n                when '1000x'                       // Access the IRQ mode registers\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    R[d] = Rmode[m,M32_IRQ];\n                when '1001x'                       // Access the Supervisor mode registers\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    R[d] = Rmode[m,M32_Svc];\n                when '1010x'                       // Access the Abort mode registers\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    R[d] = Rmode[m,M32_Abort];\n                when '1011x'                       // Access the Undefined mode registers\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    R[d] = Rmode[m,M32_Undef];\n                when '1110x'                       // Access Monitor registers\n                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    R[d] = Rmode[m,M32_Monitor];\n                when '11110'                       // Access ELR_hyp register\n                    R[d] = ELR_hyp;\n                when '11111'                       // Access SP_hyp register\n                    R[d] = Rmode[13,M32_Hyp];"}, {"mnemonic": "MRS", "short_desc": "Move Special register to general-purpose register", "full_desc": "Move Special register to general-purpose register moves the value of the , , or _<current_mode> into a general-purpose register.", "syntax": ["MRS{<c>}{<q>} <Rd>, <spec_reg>\t; A1", "MRS{<c>}{<q>} <Rd>, <spec_reg>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<spec_reg>\n"], "decode": "d = UInt(Rd);  read_spsr = (R == '1');\nif d == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if read_spsr then\n        if PSTATE.M IN {M32_User,M32_System} then\n            UNPREDICTABLE;\n        else\n            R[d] = SPSR[];\n    else\n        // CPSR has same bit assignments as SPSR, but with the IT, J, SS, IL, and T bits masked out.\n        bits(32) mask = '11111000 00001111 00000011 11011111';\n        if HavePANExt() then\n            mask<22> = '1';\n\n        if HaveDITExt() then\n            mask<21> = '1';\n        psr_val = GetPSRFromPSTATE() AND mask;\n        if PSTATE.EL == EL0 then\n            // If accessed from User mode return UNKNOWN values for E, A, I, F bits, bits<9:6>,\n            // and for the M field, bits<4:0>\n            psr_val<22> = bits(1) UNKNOWN;\n            psr_val<9:6> = bits(4) UNKNOWN;\n            psr_val<4:0> = bits(5) UNKNOWN;\n        R[d] = psr_val;"}, {"mnemonic": "VMOVL", "short_desc": "Vector Move Long", "full_desc": "Vector Move Long takes each element in a doubleword vector, sign or zero-extends them to twice their original length, and places the results in a quadword vector.", "syntax": ["VMOVL{<c>}{<q>}.<dt> <Qd>, <Dm>\t; A1", "VMOVL{<c>}{<q>}.<dt> <Qd>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if imm3H == '000' then SEE \"Related encodings\";\nif imm3H != '001' && imm3H != '010' && imm3H != '100' then SEE \"VSHLL\";\nif Vd<0> == '1' then UNDEFINED;\nesize = 8 * UInt(imm3H);\nunsigned = (U == '1');  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        result = Int(Elem[Din[m],e,esize], unsigned);\n        Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;"}, {"mnemonic": "QDSUB", "short_desc": "Saturating Double and Subtract", "full_desc": "Saturating Double and Subtract subtracts a doubled register value from another register value, and writes the result to the destination register. Both the doubling and the subtraction have their results saturated to the 32-bit signed integer range -2 <= x <= 2 - 1. If saturation occurs in either operation, it sets .Q to 1.", "syntax": ["QDSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>\t; A1", "QDSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the second general-purpose source register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);\n    (R[d], sat2)  = SignedSatQ(SInt(R[m]) - SInt(doubled), 32);\n    if sat1 || sat2 then\n        PSTATE.Q = '1';"}, {"mnemonic": "LDR (immediate)", "short_desc": "Load Register (immediate)", "full_desc": "Load Register (immediate) calculates an address from a base register value and an immediate offset, loads a word from memory, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing. For information about memory accesses see .", "syntax": ["LDR{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "LDR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "LDR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1", "LDR{<c>}{<q>} <Rt>, [SP{, #{+}<imm>}]\t; T2", "LDR{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]\t; T3", "LDR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T3", "LDR{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]\t; Offset", "LDR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used. If the PC is used, the instruction branches to the address (data) loaded to the PC. This is an interworking branch, see .", "<Rt>\nFor encoding T1 and T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nFor encoding T3 and T4: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, provided the instruction is either outside an IT block or the last instruction of an IT block. If the PC is used, the instruction branches to the address (data) loaded to the PC. This is an interworking branch, see .", "<Rn>\nFor encoding A1, T3 and T4: is the general-purpose base register, encoded in the \"Rn\" field. For PC use see .", "<Rn>\nFor encoding T1: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is the optional positive unsigned immediate byte offset, a multiple of 4, in the range 0 to 124, defaulting to 0 and encoded in the \"imm5\" field as <imm>/4.", "<imm>\nFor encoding T2: is the optional positive unsigned immediate byte offset, a multiple of 4, in the range 0 to 1020, defaulting to 0 and encoded in the \"imm8\" field as <imm>/4.", "<imm>\nFor encoding T3: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T4: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field."], "decode": "if Rn == '1111' then SEE \"LDR (literal)\";\nif P == '0' && W == '1' then SEE \"LDRT\";\nt = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif wback && n == t then UNPREDICTABLE;", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        data = MemU[address,4];\n        if wback then R[n] = offset_addr;\n        if t == 15 then\n            if address<1:0> == '00' then\n                LoadWritePC(data);\n            else\n                UNPREDICTABLE;\n        else\n            R[t] = data;\nelse\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        data = MemU[address,4];\n        if wback then R[n] = offset_addr;\n        if t == 15 then\n            if address<1:0> == '00' then\n                LoadWritePC(data);\n            else\n                UNPREDICTABLE;\n        else\n            R[t] = data;"}, {"mnemonic": "STLH", "short_desc": "Store-Release Halfword", "full_desc": "Store-Release Halfword stores a halfword from a register to memory. The instruction also has memory ordering semantics as described in .", "syntax": ["STLH{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "STLH{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt); n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    MemO[address, 2] = R[t]<15:0>;"}, {"mnemonic": "VRSQRTS", "short_desc": "Vector Reciprocal Square Root Step", "full_desc": "Vector Reciprocal Square Root Step multiplies the elements of one vector by the corresponding elements of another vector, subtracts each of the products from 3.0, divides these results by 2.0, and places the results into the elements of the destination vector.", "syntax": ["VRSQRTS{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VRSQRTS{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VRSQRTS{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VRSQRTS{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = FPRSqrtStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);"}, {"mnemonic": "STLEXH", "short_desc": "Store-Release Exclusive Halfword", "full_desc": "Store-Release Exclusive Halfword stores a halfword from a register to memory if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.", "syntax": ["STLEXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; A1", "STLEXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the destination general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rd\" field. The value returned is:", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);\nif d == 15 || t == 15 || n == 15 then UNPREDICTABLE;\nif d == n || d == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    if AArch32.ExclusiveMonitorsPass(address,2) then\n        MemO[address, 2] = R[t]<15:0>;\n        R[d] = ZeroExtend('0');\n    else\n        R[d] = ZeroExtend('1');"}, {"mnemonic": "VLDM, VLDMDB, VLDMIA", "short_desc": "Load Multiple SIMD&FP registers", "full_desc": "Load Multiple SIMD&FP registers loads multiple registers from consecutive locations in the Advanced SIMD and floating-point register file using an address from a general-purpose register.", "syntax": ["VLDMDB{<c>}{<q>}{.<size>} <Rn>!, <dreglist>\t; Decrement Before", "VLDM{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>\t; Increment After", "VLDMIA{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>\t; Increment After", "VLDMDB{<c>}{<q>}{.<size>} <Rn>!, <sreglist>\t; Decrement Before", "VLDM{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>\t; Increment After", "VLDMIA{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>\t; Increment After", "VLDMDB{<c>}{<q>}{.<size>} <Rn>!, <dreglist>\t; Decrement Before", "VLDM{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>\t; Increment After", "VLDMIA{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>\t; Increment After", "VLDMDB{<c>}{<q>}{.<size>} <Rn>!, <sreglist>\t; Decrement Before", "VLDM{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>\t; Increment After", "VLDMIA{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>\t; Increment After"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<size>\nAn optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers being transferred.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. If writeback is not specified, the PC can be used.", "!\nSpecifies base register writeback. Encoded in the \"W\" field as 1 if present, otherwise 0.", "<sreglist>\nIs the list of consecutively numbered 32-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"Vd:D\", and \"imm8\" is set to the number of registers in the list. The list must contain at least one register.", "<dreglist>\nIs the list of consecutively numbered 64-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"D:Vd\", and \"imm8\" is set to twice the number of registers in the list. The list must contain at least one register, and must not contain more than 16 registers."], "decode": "if P == '0' && U == '0' && W == '0' then SEE \"Related encodings\";\nif P == '1' && W == '0' then SEE \"VLDR\";\nif P == U && W == '1' then UNDEFINED;\n// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)\nsingle_regs = FALSE;  add = (U == '1');  wback = (W == '1');\nd = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);\nregs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see \"FLDM*X\".\nif n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;\nif regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;\nif imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    address = if add then R[n] else R[n]-imm32;\n    for r = 0 to regs-1\n        if single_regs then\n            S[d+r] = MemA[address,4];  address = address+4;\n        else\n            word1 = MemA[address,4];  word2 = MemA[address+4,4];  address = address+8;\n            // Combine the word-aligned words in the correct order for current endianness.\n            D[d+r] = if BigEndian() then word1:word2 else word2:word1;\n    if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;"}, {"mnemonic": "TST (register-shifted register)", "short_desc": "Test (register-shifted register)", "full_desc": "Test (register-shifted register) performs a bitwise AND operation on a register value and a register-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["TST{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>\t; A1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<type>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nshift_t = DecodeRegShift(stype);\nif n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] AND shifted;\n    PSTATE.N = result<31>;\n    PSTATE.Z = IsZeroBit(result);\n    PSTATE.C = carry;\n    // PSTATE.V unchanged"}, {"mnemonic": "VRINTP (Advanced SIMD)", "short_desc": "Vector Round floating-point to integer towards +Infinity", "full_desc": "Vector Round floating-point to integer towards +Infinity rounds a vector of floating-point values to integral floating-point values of the same size using the Round towards +Infinity rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTP{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTP{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VRINTP{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTP{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if op<2> != op<0> then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\n// Rounding encoded differently from other VCVT and VRINT instructions\nrounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        op1 = Elem[D[m+r],e,esize];\n        result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);\n        Elem[D[d+r],e,esize] = result;"}, {"mnemonic": "ADC, ADCS (immediate)", "short_desc": "Add with Carry (immediate)", "full_desc": "Add with Carry (immediate) adds an immediate value and the Carry flag value to a register value, and writes the result to the destination register.", "syntax": ["ADC{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ADC", "ADCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ADCS", "ADC{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ADC", "ADCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ADCS"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result, nzcv) = AddWithCarry(R[n], imm32, PSTATE.C);\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "RFE, RFEDA, RFEDB, RFEIA, RFEIB", "short_desc": "Return From Exception", "full_desc": "Return From Exception loads two consecutive memory locations using an address in a base register:", "syntax": ["RFEDA{<c>}{<q>} <Rn>{!}\t; Decrement After", "RFEDB{<c>}{<q>} <Rn>{!}\t; Decrement Before", "RFE{IA}{<c>}{<q>} <Rn>{!}\t; Increment After", "RFEIB{<c>}{<q>} <Rn>{!}\t; Increment Before", "RFEDB{<c>}{<q>} <Rn>{!}\t; T1", "RFE{IA}{<c>}{<q>} <Rn>{!}\t; T2"], "symbols": ["IA\nFor encoding A1: is an optional suffix to indicate the Increment After variant.", "IA\nFor encoding T2: is an optional suffix for the Increment After form.", "<c>\nFor encoding A1: see .  must be  or omitted.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0."], "decode": "n = UInt(Rn);\nwback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);\nif n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if PSTATE.EL == EL2 then\n        UNDEFINED;\n    elsif PSTATE.EL == EL0 then\n        UNPREDICTABLE;                        // UNDEFINED or NOP\n    else\n        address = if increment then R[n] else R[n]-8;\n        if wordhigher then address = address+4;\n        new_pc_value = MemA[address,4];\n        spsr = MemA[address+4,4];\n        if wback then R[n] = if increment then R[n]+8 else R[n]-8;\n        AArch32.ExceptionReturn(new_pc_value, spsr);"}, {"mnemonic": "ROR (register)", "short_desc": "Rotate Right (register)", "syntax": ["ROR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Not flag setting", "ROR<c>{<q>} {<Rdm>,} <Rdm>, <Rs>\t; Rotate right", "ROR<c>.W {<Rd>,} <Rm>, <Rs>\t; Not flag setting", "ROR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rs>\nIs the second general-purpose source register holding a rotate amount in its bottom 8 bits, encoded in the \"Rs\" field."]}, {"mnemonic": "VMVN (immediate)", "short_desc": "Vector Bitwise NOT (immediate)", "full_desc": "Vector Bitwise NOT (immediate) places the bitwise inverse of an immediate integer constant into every element of the destination register.", "syntax": ["VMVN{<c>}{<q>}.I32 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMVN{<c>}{<q>}.I32 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMVN{<c>}{<q>}.I16 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMVN{<c>}{<q>}.I16 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMVN{<c>}{<q>}.I32 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMVN{<c>}{<q>}.I32 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMVN{<c>}{<q>}.I32 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMVN{<c>}{<q>}.I32 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMVN{<c>}{<q>}.I16 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMVN{<c>}{<q>}.I16 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMVN{<c>}{<q>}.I32 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMVN{<c>}{<q>}.I32 <Qd>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1, A2 and A3: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<imm>\nIs a constant of the specified type that is replicated to fill the destination register. For details of the range of constants available and the encoding of , see ."], "decode": "if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE \"Related encodings\";\nif Q == '1' && Vd<0> == '1' then UNDEFINED;\nimm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);\nd = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        D[d+r] = NOT(imm64);"}, {"mnemonic": "ASRS (immediate)", "short_desc": "Arithmetic Shift Right, setting flags (immediate)", "full_desc": "Arithmetic Shift Right, setting flags (immediate) shifts a register value right by an immediate number of bits, shifting in copies of its sign bit, and writes the result to the destination register.", "syntax": ["ASRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value", "ASRS{<q>} {<Rd>,} <Rm>, #<imm>\t; T2", "ASRS.W {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value", "ASRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction performs an exception return, that restores  from SPSR_<current_mode>.", "<Rd>\nFor encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.", "<imm>\nFor encoding A1 and T2: is the shift amount, in the range 1 to 32, encoded in the \"imm5\" field as <imm> modulo 32.", "<imm>\nFor encoding T3: is the shift amount, in the range 1 to 32, encoded in the \"imm3:imm2\" field as <imm> modulo 32."]}, {"mnemonic": "LDRSH (literal)", "short_desc": "Load Register Signed Halfword (literal)", "full_desc": "Load Register Signed Halfword (literal) calculates an address from the PC value and an immediate offset, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRSH{<c>}{<q>} <Rt>, <label>\t; A1", "LDRSH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; A1", "LDRSH{<c>}{<q>} <Rt>, <label>\t; T1", "LDRSH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<label>\nFor encoding A1: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Any value in the range -255 to 255 is permitted.", "<label>\nFor encoding T1: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Permitted values of the offset are -4095 to 4095.", "+/-\n", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "if P == '0' && W == '1' then SEE \"LDRSHT\";\nt = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);\nadd = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 || wback then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    base = Align(PC,4);\n    address = if add then (base + imm32) else (base - imm32);\n    data = MemU[address,2];\n    R[t] = SignExtend(data, 32);"}, {"mnemonic": "STREX", "short_desc": "Store Register Exclusive", "full_desc": "Store Register Exclusive calculates an address from a base register value and an immediate offset, stores a word from a register to the calculated address if the PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.", "syntax": ["STREX{<c>}{<q>} <Rd>, <Rt>, [<Rn> {, {#}<imm>}]\t; A1", "STREX{<c>}{<q>} <Rd>, <Rt>, [<Rn> {, #<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the destination general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rd\" field. The value returned is:", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<imm>\nFor encoding A1: the immediate offset added to the value of  to calculate the address.  can only be 0 or omitted.", "<imm>\nFor encoding T1: the immediate offset added to the value of  to calculate the address.  can be omitted, meaning an offset of 0. Values are multiples of 4 in the range 0-1020."], "decode": "d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);  imm32 = Zeros(32); // Zero offset\nif d == 15 || t == 15 || n == 15 then UNPREDICTABLE;\nif d == n || d == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n] + imm32;\n    if AArch32.ExclusiveMonitorsPass(address,4) then\n        MemA[address,4] = R[t];\n        R[d] = ZeroExtend('0');\n    else\n        R[d] = ZeroExtend('1');"}, {"mnemonic": "SEVL", "short_desc": "Send Event Local", "full_desc": "Send Event Local is a hint instruction that causes an event to be signaled locally without requiring the event to be signaled to other PEs in the multiprocessor system. It can prime a wait-loop which starts with a  instruction.", "syntax": ["SEVL{<c>}{<q>}\t; A1", "SEVL{<c>}{<q>}\t; T1", "SEVL{<c>}.W\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    SendEventLocal();"}, {"mnemonic": "VFMAB, VFMAT (BFloat16, by scalar)", "short_desc": "BFloat16 floating-point widening multiply-add long (by scalar)", "full_desc": "The BFloat16 floating-point widening multiply-add long instruction widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first source vector, and an indexed element in the second source vector from Bfloat16 to single-precision format. The instruction then multiplies and adds these values to the overlapping single-precision elements of the destination vector.", "syntax": ["VFMA<bt>{<q>}.BF16 <Qd>, <Qn>, <Dm>[<index>]\t; A1", "VFMA<bt>{<q>}.BF16 <Qd>, <Qn>, <Dm>[<index>]\t; T1"], "symbols": ["<bt>\n", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm<2:0>\" field.", "<index>\nIs the element index in the range 0 to 3, encoded in the \"M:Vm<3>\" field."], "decode": "if !HaveAArch32BF16Ext() then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(Vm<2:0>);\ninteger i = UInt(M:Vm<3>);\ninteger elements = 128 DIV 32;\ninteger sel = UInt(Q);", "operation": "CheckAdvSIMDEnabled();\nbits(128) operand1 = Q[n>>1];\nbits(64) operand2 = D[m];\nbits(128) operand3 = Q[d>>1];\nbits(128) result;\n\nbits(32) element2 = Elem[operand2, i, 16] : Zeros(16);\n\nfor e = 0 to elements-1\n    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);\n    bits(32) addend = Elem[operand3, e, 32];\n    Elem[result, e, 32] = FPMulAdd(addend, element1, element2,\n                                   StandardFPSCRValue());\n\nQ[d>>1] = result;"}, {"mnemonic": "RSC, RSCS (immediate)", "short_desc": "Reverse Subtract with Carry (immediate)", "full_desc": "Reverse Subtract with Carry (immediate) subtracts a register value and the value of NOT (Carry flag) from an immediate value, and writes the result to the destination register.", "syntax": ["RSC{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; RSC", "RSCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; RSCS"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<const>\nAn immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result, nzcv) = AddWithCarry(NOT(R[n]), imm32, PSTATE.C);\n    if d == 15 then\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VRINTN (floating-point)", "short_desc": "Round floating-point to integer to Nearest", "full_desc": "Round floating-point to integer to Nearest rounds a floating-point value to an integral floating-point value of the same size using the Round to Nearest rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTN{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTN{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTN{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VRINTN{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTN{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTN{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nrounding = FPDecodeRM(RM);  exact = FALSE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\ncase esize of\n    when 16\n        S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);\n    when 32\n        S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);\n    when 64\n        D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);"}, {"mnemonic": "VABA", "short_desc": "Vector Absolute Difference and Accumulate", "full_desc": "Vector Absolute Difference and Accumulate subtracts the elements of one vector from the corresponding elements of another vector, and accumulates the absolute values of the results into the elements of the destination vector.", "syntax": ["VABA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VABA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VABA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VABA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nunsigned = (U == '1');  long_destination = FALSE;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];\n            op2 = Elem[Din[m+r],e,esize];\n            absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + absdiff;\n            else\n                Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + absdiff;"}, {"mnemonic": "VMAX (integer)", "short_desc": "Vector Maximum (integer)", "full_desc": "Vector Maximum compares corresponding elements in two vectors, and copies the larger of each pair into the corresponding element in the destination vector.", "syntax": ["VMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMAX{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMAX{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '11' then UNDEFINED;\nmaximum = (op == '0');  unsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Int(Elem[D[n+r],e,esize], unsigned);\n            op2 = Int(Elem[D[m+r],e,esize], unsigned);\n            result = if maximum then Max(op1,op2) else Min(op1,op2);\n            Elem[D[d+r],e,esize] = result<esize-1:0>;"}, {"mnemonic": "TEQ (immediate)", "short_desc": "Test Equivalence (immediate)", "full_desc": "Test Equivalence (immediate) performs a bitwise exclusive OR operation on a register value and an immediate value. It updates the condition flags based on the result, and discards the result.", "syntax": ["TEQ{<c>}{<q>} <Rn>, #<const>\t; A1", "TEQ{<c>}{<q>} <Rn>, #<const>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "n = UInt(Rn);\n(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = R[n] EOR imm32;\n    PSTATE.N = result<31>;\n    PSTATE.Z = IsZeroBit(result);\n    PSTATE.C = carry;\n    // PSTATE.V unchanged"}, {"mnemonic": "VCVTR", "short_desc": "Convert floating-point to integer", "full_desc": "Convert floating-point to integer converts a value in a register from floating-point to a 32-bit integer, using the rounding mode specified by the  and places the result in a second register.", "syntax": ["VCVTR{<c>}{<q>}.U32.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTR{<c>}{<q>}.S32.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTR{<c>}{<q>}.U32.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTR{<c>}{<q>}.S32.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTR{<c>}{<q>}.U32.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVTR{<c>}{<q>}.S32.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVTR{<c>}{<q>}.U32.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTR{<c>}{<q>}.S32.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTR{<c>}{<q>}.U32.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTR{<c>}{<q>}.S32.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTR{<c>}{<q>}.U32.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVTR{<c>}{<q>}.S32.F64 <Sd>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if opc2 != '000' && opc2 != '10x' then SEE \"Related encodings\";\nif size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nto_integer = (opc2<2> == '1');\nif to_integer then\n    unsigned = (opc2<0> == '0');\n    rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);\n    d = UInt(Vd:D);\n    case size of\n        when '01' esize = 16; m = UInt(Vm:M);\n        when '10' esize = 32; m = UInt(Vm:M);\n        when '11' esize = 64; m = UInt(M:Vm);\nelse\n    unsigned = (op == '0');\n    rounding = FPRoundingMode(FPSCR);\n    m = UInt(Vm:M);\n    case size of\n        when '01' esize = 16; d = UInt(Vd:D);\n        when '10' esize = 32; d = UInt(Vd:D);\n        when '11' esize = 64; d = UInt(D:Vd);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    if to_integer then\n        case esize of\n            when 16\n                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);\n            when 32\n                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);\n            when 64\n                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);\n    else\n        case esize of\n            when 16\n                bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);\n                S[d] = Zeros(16):fp16;\n            when 32\n                S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);\n            when 64\n                D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);"}, {"mnemonic": "USADA8", "short_desc": "Unsigned Sum of Absolute Differences and Accumulate", "full_desc": "Unsigned Sum of Absolute Differences and Accumulate performs four unsigned 8-bit subtractions, and adds the absolute values of the differences to a 32-bit accumulate operand.", "syntax": ["USADA8{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; A1", "USADA8{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<Ra>\nIs the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "if Ra == '1111' then SEE \"USAD8\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    absdiff1 = Abs(UInt(R[n]<7:0>)   - UInt(R[m]<7:0>));\n    absdiff2 = Abs(UInt(R[n]<15:8>)  - UInt(R[m]<15:8>));\n    absdiff3 = Abs(UInt(R[n]<23:16>) - UInt(R[m]<23:16>));\n    absdiff4 = Abs(UInt(R[n]<31:24>) - UInt(R[m]<31:24>));\n    result = UInt(R[a]) + absdiff1 + absdiff2 + absdiff3 + absdiff4;\n    R[d] = result<31:0>;"}, {"mnemonic": "LDRSBT", "short_desc": "Load Register Signed Byte Unprivileged", "full_desc": "Load Register Signed Byte Unprivileged loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRSBT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}\t; A1", "LDRSBT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>\t; A2", "LDRSBT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 and encoded in the \"imm8\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');\nregister_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);\nif t == 15 || n == 15 || n == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode\n    EncodingSpecificOperations();\n    offset = if register_form then R[m] else imm32;\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if postindex then R[n] else offset_addr;\n    R[t] = SignExtend(MemU_unpriv[address,1], 32);\n    if postindex then R[n] = offset_addr;"}, {"mnemonic": "VSELEQ, VSELGE, VSELGT, VSELVS", "short_desc": "Floating-point conditional select", "full_desc": "Floating-point conditional select allows the destination register to take the value in either one or the other source register according to the condition codes in the .", "syntax": ["VSELEQ.F64 <Dd>, <Dn>, <Dm>\t; VSELEQ,doubleprec", "VSELEQ.F16 <Sd>, <Sn>, <Sm>\t; VSELEQ,halfprec", "VSELEQ.F32 <Sd>, <Sn>, <Sm>\t; VSELEQ,singleprec", "VSELGE.F64 <Dd>, <Dn>, <Dm>\t; VSELGE,doubleprec", "VSELGE.F16 <Sd>, <Sn>, <Sm>\t; VSELGE,halfprec", "VSELGE.F32 <Sd>, <Sn>, <Sm>\t; VSELGE,singleprec", "VSELGT.F64 <Dd>, <Dn>, <Dm>\t; VSELGT,doubleprec", "VSELGT.F16 <Sd>, <Sn>, <Sm>\t; VSELGT,halfprec", "VSELGT.F32 <Sd>, <Sn>, <Sm>\t; VSELGT,singleprec", "VSELVS.F64 <Dd>, <Dn>, <Dm>\t; VSELVS,doubleprec", "VSELVS.F16 <Sd>, <Sn>, <Sm>\t; VSELVS,halfprec", "VSELVS.F32 <Sd>, <Sn>, <Sm>\t; VSELVS,singleprec", "VSELEQ.F64 <Dd>, <Dn>, <Dm>\t; VSELEQ,doubleprec", "VSELEQ.F16 <Sd>, <Sn>, <Sm>\t; VSELEQ,halfprec", "VSELEQ.F32 <Sd>, <Sn>, <Sm>\t; VSELEQ,singleprec", "VSELGE.F64 <Dd>, <Dn>, <Dm>\t; VSELGE,doubleprec", "VSELGE.F16 <Sd>, <Sn>, <Sm>\t; VSELGE,halfprec", "VSELGE.F32 <Sd>, <Sn>, <Sm>\t; VSELGE,singleprec", "VSELGT.F64 <Dd>, <Dn>, <Dm>\t; VSELGT,doubleprec", "VSELGT.F16 <Sd>, <Sn>, <Sm>\t; VSELGT,halfprec", "VSELGT.F32 <Sd>, <Sn>, <Sm>\t; VSELGT,singleprec", "VSELVS.F64 <Dd>, <Dn>, <Dm>\t; VSELVS,doubleprec", "VSELVS.F16 <Sd>, <Sn>, <Sm>\t; VSELVS,halfprec", "VSELVS.F32 <Sd>, <Sn>, <Sm>\t; VSELVS,singleprec"], "symbols": ["<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);\ncond = cc:(cc<1> EOR cc<0>):'0';", "operation": "EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\ncase esize of\n    when 16\n        S[d] = Zeros(16) : (if ConditionHolds(cond) then S[n] else S[m])<15:0>;\n    when 32\n        S[d] = if ConditionHolds(cond) then S[n] else S[m];\n    when 64\n        D[d] = if ConditionHolds(cond) then D[n] else D[m];"}, {"mnemonic": "BL, BLX (immediate)", "short_desc": "Branch with Link and optional Exchange (immediate)", "full_desc": "Branch with Link calls a subroutine at a PC-relative address, and setting LR to the return address.", "syntax": ["BL{<c>}{<q>} <label>\t; A1", "BLX{<c>}{<q>} <label>\t; A2", "BL{<c>}{<q>} <label>\t; T1", "BLX{<c>}{<q>} <label>\t; T2"], "symbols": ["<c>\nFor encoding A1, T1 and T2: see .", "<c>\nFor encoding A2: see .  must be  or omitted.", "<q>\nSee .", "<label>\nFor encoding A1: the label of the instruction that is to be branched to. The assembler calculates the required value of the offset from the PC value of the  instruction to this label, then selects an encoding that sets  to that offset.", "<label>\nFor encoding A2: the label of the instruction that is to be branched to. The assembler calculates the required value of the offset from the PC value of the  instruction to this label, then selects an encoding with  set to that offset.", "<label>\nFor encoding T1: the label of the instruction that is to be branched to.", "<label>\nFor encoding T2: the label of the instruction that is to be branched to."], "decode": "imm32 = SignExtend(imm24:'00', 32);  targetInstrSet = InstrSet_A32;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if CurrentInstrSet() == InstrSet_A32 then\n        LR = PC - 4;\n    else\n        LR = PC<31:1> : '1';\n    if targetInstrSet == InstrSet_A32 then\n        targetAddress = Align(PC,4) + imm32;\n    else\n        targetAddress = PC + imm32;\n    SelectInstrSet(targetInstrSet);\n    BranchWritePC(targetAddress, BranchType_DIRCALL);"}, {"mnemonic": "VCLT (register)", "short_desc": "Vector Compare Less Than", "syntax": ["VCLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field."]}, {"mnemonic": "VRSQRTE", "short_desc": "Vector Reciprocal Square Root Estimate", "full_desc": "Vector Reciprocal Square Root Estimate finds an approximate reciprocal square root of each element in a vector, and places the results in a second vector.", "syntax": ["VRSQRTE{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRSQRTE{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VRSQRTE{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRSQRTE{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\nfloating_point = (F == '1');\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if floating_point then\n                Elem[D[d+r],e,esize] = FPRSqrtEstimate(Elem[D[m+r],e,esize], StandardFPSCRValue());\n            else\n                Elem[D[d+r],e,esize] = UnsignedRSqrtEstimate(Elem[D[m+r],e,esize]);"}, {"mnemonic": "SXTB", "short_desc": "Signed Extend Byte", "full_desc": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to 32 bits, and writes the result to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.", "syntax": ["SXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; A1", "SXTB{<c>}{<q>} {<Rd>,} <Rm>\t; T1", "SXTB{<c>}.W {<Rd>,} <Rm>\t; T2", "SXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d] = SignExtend(rotated<7:0>, 32);"}, {"mnemonic": "VRSHR", "short_desc": "Vector Rounding Shift Right", "full_desc": "Vector Rounding Shift Right takes each element in a vector, right shifts them by an immediate value, and places the rounded results in the destination vector. For truncated results, see .", "syntax": ["VRSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VRSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector", "VRSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VRSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\n", "<size>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nIs an immediate value, in the range 1 to , encoded in the \"imm6\" field as  - ."], "decode": "if (L:imm6) == '0000xxx' then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\ncase L:imm6 of\n    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);\n    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);\n    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);\n    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);\nunsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    round_const = 1 << (shift_amount - 1);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;\n            Elem[D[d+r],e,esize] = result<esize-1:0>;"}, {"mnemonic": "SMC", "short_desc": "Secure Monitor Call", "full_desc": "Secure Monitor Call causes a Secure Monitor Call exception.  For more information see .", "syntax": ["SMC{<c>}{<q>} {#}<imm4>\t; A1", "SMC{<c>}{<q>} {#}<imm4>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<imm4>\nIs a 4-bit unsigned immediate value, in the range 0 to 15, encoded in the \"imm4\" field. This is ignored by the PE. The Secure Monitor Call exception handler (Secure Monitor code) can use this value to determine what service is being requested, but Arm does not recommend this."], "decode": "// imm4 is for assembly/disassembly only and is ignored by hardware", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n\n    AArch32.CheckForSMCUndefOrTrap();\n\n    if !ELUsingAArch32(EL3) then\n        if SCR_EL3.SMD == '1' then\n            // SMC disabled.\n            UNDEFINED;\n    else\n        if SCR.SCD == '1' then\n            // SMC disabled\n            if IsSecure() then\n                // Executes either as a NOP or UNALLOCATED.\n                c = ConstrainUnpredictable(Unpredictable_SMD);\n                assert c IN {Constraint_NOP, Constraint_UNDEF};\n                if c == Constraint_NOP then EndOfInstruction();\n            UNDEFINED;\n\n    if !ELUsingAArch32(EL3) then\n        AArch64.CallSecureMonitor(Zeros(16));\n    else\n        AArch32.TakeSMCException();"}, {"mnemonic": "VQSUB", "short_desc": "Vector Saturating Subtract", "full_desc": "Vector Saturating Subtract subtracts the elements of the second operand vector from the corresponding elements of the first operand vector, and places the results in the destination vector. Signed and unsigned operations are distinct.", "syntax": ["VQSUB{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VQSUB{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VQSUB{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VQSUB{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            diff = Int(Elem[D[n+r],e,esize], unsigned) - Int(Elem[D[m+r],e,esize], unsigned);\n            (Elem[D[d+r],e,esize], sat) = SatQ(diff, esize, unsigned);\n            if sat then FPSCR.QC = '1';"}, {"mnemonic": "VMOV (general-purpose register to scalar)", "short_desc": "Copy a general-purpose register to a vector element", "full_desc": "Copy a general-purpose register to a vector element copies a byte, halfword, or word from a general-purpose register into an Advanced SIMD scalar.", "syntax": ["VMOV{<c>}{<q>}{.<size>} <Dd[x]>, <Rt>\t; A1", "VMOV{<c>}{<q>}{.<size>} <Dd[x]>, <Rt>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<size>\nThe data size. It must be one of:", "<Dd[x]>\nThe scalar. The register  is encoded in D:Vd. For details of how  is encoded, see the description of .", "<Rt>\nThe source general-purpose register."], "decode": "case opc1:opc2 of\n    when '1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);\n    when '0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);\n    when '0x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);\n    when '0x10'  UNDEFINED;\nd = UInt(D:Vd);  t = UInt(Rt);\nif t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    Elem[D[d],index,esize] = R[t]<esize-1:0>;"}, {"mnemonic": "VMMLA", "short_desc": "BFloat16 floating-point matrix multiply-accumulate", "full_desc": "BFloat16 floating-point matrix multiply-accumulate. This instruction multiplies the 2x4 matrix of BF16 values in the first 128-bit source vector by the 4x2 BF16 matrix in the second 128-bit source vector. The resulting 2x2 single-precision matrix product is then added destructively to the 2x2 single-precision matrix in the 128-bit destination vector. This is equivalent to performing a 4-way dot product per destination element. The instruction does not update the  exception status.", "syntax": ["VMMLA{<q>}.BF16 <Qd>, <Qn>, <Qm>\t; A1", "VMMLA{<q>}.BF16 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAArch32BF16Ext() then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(M:Vm);\ninteger regs = 2;", "operation": "CheckAdvSIMDEnabled();\n\nbits(128) op1 = Q[n>>1];\nbits(128) op2 = Q[m>>1];\nbits(128) acc = Q[d>>1];\n\nQ[d>>1] = BFMatMulAdd(acc, op1, op2);"}, {"mnemonic": "SADD8", "short_desc": "Signed Add 8", "full_desc": "Signed Add 8 performs four 8-bit signed integer additions, and writes the results to the destination register. It sets .GE according to the results of the additions.", "syntax": ["SADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);\n    sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);\n    sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);\n    sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);\n    R[d]<7:0>   = sum1<7:0>;\n    R[d]<15:8>  = sum2<7:0>;\n    R[d]<23:16> = sum3<7:0>;\n    R[d]<31:24> = sum4<7:0>;\n    PSTATE.GE<0>  = if sum1 >= 0 then '1' else '0';\n    PSTATE.GE<1>  = if sum2 >= 0 then '1' else '0';\n    PSTATE.GE<2>  = if sum3 >= 0 then '1' else '0';\n    PSTATE.GE<3>  = if sum4 >= 0 then '1' else '0';"}, {"mnemonic": "ADR", "short_desc": "Form PC-relative address", "full_desc": "Form PC-relative address adds an immediate value to the PC value to form a PC-relative address, and writes the result to the destination register.", "syntax": ["ADR{<c>}{<q>} <Rd>, <label>\t; A1", "ADR{<c>}{<q>} <Rd>, <label>\t; A2", "ADR{<c>}{<q>} <Rd>, <label>\t; T1", "ADR{<c>}{<q>} <Rd>, <label>\t; T2", "ADR{<c>}.W <Rd>, <label>\t; T3", "ADR{<c>}{<q>} <Rd>, <label>\t; T3"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1 and A2: is the general-purpose destination register, encoded in the \"Rd\" field. If the PC is used, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see .", "<Rd>\nFor encoding T1, T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<label>\nFor encoding A1 and A2: the label of an instruction or literal data item whose address is to be loaded into . The assembler calculates the required value of the offset from the  value of the  instruction to this label.", "<label>\nFor encoding T1: the label of an instruction or literal data item whose address is to be loaded into . The assembler calculates the required value of the offset from the  value of the  instruction to this label. Permitted values of the size of the offset are multiples of 4 in the range 0 to 1020.", "<label>\nFor encoding T2 and T3: the label of an instruction or literal data item whose address is to be loaded into . The assembler calculates the required value of the offset from the  value of the  instruction to this label."], "decode": "d = UInt(Rd);  imm32 = A32ExpandImm(imm12);  add = TRUE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);\n    if d == 15 then          // Can only occur for A32 encodings\n        ALUWritePC(result);\n    else\n        R[d] = result;"}, {"mnemonic": "SBC, SBCS (register-shifted register)", "short_desc": "Subtract with Carry (register-shifted register)", "full_desc": "Subtract with Carry (register-shifted register) subtracts a register-shifted register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.", "syntax": ["SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);\n    R[d] = result;\n    if setflags then\n        PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VCGE (register)", "short_desc": "Vector Compare Greater Than or Equal", "full_desc": "Vector Compare Greater Than or Equal takes each element in a vector, and compares it with the corresponding element of a second vector. If the first is greater than or equal to the second, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VCGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '11' then UNDEFINED;\nvtype = if U == '1' then VCGEtype_unsigned else VCGEtype_signed;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "enumeration VCGEtype {VCGEtype_signed, VCGEtype_unsigned, VCGEtype_fp};\n\nif ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];\n            case vtype of\n                when VCGEtype_signed    test_passed = (SInt(op1) >= SInt(op2));\n                when VCGEtype_unsigned  test_passed = (UInt(op1) >= UInt(op2));\n                when VCGEtype_fp        test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "VCVTB", "short_desc": "Convert to or from a half-precision value in the bottom half of a single-precision register", "full_desc": "Convert to or from a half-precision value in the bottom half of a single-precision register does one of the following:", "syntax": ["VCVTB{<c>}{<q>}.F32.F16 <Sd>, <Sm>\t; Half-precision to single-precision", "VCVTB{<c>}{<q>}.F64.F16 <Dd>, <Sm>\t; Half-precision to double-precision", "VCVTB{<c>}{<q>}.F16.F32 <Sd>, <Sm>\t; Single-precision to half-precision", "VCVTB{<c>}{<q>}.F16.F64 <Sd>, <Dm>\t; Double-precision to half-precision", "VCVTB{<c>}{<q>}.F32.F16 <Sd>, <Sm>\t; Half-precision to single-precision", "VCVTB{<c>}{<q>}.F64.F16 <Dd>, <Sm>\t; Half-precision to double-precision", "VCVTB{<c>}{<q>}.F16.F32 <Sd>, <Sm>\t; Single-precision to half-precision", "VCVTB{<c>}{<q>}.F16.F64 <Sd>, <Dm>\t; Double-precision to half-precision"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "uses_double = (sz == '1'); convert_from_half = (op == '0');\nlowbit = (if T == '1' then 16 else 0);\nif uses_double then\n    if convert_from_half then\n        d = UInt(D:Vd); m = UInt(Vm:M);\n    else\n        d = UInt(Vd:D); m = UInt(M:Vm);\nelse\n    d = UInt(Vd:D); m = UInt(Vm:M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\n    bits(16) hp;\n    if convert_from_half then\n        hp = S[m]<lowbit+15:lowbit>;\n        if uses_double then\n            D[d] = FPConvert(hp, FPSCR);\n        else\n            S[d] = FPConvert(hp, FPSCR);\n    else\n        if uses_double then\n            hp = FPConvert(D[m], FPSCR);\n        else\n            hp = FPConvert(S[m], FPSCR);\n        S[d]<lowbit+15:lowbit> = hp;"}, {"mnemonic": "VQDMULH", "short_desc": "Vector Saturating Doubling Multiply Returning High Half", "full_desc": "Vector Saturating Doubling Multiply Returning High Half multiplies corresponding elements in two vectors, doubles the results, and places the most significant half of the final results in the destination vector. The results are truncated, for rounded results see .", "syntax": ["VQDMULH{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VQDMULH{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VQDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VQDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]>\t; 128-bit SIMD vector", "VQDMULH{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VQDMULH{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VQDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VQDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm[x]>\nIs the 64-bit name of the second SIMD&FP source register holding the scalar. If  is ,  is restricted to D0-D7.  is encoded in \"Vm<2:0>\", and  is encoded in \"M:Vm<3>\". If  is ,  is restricted to D0-D15.  is encoded in \"Vm\", and  is encoded in \"M\".", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '00' || size == '11' then UNDEFINED;\nscalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    if scalar_form then op2 = SInt(Elem[D[m],index,esize]);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);\n            op1 = SInt(Elem[D[n+r],e,esize]);\n            // The following only saturates if both op1 and op2 equal -(2^(esize-1))\n            (result, sat) = SignedSatQ((2*op1*op2) >> esize, esize);\n            Elem[D[d+r],e,esize] = result;\n            if sat then FPSCR.QC = '1';"}, {"mnemonic": "STC", "short_desc": "Store data to System register", "full_desc": "Store data to System register calculates an address from a base register value and an immediate offset, and stores a word from the  System register to memory. It can use offset, post-indexed, pre-indexed, or unindexed addressing. For information about memory accesses see .", "syntax": ["STC{<c>}{<q>} p14, c5, [<Rn>{, #{+/-}<imm>}]\t; Offset", "STC{<c>}{<q>} p14, c5, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STC{<c>}{<q>} p14, c5, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "STC{<c>}{<q>} p14, c5, [<Rn>], <option>\t; Unindexed", "STC{<c>}{<q>} p14, c5, [<Rn>{, #{+/-}<imm>}]\t; Offset", "STC{<c>}{<q>} p14, c5, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STC{<c>}{<q>} p14, c5, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "STC{<c>}{<q>} p14, c5, [<Rn>], <option>\t; Unindexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nFor the offset or unindexed variant: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor the offset, post-indexed or pre-indexed variant: is the general-purpose base register, encoded in the \"Rn\" field.", "<option>\nIs an 8-bit immediate, in the range 0 to 255 enclosed in { }, encoded in the \"imm8\" field. The value of this field is ignored when executing this instruction.", "+/-\n", "<imm>\nIs the immediate offset used for forming the address, a multiple of 4 in the range 0-1020, defaulting to 0 and encoded in the \"imm8\" field, as <imm>/4."], "decode": "if P == '0' && U == '0' && W == '0' then UNDEFINED;\nn = UInt(Rn);  cp = 14;\nimm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');\nif n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n    address = if index then offset_addr else R[n];\n\n    // System register read from DBGDTRRXint.\n    MemA[address,4] = DBGDTR_EL0[];\n\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "VST4 (multiple 4-element structures)", "short_desc": "Store multiple 4-element structures from four registers", "full_desc": "Store multiple 4-element structures from four registers stores multiple 4-element structures to memory from four registers, with interleaving. For more information, see . Every element of each register is saved. For details of the addressing mode see .", "syntax": ["VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then UNDEFINED;\ncase itype of\n    when '0000'\n        inc = 1;\n    when '0001'\n        inc = 2;\n    otherwise\n        SEE \"Related encodings\";\nalignment = if align == '00' then 1 else 4 << UInt(align);\nebytes = 1 << UInt(size);  elements = 8 DIV ebytes;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d4 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = TRUE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    for e = 0 to elements-1\n        MemU[address,         ebytes] = Elem[D[d], e];\n        MemU[address+ebytes,  ebytes] = Elem[D[d2],e];\n        MemU[address+2*ebytes,ebytes] = Elem[D[d3],e];\n        MemU[address+3*ebytes,ebytes] = Elem[D[d4],e];\n        address = address + 4*ebytes;\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 32;"}, {"mnemonic": "VMOVX", "short_desc": "Vector Move extraction", "full_desc": "Vector Move extraction. This instruction copies the upper 16 bits of the 32-bit source SIMD&FP register into the lower 16 bits of the 32-bit destination SIMD&FP register, while clearing the remaining bits to zero.", "syntax": ["VMOVX{<q>}.F16 <Sd>, <Sm>\t; A1", "VMOVX{<q>}.F16 <Sd>, <Sm>\t; T1"], "symbols": ["<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\nif FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\nd = UInt(Vd:D); m = UInt(Vm:M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    S[d] = Zeros(16) : S[m]<31:16>;"}, {"mnemonic": "VPMAX (integer)", "short_desc": "Vector Pairwise Maximum (integer)", "full_desc": "Vector Pairwise Maximum compares adjacent pairs of elements in two doubleword vectors, and copies the larger of each pair into the corresponding element in the destination doubleword vector.", "syntax": ["VPMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; A1", "VPMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nmaximum = (op == '0');  unsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    bits(64) dest;\n    h = elements DIV 2;\n\n    for e = 0 to h-1\n        op1 = Int(Elem[D[n],2*e,esize], unsigned);\n        op2 = Int(Elem[D[n],2*e+1,esize], unsigned);\n        result = if maximum then Max(op1,op2) else Min(op1,op2);\n        Elem[dest,e,esize] = result<esize-1:0>;\n        op1 = Int(Elem[D[m],2*e,esize], unsigned);\n        op2 = Int(Elem[D[m],2*e+1,esize], unsigned);\n        result = if maximum then Max(op1,op2) else Min(op1,op2);\n        Elem[dest,e+h,esize] = result<esize-1:0>;\n\n    D[d] = dest;"}, {"mnemonic": "MVN, MVNS (immediate)", "short_desc": "Bitwise NOT (immediate)", "full_desc": "Bitwise NOT (immediate) writes the bitwise inverse of an immediate value to the destination register.", "syntax": ["MVN{<c>}{<q>} <Rd>, #<const>\t; MVN", "MVNS{<c>}{<q>} <Rd>, #<const>\t; MVNS", "MVN{<c>}{<q>} <Rd>, #<const>\t; MVN", "MVNS{<c>}{<q>} <Rd>, #<const>\t; MVNS"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  setflags = (S == '1');\n(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = NOT(imm32);\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "LSR (immediate)", "short_desc": "Logical Shift Right (immediate)", "full_desc": "Logical Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value", "LSR<c>{<q>} {<Rd>,} <Rm>, #<imm>\t; T2", "LSR<c>.W {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value", "LSR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see .", "<Rd>\nFor encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.", "<imm>\nFor encoding A1 and T2: is the shift amount, in the range 1 to 32, encoded in the \"imm5\" field as <imm> modulo 32.", "<imm>\nFor encoding T3: is the shift amount, in the range 1 to 32, encoded in the \"imm3:imm2\" field as <imm> modulo 32."]}, {"mnemonic": "SMLALD, SMLALDX", "short_desc": "Signed Multiply Accumulate Long Dual", "full_desc": "Signed Multiply Accumulate Long Dual performs two signed 16 x 16-bit multiplications. It adds the products to a 64-bit accumulate operand.", "syntax": ["SMLALD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALD", "SMLALDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALDX", "SMLALD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALD", "SMLALDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALDX"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<RdLo>\nIs the general-purpose source register holding the lower 32 bits of the addend, and the destination register for the lower 32 bits of the result, encoded in the \"RdLo\" field.", "<RdHi>\nIs the general-purpose source register holding the upper 32 bits of the addend, and the destination register for the upper 32 bits of the result, encoded in the \"RdHi\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');\nif dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif dHi == dLo then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand2 = if m_swap then ROR(R[m],16) else R[m];\n    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);\n    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);\n    result = product1 + product2 + SInt(R[dHi]:R[dLo]);\n    R[dHi] = result<63:32>;\n    R[dLo] = result<31:0>;"}, {"mnemonic": "VBIF", "short_desc": "Vector Bitwise Insert if False", "full_desc": "Vector Bitwise Insert if False inserts each bit from the first source register into the destination register if the corresponding bit of the second source register is 0, otherwise leaves the bit in the destination register unchanged.", "syntax": ["VBIF{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VBIF{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VBIF{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VBIF{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif op == '00' then SEE \"VEOR\";\nif op == '01' then operation = VBitOps_VBSL;\nif op == '10' then operation = VBitOps_VBIT;\nif op == '11' then operation = VBitOps_VBIF;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL};\n\nif ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        case operation of\n            when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));\n            when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));\n            when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));"}, {"mnemonic": "VTBL, VTBX", "short_desc": "Vector Table Lookup and Extension", "full_desc": "Vector Table Lookup uses byte indexes in a control vector to look up byte values in a table and generate a new vector. Indexes out of range return 0.", "syntax": ["VTBL{<c>}{<q>}.8 <Dd>, <list>, <Dm>\t; VTBL", "VTBX{<c>}{<q>}.8 <Dd>, <list>, <Dm>\t; VTBX", "VTBL{<c>}{<q>}.8 <Dd>, <list>, <Dm>\t; VTBL", "VTBX{<c>}{<q>}.8 <Dd>, <list>, <Dm>\t; VTBX"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<list>\nThe vectors containing the table. It must be one of:", "<Dm>\nIs the 64-bit name of the SIMD&FP source register holding the indices, encoded in the \"M:Vm\" field."], "decode": "is_vtbl = (op == '0');  length = UInt(len)+1;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);\nif n+length > 32 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n\n    // Create 256-bit = 32-byte table variable, with zeros in entries that will not be used.\n    table3 = if length == 4 then D[n+3] else Zeros(64);\n    table2 = if length >= 3 then D[n+2] else Zeros(64);\n    table1 = if length >= 2 then D[n+1] else Zeros(64);\n    table = table3 : table2 : table1 : D[n];\n\n    for i = 0 to 7\n        index = UInt(Elem[D[m],i,8]);\n        if index < 8*length then\n            Elem[D[d],i,8] = Elem[table,index,8];\n        else\n            if is_vtbl then\n                Elem[D[d],i,8] = Zeros(8);\n            // else Elem[D[d],i,8] unchanged"}, {"mnemonic": "USAT16", "short_desc": "Unsigned Saturate 16", "full_desc": "Unsigned Saturate 16 saturates two signed 16-bit values to a selected unsigned range.", "syntax": ["USAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>\t; A1", "USAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<imm>\nIs the bit position for saturation, in the range 0 to 15, encoded in the \"sat_imm\" field.", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);\nif d == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result1, sat1) = UnsignedSatQ(SInt(R[n]<15:0>), saturate_to);\n    (result2, sat2) = UnsignedSatQ(SInt(R[n]<31:16>), saturate_to);\n    R[d]<15:0> = ZeroExtend(result1, 16);\n    R[d]<31:16> = ZeroExtend(result2, 16);\n    if sat1 || sat2 then\n        PSTATE.Q = '1';"}, {"mnemonic": "SMMUL, SMMULR", "short_desc": "Signed Most Significant Word Multiply", "full_desc": "Signed Most Significant Word Multiply multiplies two signed 32-bit values, extracts the most significant 32 bits of the result, and writes those bits to the destination register.", "syntax": ["SMMUL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMMUL", "SMMULR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMMULR", "SMMUL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMMUL", "SMMULR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMMULR"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  round = (R == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = SInt(R[n]) * SInt(R[m]);\n    if round then result = result + 0x80000000;\n    R[d] = result<63:32>;"}, {"mnemonic": "VLD2 (multiple 2-element structures)", "short_desc": "Load multiple 2-element structures to two or four registers", "full_desc": "Load multiple 2-element structures to two or four registers loads multiple 2-element structures from memory into two or four registers, with de-interleaving. For more information, see .  Every element of each register is loaded. For details of the addressing mode see .", "syntax": ["VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "regs = 1;  if align == '11' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninc = if itype == '1001' then 2 else 1;\nalignment = if align == '00' then 1 else 4 << UInt(align);\nebytes = 1 << UInt(size);  elements = 8 DIV ebytes;\nd = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d2+regs > 32 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r], e] = MemU[address,ebytes];\n            Elem[D[d2+r],e] = MemU[address+ebytes,ebytes];\n            address = address + 2*ebytes;\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 16*regs;"}, {"mnemonic": "VREV32", "short_desc": "Vector Reverse in words", "full_desc": "Vector Reverse in words reverses the order of 8-bit or 16-bit elements in each word of the vector, and places the result in the corresponding destination vector.", "syntax": ["VREV32{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VREV32{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VREV32{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VREV32{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if UInt(op)+UInt(size) >= 3 then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\n\nesize = 8 << UInt(size);\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\ninteger containers = 64 DIV container_size;\ninteger elements_per_container = container_size DIV esize;\n\nd = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n\n    bits(64) result;\n    integer element;\n    integer rev_element;\n    for r = 0 to regs-1\n        element = 0;\n        for c = 0 to containers-1\n            rev_element = element + elements_per_container - 1;\n            for e = 0 to elements_per_container-1\n                Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];\n                element = element + 1;\n                rev_element = rev_element - 1;\n        D[d+r] = result;"}, {"mnemonic": "UQSUB8", "short_desc": "Unsigned Saturating Subtract 8", "full_desc": "Unsigned Saturating Subtract 8 performs four unsigned 8-bit integer subtractions, saturates the results to the 8-bit unsigned integer range 0 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["UQSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UQSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);\n    diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);\n    diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);\n    diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);\n    R[d]<7:0>   = UnsignedSat(diff1, 8);\n    R[d]<15:8>  = UnsignedSat(diff2, 8);\n    R[d]<23:16> = UnsignedSat(diff3, 8);\n    R[d]<31:24> = UnsignedSat(diff4, 8);"}, {"mnemonic": "VLDR (immediate)", "short_desc": "Load SIMD&FP register (immediate)", "full_desc": "Load SIMD&FP register (immediate) loads a single register from the Advanced SIMD and floating-point register file, using an address from a general-purpose register, with an optional offset.", "syntax": ["VLDR{<c>}{<q>}.16 <Sd>, [<Rn> {, #{+/-}<imm>}]\t; Half-precision scalar", "VLDR{<c>}{<q>}{.32} <Sd>, [<Rn> {, #{+/-}<imm>}]\t; Single-precision scalar", "VLDR{<c>}{<q>}{.64} <Dd>, [<Rn> {, #{+/-}<imm>}]\t; Double-precision scalar", "VLDR{<c>}{<q>}.16 <Sd>, [<Rn> {, #{+/-}<imm>}]\t; Half-precision scalar", "VLDR{<c>}{<q>}{.32} <Sd>, [<Rn> {, #{+/-}<imm>}]\t; Single-precision scalar", "VLDR{<c>}{<q>}{.64} <Dd>, [<Rn> {, #{+/-}<imm>}]\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", ".64\nIs an optional data size specifier for 64-bit memory accesses that can be used in the assembler source code, but is otherwise ignored.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", ".32\nIs an optional data size specifier for 32-bit memory accesses that can be used in the assembler source code, but is otherwise ignored.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "<imm>\nFor the single-precision scalar or double-precision scalar variants: is the optional unsigned immediate byte offset, a multiple of 4, in the range 0 to 1020, defaulting to 0, and encoded in the \"imm8\" field as <imm>/4."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nesize = 8 << UInt(size);  add = (U == '1');\nimm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);\ncase size of\n    when '01' d = UInt(Vd:D);\n    when '10' d = UInt(Vd:D);\n    when '11' d = UInt(D:Vd);\nn = UInt(Rn);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    base = if n == 15 then Align(PC,4) else R[n];\n    address = if add then (base + imm32) else (base - imm32);\n    case esize of\n        when 16\n            S[d] = Zeros(16) : MemA[address,2];\n        when 32\n            S[d] = MemA[address,4];\n        when 64\n            word1 = MemA[address,4];  word2 = MemA[address+4,4];\n            // Combine the word-aligned words in the correct order for current endianness.\n            D[d] = if BigEndian() then word1:word2 else word2:word1;"}, {"mnemonic": "VABDL (integer)", "short_desc": "Vector Absolute Difference Long (integer)", "full_desc": "Vector Absolute Difference Long (integer) subtracts the elements of one vector from the corresponding elements of another vector, and places the absolute values of the results in the elements of the destination vector.", "syntax": ["VABDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; A1", "VABDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vd<0> == '1' then UNDEFINED;\nunsigned = (U == '1');  long_destination = TRUE;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];\n            op2 = Elem[Din[m+r],e,esize];\n            absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = absdiff<2*esize-1:0>;\n            else\n                Elem[D[d+r],e,esize] = absdiff<esize-1:0>;"}, {"mnemonic": "VADDW", "short_desc": "Vector Add Wide", "full_desc": "Vector Add Wide adds corresponding elements in one quadword and one doubleword vector, and places the results in a quadword vector. Before adding, it sign-extends or zero-extends the elements of the doubleword operand.", "syntax": ["VADDW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>\t; A1", "VADDW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        if is_vaddw then\n            op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);\n        else\n            op1 = Int(Elem[Din[n],e,esize], unsigned);\n        result = op1 + Int(Elem[Din[m],e,esize],unsigned);\n        Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;"}, {"mnemonic": "VMLS (integer)", "short_desc": "Vector Multiply Subtract (integer)", "full_desc": "Vector Multiply Subtract multiplies corresponding elements in two vectors, and subtracts the products from the corresponding elements of the destination vector.", "syntax": ["VMLS{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMLS{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMLS{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMLS{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\nThe data type for the elements of the operands. It must be one of:", "<size>\nThe data size for the elements of the operands. It must be one of:", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nadd = (op == '0');  long_destination = FALSE;\nunsigned = FALSE;  // \"Don't care\" value: TRUE produces same functionality\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);\n            addend = if add then product else -product;\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;\n            else\n                Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;"}, {"mnemonic": "VRINTR", "short_desc": "Round floating-point to integer", "full_desc": "Round floating-point to integer rounds a floating-point value to an integral floating-point value of the same size using the rounding mode specified in the FPSCR. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTR{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTR{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTR{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VRINTR{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTR{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTR{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nrounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);\nexact = FALSE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\n    case esize of\n        when 16\n            S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);\n        when 32\n            S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);\n        when 64\n            D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);"}, {"mnemonic": "BXJ", "short_desc": "Branch and Exchange, previously Branch and Exchange Jazelle", "full_desc": "Branch and Exchange, previously Branch and Exchange Jazelle.", "syntax": ["BXJ{<c>}{<q>} <Rm>\t; A1", "BXJ{<c>}{<q>} <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rm>\nIs the general-purpose register holding the address to be branched to, encoded in the \"Rm\" field."], "decode": "m = UInt(Rm);\nif m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    BXWritePC(R[m], BranchType_INDIR);"}, {"mnemonic": "VQRDMLAH", "short_desc": "Vector Saturating Rounding Doubling Multiply Accumulate Returning High Half", "full_desc": "Vector Saturating Rounding Doubling Multiply Accumulate Returning High Half. This instruction multiplies the vector elements of the first source SIMD&FP register with either the corresponding vector elements of the second source SIMD&FP register or the value of a vector element of the second source SIMD&FP register, without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.", "syntax": ["VQRDMLAH{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VQRDMLAH{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VQRDMLAH{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VQRDMLAH{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>\t; 128-bit SIMD vector", "VQRDMLAH{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VQRDMLAH{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VQRDMLAH{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VQRDMLAH{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm[x]>\nIs the 64-bit name of the second SIMD&FP source register holding the scalar. If  is ,  is restricted to D0-D7.  is encoded in \"Vm<2:0>\", and  is encoded in \"M:Vm<3>\". If  is ,  is restricted to D0-D15.  is encoded in \"Vm\", and  is encoded in \"M\".", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if !HaveQRDMLAHExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '00' || size == '11' then UNDEFINED;\nadd = TRUE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations();  CheckAdvSIMDEnabled();\nround_const = 1 << (esize-1);\nif scalar_form then op2 = SInt(Elem[D[m],index,esize]);\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        op1 = SInt(Elem[D[n+r],e,esize]);\n        op3 = SInt(Elem[D[d+r],e,esize]) << esize;\n        if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);\n        (result, sat) = SignedSatQ((op3 + 2*(op1*op2) + round_const) >> esize, esize);\n        Elem[D[d+r],e,esize] = result;\n        if sat then FPSCR.QC = '1';"}, {"mnemonic": "VFMAL (vector)", "short_desc": "Vector Floating-point Multiply-Add Long to accumulator (vector)", "full_desc": "Vector Floating-point Multiply-Add Long to accumulator (vector). This instruction multiplies corresponding values in the vectors in the two source SIMD&FP registers, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.", "syntax": ["VFMAL{<q>}.F16 <Dd>, <Sn>, <Sm>\t; 64-bit SIMD vector", "VFMAL{<q>}.F16 <Qd>, <Dn>, <Dm>\t; 128-bit SIMD vector", "VFMAL{<q>}.F16 <Dd>, <Sn>, <Sm>\t; 64-bit SIMD vector", "VFMAL{<q>}.F16 <Qd>, <Dn>, <Dm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;\nif Q == '1' && Vd<0> == '1' then UNDEFINED;\n\ninteger d = UInt(D:Vd);\ninteger n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);\ninteger m = if Q == '1' then UInt(M:Vm) else UInt(Vm:M);\ninteger esize = 32;\ninteger regs = if Q=='1' then 2 else 1;\ninteger datasize = if Q=='1' then 64 else 32;\nboolean sub_op = S=='1';", "operation": "CheckAdvSIMDEnabled();\nbits(datasize) operand1 ;\nbits(datasize) operand2 ;\nbits(64) operand3;\nbits(64) result;\nbits(esize DIV 2) element1;\nbits(esize DIV 2) element2;\n\nif Q=='0' then\n    operand1 = S[n]<datasize-1:0>;\n    operand2 = S[m]<datasize-1:0>;\nelse\n    operand1 = D[n]<datasize-1:0>;\n    operand2 = D[m]<datasize-1:0>;\nfor r = 0 to regs-1\n    operand3 = D[d+r];\n    for e = 0 to 1\n        element1 = Elem[operand1, 2*r+e, esize DIV 2];\n        element2 = Elem[operand2, 2*r+e, esize DIV 2];\n        if sub_op then element1 = FPNeg(element1);\n        Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());\n    D[d+r] = result;"}, {"mnemonic": "VDIV", "short_desc": "Divide", "full_desc": "Divide divides one floating-point value by another floating-point value and writes the result to a third floating-point register.", "syntax": ["VDIV{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VDIV{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VDIV{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar", "VDIV{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VDIV{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VDIV{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\nif size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    case esize of\n        when 16\n            S[d] = Zeros(16) : FPDiv(S[n]<15:0>, S[m]<15:0>, FPSCR);\n        when 32\n            S[d] = FPDiv(S[n], S[m], FPSCR);\n        when 64\n            D[d] = FPDiv(D[n], D[m], FPSCR);"}, {"mnemonic": "ORN, ORNS (immediate)", "short_desc": "Bitwise OR NOT (immediate)", "full_desc": "Bitwise OR NOT (immediate) performs a bitwise (inclusive) OR of a register value and the complement of an immediate value, and writes the result to the destination register. It can optionally update the condition flags based on the result.", "syntax": ["ORNS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; Flag setting", "ORN{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nAn immediate value. See  for the range of values."], "decode": "if Rn == '1111' then SEE \"MVN (immediate)\";\nd = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');\n(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);\nif d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = R[n] OR NOT(imm32);\n    R[d] = result;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result);\n        PSTATE.C = carry;\n        // PSTATE.V unchanged"}, {"mnemonic": "VCNT", "short_desc": "Vector Count Set Bits", "full_desc": "Vector Count Set Bits counts the number of bits that are one in each element in a vector, and places the results in a second vector.", "syntax": ["VCNT{<c>}{<q>}.8 <Dd>, <Dm>\t; 64-bit SIMD vector", "VCNT{<c>}{<q>}.8 <Qd>, <Qm>\t; 128-bit SIMD vector", "VCNT{<c>}{<q>}.8 <Dd>, <Dm>\t; 64-bit SIMD vector", "VCNT{<c>}{<q>}.8 <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size != '00' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nesize = 8;  elements = 8;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = BitCount(Elem[D[m+r],e,esize])<esize-1:0>;"}, {"mnemonic": "VMLAL (integer)", "short_desc": "Vector Multiply Accumulate Long (integer)", "full_desc": "Vector Multiply Accumulate Long multiplies corresponding elements in two vectors, and add the products to the corresponding element of the destination vector. The destination vector element is twice as long as the elements that are multiplied.", "syntax": ["VMLAL{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm>\t; A1", "VMLAL{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\nThe data type for the elements of the operands. It must be one of:", "<size>\nThe data size for the elements of the operands. It must be one of:", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vd<0> == '1' then UNDEFINED;\nadd = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);\n            addend = if add then product else -product;\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;\n            else\n                Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;"}, {"mnemonic": "LDRSB (register)", "short_desc": "Load Register Signed Byte (register)", "full_desc": "Load Register Signed Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. The offset register value can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see .", "syntax": ["LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]\t; Offset", "LDRSB{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>\t; Post-indexed", "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!\t; Pre-indexed", "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]\t; T1", "LDRSB{<c>}.W <Rt>, [<Rn>, {+}<Rm>]\t; T2", "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant.", "<Rn>\nFor encoding T1 and T2: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<imm>\nIf present, the size of the left shift to apply to the value from , in the range 1-3.  is encoded in imm2. If absent, no shift is specified and imm2 is encoded as ."], "decode": "if P == '0' && W == '1' then SEE \"LDRSBT\";\nt = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\n(shift_t, shift_n) = (SRType_LSL, 0);\nif t == 15 || m == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if index then offset_addr else R[n];\n    R[t] = SignExtend(MemU[address,1], 32);\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "VMOVN", "short_desc": "Vector Move and Narrow", "full_desc": "Vector Move and Narrow copies the least significant half of each element of a quadword vector into the corresponding elements of a doubleword vector.", "syntax": ["VMOVN{<c>}{<q>}.<dt> <Dd>, <Qm>\t; A1", "VMOVN{<c>}{<q>}.<dt> <Dd>, <Qm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if size == '11' then UNDEFINED;\nif Vm<0> == '1' then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        Elem[D[d],e,esize] = Elem[Qin[m>>1],e,2*esize]<esize-1:0>;"}, {"mnemonic": "SETPAN", "short_desc": "Set Privileged Access Never", "full_desc": "Set Privileged Access Never writes a new value to .PAN.", "syntax": ["SETPAN{<q>} #<imm>\t; A1", "SETPAN{<q>} #<imm>\t; T1"], "symbols": ["<q>\nSee .", "<imm>\nIs the unsigned immediate 0 or 1, encoded in the \"imm1\" field."], "decode": "if !HavePANExt() then UNDEFINED;\nvalue = imm1;", "operation": "EncodingSpecificOperations();\nif PSTATE.EL != EL0 then\n    PSTATE.PAN = value;"}, {"mnemonic": "VQDMLAL", "short_desc": "Vector Saturating Doubling Multiply Accumulate Long", "full_desc": "Vector Saturating Doubling Multiply Accumulate Long multiplies corresponding elements in two doubleword vectors, doubles the products, and accumulates the results into the elements of a quadword vector.", "syntax": ["VQDMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; A1", "VQDMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]\t; A2", "VQDMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; T1", "VQDMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]\t; T2"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nFor encoding A1 and T1: is the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dm>\nFor encoding A2 and T2: is the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm<2:0>\" field when  is S16, otherwise the \"Vm\" field.", "<index>\nIs the element index in the range 0 to 3, encoded in the \"M:Vm<3>\" field when  is S16, otherwise in range 0 to 1, encoded in the \"M\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif size == '00' || Vd<0> == '1' then UNDEFINED;\nadd = (op == '0');\nscalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);\nesize = 8 << UInt(size);  elements = 64 DIV esize;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);\n    for e = 0 to elements-1\n        if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);\n        op1 = SInt(Elem[Din[n],e,esize]);\n        // The following only saturates if both op1 and op2 equal -(2^(esize-1))\n        (product, sat1) = SignedSatQ(2*op1*op2, 2*esize);\n        if add then\n            result = SInt(Elem[Qin[d>>1],e,2*esize]) + SInt(product);\n        else\n            result = SInt(Elem[Qin[d>>1],e,2*esize]) - SInt(product);\n        (Elem[Q[d>>1],e,2*esize], sat2) = SignedSatQ(result, 2*esize);\n        if sat1 || sat2 then FPSCR.QC = '1';"}, {"mnemonic": "QDADD", "short_desc": "Saturating Double and Add", "full_desc": "Saturating Double and Add adds a doubled register value to another register value, and writes the result to the destination register. Both the doubling and the addition have their results saturated to the 32-bit signed integer range -2 <= x <= 2 - 1. If saturation occurs in either operation, it sets .Q to 1.", "syntax": ["QDADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>\t; A1", "QDADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the second general-purpose source register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);\n    (R[d], sat2)  = SignedSatQ(SInt(R[m]) + SInt(doubled), 32);\n    if sat1 || sat2 then\n        PSTATE.Q = '1';"}, {"mnemonic": "VACLT", "short_desc": "Vector Absolute Compare Less Than", "syntax": ["VACLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VACLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VACLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VACLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field."]}, {"mnemonic": "REVSH", "short_desc": "Byte-Reverse Signed Halfword", "full_desc": "Byte-Reverse Signed Halfword reverses the byte order in the lower 16-bit halfword of a 32-bit register, and sign-extends the result to 32 bits.", "syntax": ["REVSH{<c>}{<q>} <Rd>, <Rm>\t; A1", "REVSH{<c>}{<q>} <Rd>, <Rm>\t; T1", "REVSH{<c>}.W <Rd>, <Rm>\t; T2", "REVSH{<c>}{<q>} <Rd>, <Rm>\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1 and T1: is the general-purpose source register, encoded in the \"Rm\" field.", "<Rm>\nFor encoding T2: is the general-purpose source register, encoded in the \"Rm\" field. It must be encoded with an identical value in the \"Rn\" field."], "decode": "d = UInt(Rd);  m = UInt(Rm);\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    bits(32) result;\n    result<31:8>  = SignExtend(R[m]<7:0>, 24);\n    result<7:0>   = R[m]<15:8>;\n    R[d] = result;"}, {"mnemonic": "PLD, PLDW (register)", "short_desc": "Preload Data (register)", "full_desc": "Preload Data (register) signals the memory system that data memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into the data cache.", "syntax": ["PLD{<c>}{<q>} [<Rn>, {+/-}<Rm> {, <shift> #<amount>}]\t; Preload read, optional shift or rotate", "PLD{<c>}{<q>} [<Rn>, {+/-}<Rm> , RRX]\t; Preload read, rotate right with extend", "PLDW{<c>}{<q>} [<Rn>, {+/-}<Rm> {, <shift> #<amount>}]\t; Preload write, optional shift or rotate", "PLDW{<c>}{<q>} [<Rn>, {+/-}<Rm> , RRX]\t; Preload write, rotate right with extend", "PLD{<c>}{<q>} [<Rn>, {+}<Rm> {, LSL #<amount>}]\t; Preload read", "PLDW{<c>}{<q>} [<Rn>, {+}<Rm> {, LSL #<amount>}]\t; Preload write"], "symbols": ["<c>\nFor encoding A1: see .  must be  or omitted.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used.", "<Rn>\nFor encoding T1: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T1: is the shift amount, in the range 0 to 3, defaulting to 0 and encoded in the \"imm2\" field."], "decode": "n = UInt(Rn);  m = UInt(Rm);  add = (U == '1');  is_pldw = (R == '0');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);\nif m == 15 || (n == 15 && is_pldw) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    address = if add then (R[n] + offset) else (R[n] - offset);\n    if is_pldw then\n        Hint_PreloadDataForWrite(address);\n    else\n        Hint_PreloadData(address);"}, {"mnemonic": "VDUP (general-purpose register)", "short_desc": "Duplicate general-purpose register to vector", "full_desc": "Duplicate general-purpose register to vector duplicates an element from a general-purpose register into every element of the destination vector.", "syntax": ["VDUP{<c>}{<q>}.<size> <Qd>, <Rt>\t; A1", "VDUP{<c>}{<q>}.<size> <Dd>, <Rt>\t; A1", "VDUP{<c>}{<q>}.<size> <Qd>, <Rt>\t; T1", "VDUP{<c>}{<q>}.<size> <Dd>, <Rt>\t; T1"], "symbols": ["<c>\nSee . Arm strongly recommends that any  instruction is unconditional, see .", "<q>\nSee .", "<size>\nThe data size for the elements of the destination vector. It must be one of:", "<Qd>\nThe destination vector for a quadword operation.", "<Dd>\nThe destination vector for a doubleword operation.", "<Rt>\nThe Arm source register."], "decode": "if Q == '1' && Vd<0> == '1' then UNDEFINED;\nd = UInt(D:Vd);  t = UInt(Rt);  regs = if Q == '0' then 1 else 2;\ncase B:E of\n    when '00'  esize = 32;  elements = 2;\n    when '01'  esize = 16;  elements = 4;\n    when '10'  esize = 8;   elements = 8;\n    when '11'  UNDEFINED;\nif t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    scalar = R[t]<esize-1:0>;\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = scalar;"}, {"mnemonic": "ASRS (register)", "short_desc": "Arithmetic Shift Right, setting flags (register)", "syntax": ["ASRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Flag setting", "ASRS{<q>} {<Rdm>,} <Rdm>, <Rs>\t; Arithmetic shift right", "ASRS.W {<Rd>,} <Rm>, <Rs>\t; Flag setting", "ASRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rs>\nIs the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."]}, {"mnemonic": "EOR, EORS (register)", "short_desc": "Bitwise Exclusive OR (register)", "full_desc": "Bitwise Exclusive OR (register) performs a bitwise Exclusive OR of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; EOR, rotate right with extend", "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; EOR, shift or rotate by value", "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; EORS, rotate right with extend", "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; EORS, shift or rotate by value", "EOR<c>{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "EORS{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; EOR, rotate right with extend", "EOR<c>.W {<Rd>,} <Rn>, <Rm>\t; EOR, shift or rotate by value", "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; EOR, shift or rotate by value", "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; EORS, rotate right with extend", "EORS.W {<Rd>,} <Rn>, <Rm>\t; EORS, shift or rotate by value", "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; EORS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdn>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] EOR shifted;\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "CRC32C", "short_desc": "CRC32C", "full_desc": "performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, or 32 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial  is used for the CRC calculation.", "syntax": ["CRC32CB{<q>} <Rd>, <Rn>, <Rm>\t; CRC32CB", "CRC32CH{<q>} <Rd>, <Rn>, <Rm>\t; CRC32CH", "CRC32CW{<q>} <Rd>, <Rn>, <Rm>\t; CRC32CW", "CRC32CB{<q>} <Rd>, <Rn>, <Rm>\t; CRC32CB", "CRC32CH{<q>} <Rd>, <Rn>, <Rm>\t; CRC32CH", "CRC32CW{<q>} <Rd>, <Rn>, <Rm>\t; CRC32CW"], "symbols": ["<q>\nSee . An  instruction must be unconditional.", "<Rd>\nIs the general-purpose accumulator output register, encoded in the \"Rd\" field.", "<Rn>\nIs the general-purpose accumulator input register, encoded in the \"Rn\" field.", "<Rm>\nIs the general-purpose data source register, encoded in the \"Rm\" field."], "decode": "if ! HaveCRCExt() then UNDEFINED;\nd = UInt(Rd); n = UInt(Rn); m = UInt(Rm);\nsize = 8 << UInt(sz);\ncrc32c = (C == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif size == 64 then UNPREDICTABLE;\nif cond != '1110' then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n\n    acc = R[n];             // accumulator\n    val = R[m]<size-1:0>;   // input value\n    poly = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\n    tempacc = BitReverse(acc):Zeros(size);\n    tempval = BitReverse(val):Zeros(32);\n    // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation\n    R[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"}, {"mnemonic": "VQSHL, VQSHLU (immediate)", "short_desc": "Vector Saturating Shift Left (immediate)", "full_desc": "Vector Saturating Shift Left (immediate) takes each element in a vector of integers, left shifts them by an immediate value, and places the results in a second vector.", "syntax": ["VQSHL{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; VQSHL,double,signed-result", "VQSHL{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; VQSHL,quad,signed-result", "VQSHLU{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; VQSHLU,double,unsigned-result", "VQSHLU{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; VQSHLU,quad,unsigned-result", "VQSHL{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; VQSHL,double,signed-result", "VQSHL{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; VQSHL,quad,signed-result", "VQSHLU{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; VQSHLU,double,unsigned-result", "VQSHLU{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; VQSHLU,quad,unsigned-result"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\n", "<size>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nIs an immediate value, in the range 0 to -1, encoded in the \"imm6\" field."], "decode": "if (L:imm6) == '0000xxx' then SEE \"Related encodings\";\nif U == '0' && op == '0' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\ncase L:imm6 of\n    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;\n    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;\n    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;\n    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);\nsrc_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            operand = Int(Elem[D[m+r],e,esize], src_unsigned);\n            (result, sat) = SatQ(operand << shift_amount, esize, dest_unsigned);\n            Elem[D[d+r],e,esize] = result;\n            if sat then FPSCR.QC = '1';"}, {"mnemonic": "VCMLA (by element)", "short_desc": "Vector Complex Multiply Accumulate (by element)", "full_desc": "Vector Complex Multiply Accumulate (by element).", "syntax": ["VCMLA{<q>}.F16 <Dd>, <Dn>, <Dm>[<index>], #<rotate>\t; 64-bit SIMD vector of half-precision floating-point", "VCMLA{<q>}.F32 <Dd>, <Dn>, <Dm>[0], #<rotate>\t; 64-bit SIMD vector of single-precision floating-point", "VCMLA{<q>}.F16 <Qd>, <Qn>, <Dm>[<index>], #<rotate>\t; 128-bit SIMD vector of half-precision floating-point", "VCMLA{<q>}.F32 <Qd>, <Qn>, <Dm>[0], #<rotate>\t; 128-bit SIMD vector of single-precision floating-point", "VCMLA{<q>}.F16 <Dd>, <Dn>, <Dm>[<index>], #<rotate>\t; 64-bit SIMD vector of half-precision floating-point", "VCMLA{<q>}.F32 <Dd>, <Dn>, <Dm>[0], #<rotate>\t; 64-bit SIMD vector of single-precision floating-point", "VCMLA{<q>}.F16 <Qd>, <Qn>, <Dm>[<index>], #<rotate>\t; 128-bit SIMD vector of half-precision floating-point", "VCMLA{<q>}.F32 <Qd>, <Qn>, <Dm>[0], #<rotate>\t; 128-bit SIMD vector of single-precision floating-point"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nFor the half-precision scalar variant: is the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm\" field.", "<Dm>\nFor the single-precision scalar variant: is the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<index>\nIs the element index in the range 0 to 1, encoded in the \"M\" field.", "<rotate>\n"], "decode": "if !HaveFCADDExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn);\nm = if S=='1' then UInt(M:Vm) else UInt(Vm);\nesize = 16 << UInt(S);\nif !HaveFP16Ext() && esize == 16 then UNDEFINED;\nelements = 64 DIV esize;\nregs = if Q == '0' then 1 else 2;\nindex = if S=='1' then 0 else UInt(M);", "operation": "EncodingSpecificOperations();\nCheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    operand1 = D[n+r];\n    operand2 = Din[m];\n    operand3 = D[d+r];\n    for e = 0 to (elements DIV 2)-1\n        case rot of\n            when '00'\n                element1 = Elem[operand2,index*2,esize];\n                element2 = Elem[operand1,e*2,esize];\n                element3 = Elem[operand2,index*2+1,esize];\n                element4 = Elem[operand1,e*2,esize];\n            when '01'\n                element1 = FPNeg(Elem[operand2,index*2+1,esize]);\n                element2 = Elem[operand1,e*2+1,esize];\n                element3 = Elem[operand2,index*2,esize];\n                element4 = Elem[operand1,e*2+1,esize];\n            when '10'\n                element1 = FPNeg(Elem[operand2,index*2,esize]);\n                element2 = Elem[operand1,e*2,esize];\n                element3 = FPNeg(Elem[operand2,index*2+1,esize]);\n                element4 = Elem[operand1,e*2,esize];\n            when '11'\n                element1 = Elem[operand2,index*2+1,esize];\n                element2 = Elem[operand1,e*2+1,esize];\n                element3 = FPNeg(Elem[operand2,index*2,esize]);\n                element4 = Elem[operand1,e*2+1,esize];\n        result1 = FPMulAdd(Elem[operand3,e*2,esize],element2,element1, StandardFPSCRValue());\n        result2 = FPMulAdd(Elem[operand3,e*2+1,esize],element4,element3,StandardFPSCRValue());\n        Elem[D[d+r],e*2,esize] = result1;\n        Elem[D[d+r],e*2+1,esize] = result2;"}, {"mnemonic": "LSL (immediate)", "short_desc": "Logical Shift Left (immediate)", "full_desc": "Logical Shift Left (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSL{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value", "LSL<c>{<q>} {<Rd>,} <Rm>, #<imm>\t; T2", "LSL<c>.W {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value", "LSL{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see .", "<Rd>\nFor encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.", "<imm>\nFor encoding A1: is the shift amount, in the range 0 to 31, encoded in the \"imm5\" field as <imm> modulo 32.", "<imm>\nFor encoding T2: is the shift amount, in the range 1 to 31, encoded in the \"imm5\" field as <amount> modulo 32.", "<imm>\nFor encoding T3: is the shift amount, in the range 0 to 31,  encoded in the \"imm3:imm2\" field as <imm> modulo 32."]}, {"mnemonic": "VSUB (integer)", "short_desc": "Vector Subtract (integer)", "full_desc": "Vector Subtract (integer) subtracts the elements of one vector from the corresponding elements of another vector, and places the results in the destination vector.", "syntax": ["VSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] - Elem[D[m+r],e,esize];"}, {"mnemonic": "VEOR", "short_desc": "Vector Bitwise Exclusive OR", "full_desc": "Vector Bitwise Exclusive OR performs a bitwise Exclusive OR operation between two registers, and places the result in the destination register. The operand and result registers can be quadword or doubleword. They must all be the same size.", "syntax": ["VEOR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VEOR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VEOR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VEOR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        D[d+r] = D[n+r] EOR D[m+r];"}, {"mnemonic": "VBIT", "short_desc": "Vector Bitwise Insert if True", "full_desc": "Vector Bitwise Insert if True inserts each bit from the first source register into the destination register if the corresponding bit of the second source register is 1, otherwise leaves the bit in the destination register unchanged.", "syntax": ["VBIT{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VBIT{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VBIT{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VBIT{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif op == '00' then SEE \"VEOR\";\nif op == '01' then operation = VBitOps_VBSL;\nif op == '10' then operation = VBitOps_VBIT;\nif op == '11' then operation = VBitOps_VBIF;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL};\n\nif ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        case operation of\n            when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));\n            when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));\n            when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));"}, {"mnemonic": "STR (immediate)", "short_desc": "Store Register (immediate)", "full_desc": "Store Register (immediate) calculates an address from a base register value and an immediate offset, and stores a word from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about memory accesses see .", "syntax": ["STR{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "STR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "STR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1", "STR{<c>}{<q>} <Rt>, [SP{, #{+}<imm>}]\t; T2", "STR{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]\t; T3", "STR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T3", "STR{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]\t; Offset", "STR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, but this is deprecated.", "<Rt>\nFor encoding T1, T2, T3 and T4: is the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant, but this is deprecated.", "<Rn>\nFor encoding T1, T3 and T4: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is the optional positive unsigned immediate byte offset, a multiple of 4, in the range 0 to 124, defaulting to 0 and encoded in the \"imm5\" field as <imm>/4.", "<imm>\nFor encoding T2: is the optional positive unsigned immediate byte offset, a multiple of 4, in the range 0 to 1020, defaulting to 0 and encoded in the \"imm8\" field as <imm>/4.", "<imm>\nFor encoding T3: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T4: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field."], "decode": "if P == '0' && W == '1' then SEE \"STRT\";\nt = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        MemU[address,4] = if t == 15 then PCStoreValue() else R[t];\n        if wback then R[n] = offset_addr;\nelse\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        MemU[address,4] = R[t];\n        if wback then R[n] = offset_addr;"}, {"mnemonic": "ISB", "short_desc": "Instruction Synchronization Barrier", "full_desc": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a context synchronization event. For more information, see .", "syntax": ["ISB{<c>}{<q>} {<option>}\t; A1", "ISB{<c>}{<q>} {<option>}\t; T1"], "symbols": ["<c>\nFor encoding A1: see . Must be  or omitted.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<option>\nSpecifies an optional limitation on the barrier operation. Values are:"], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    InstructionSynchronizationBarrier();"}, {"mnemonic": "VCGT (immediate #0)", "short_desc": "Vector Compare Greater Than Zero", "full_desc": "Vector Compare Greater Than Zero takes each element in a vector, and compares it with zero.  If it is greater than zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VCGT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nfloating_point = (F == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if floating_point then\n                bits(esize) zero = FPZero('0');\n                test_passed = FPCompareGT(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());\n            else\n                test_passed = (SInt(Elem[D[m+r],e,esize]) > 0);\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "VSDOT (vector)", "short_desc": "Dot Product vector form with signed integers.", "full_desc": "Dot Product vector form with signed integers. This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["VSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VSDOT{<q>}.S8 <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VSDOT{<q>}.S8 <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if !HaveDOTPExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nboolean signed = U=='0';\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(M:Vm);\ninteger esize = 32;\ninteger regs = if Q == '1' then 2 else 1;", "operation": "bits(64) operand1;\nbits(64) operand2;\nbits(64) result;\nCheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    operand1 = D[n+r];\n    operand2 = D[m+r];\n    result = D[d+r];\n    integer element1, element2;\n    for e = 0 to 1\n        integer res = 0;\n        for i = 0 to 3\n            if signed then\n                element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n                element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n            else\n                element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n                element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n            res = res + element1 * element2;\n        Elem[result, e, esize] = Elem[result, e, esize] + res;\n    D[d+r] = result;"}, {"mnemonic": "UHADD8", "short_desc": "Unsigned Halving Add 8", "full_desc": "Unsigned Halving Add 8 performs four unsigned 8-bit integer additions, halves the results, and writes the results to the destination register.", "syntax": ["UHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);\n    sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);\n    sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);\n    sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);\n    R[d]<7:0>   = sum1<8:1>;\n    R[d]<15:8>  = sum2<8:1>;\n    R[d]<23:16> = sum3<8:1>;\n    R[d]<31:24> = sum4<8:1>;"}, {"mnemonic": "VSUBHN", "short_desc": "Vector Subtract and Narrow, returning High Half", "full_desc": "Vector Subtract and Narrow, returning High Half subtracts the elements of one quadword vector from the corresponding elements of another quadword vector, takes the most significant half of each result, and places the final results in a doubleword vector. The results are truncated. For rounded results, see .", "syntax": ["VSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>\t; A1", "VSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize];\n        Elem[D[d],e,esize] = result<2*esize-1:esize>;"}, {"mnemonic": "VMOV (between two general-purpose registers and a doubleword floating-point register)", "short_desc": "Copy two general-purpose registers to or from a SIMD&FP register", "full_desc": "Copy two general-purpose registers to or from a SIMD&FP register copies two words from two general-purpose registers into a doubleword register in the Advanced SIMD and floating-point register file, or from a doubleword register in the Advanced SIMD and floating-point register file to two general-purpose registers.", "syntax": ["VMOV{<c>}{<q>} <Dm>, <Rt>, <Rt2>\t; From general-purpose registers", "VMOV{<c>}{<q>} <Rt>, <Rt2>, <Dm>\t; To general-purpose registers", "VMOV{<c>}{<q>} <Dm>, <Rt>, <Rt2>\t; From general-purpose registers", "VMOV{<c>}{<q>} <Rt>, <Rt2>, <Dm>\t; To general-purpose registers"], "symbols": ["<Dm>\nIs the 64-bit name of the SIMD&FP register to be transferred, encoded in the \"M:Vm\" field.", "<Rt2>\nIs the second general-purpose register that [63:32] will be transferred to or from, encoded in the \"Rt2\" field.", "<Rt>\nIs the first general-purpose register that [31:0] will be transferred to or from, encoded in the \"Rt\" field.", "<c>\nSee .", "<q>\nSee ."], "decode": "to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(M:Vm);\nif t == 15 || t2 == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13\nif to_arm_registers && t == t2 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    if to_arm_registers then\n        R[t] = D[m]<31:0>;\n        R[t2] = D[m]<63:32>;\n    else\n        D[m]<31:0> = R[t];\n        D[m]<63:32> = R[t2];"}, {"mnemonic": "MCRR", "short_desc": "Move to System register from two general-purpose registers", "full_desc": "Move to System register from two general-purpose registers. This instruction copies the values of two general-purpose registers to a System register.", "syntax": ["MCRR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>\t; A1", "MCRR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<coproc>\n", "<opc1>\nIs the opc1 parameter within the System register encoding space, in the range 0 to 15, encoded in the \"opc1\" field.", "<Rt>\nIs the first general-purpose register that is transferred into, encoded in the \"Rt\" field.", "<Rt2>\nIs the second general-purpose register that is transferred into, encoded in the \"Rt2\" field.", "<CRm>\nIs the CRm parameter within the System register encoding space, in the range c0 to c15, encoded in the \"CRm\" field."], "decode": "t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;\nif t == 15 || t2 == 15 then UNPREDICTABLE;\n// Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    value = R[t2]:R[t];\n    AArch32.SysRegWrite64(cp, ThisInstr(), value);"}, {"mnemonic": "QADD16", "short_desc": "Saturating Add 16", "full_desc": "Saturating Add 16 performs two 16-bit integer additions, saturates the results to the 16-bit signed integer range -2 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["QADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "QADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);\n    sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);\n    R[d]<15:0>  = SignedSat(sum1, 16);\n    R[d]<31:16> = SignedSat(sum2, 16);"}, {"mnemonic": "VMOV (between general-purpose register and single-precision)", "short_desc": "Copy a general-purpose register to or from a 32-bit SIMD&FP register", "full_desc": "Copy a general-purpose register to or from a 32-bit SIMD&FP register. This instruction transfers the value held in a 32-bit SIMD&FP register to a general-purpose register, or the value held in a general-purpose register to a 32-bit SIMD&FP register.", "syntax": ["VMOV{<c>}{<q>} <Sn>, <Rt>\t; From general-purpose register", "VMOV{<c>}{<q>} <Rt>, <Sn>\t; To general-purpose register", "VMOV{<c>}{<q>} <Sn>, <Rt>\t; From general-purpose register", "VMOV{<c>}{<q>} <Rt>, <Sn>\t; To general-purpose register"], "symbols": ["<Rt>\nIs the general-purpose register that  will be transferred to or from, encoded in the \"Rt\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Vn:N\" field.", "<c>\nSee .", "<q>\nSee ."], "decode": "to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);\nif t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    if to_arm_register then\n        R[t] = S[n];\n    else\n        S[n] = R[t];"}, {"mnemonic": "LDREX", "short_desc": "Load Register Exclusive", "full_desc": "Load Register Exclusive calculates an address from a base register value and an immediate offset, loads a word from memory, writes it to a register and:", "syntax": ["LDREX{<c>}{<q>} <Rt>, [<Rn> {, {#}<imm>}]\t; A1", "LDREX{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<imm>\nFor encoding A1: the immediate offset added to the value of  to calculate the address.  can only be 0 or omitted.", "<imm>\nFor encoding T1: the immediate offset added to the value of  to calculate the address.  can be omitted, meaning an offset of 0. Values are multiples of 4 in the range 0-1020."], "decode": "t = UInt(Rt);  n = UInt(Rn);  imm32 = Zeros(32); // Zero offset\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n] + imm32;\n    AArch32.SetExclusiveMonitors(address,4);\n    R[t] = MemA[address,4];"}, {"mnemonic": "VLDR (literal)", "short_desc": "Load SIMD&FP register (literal)", "full_desc": "Load SIMD&FP register (literal) loads a single register from the Advanced SIMD and floating-point register file, using an address from the PC value and an immediate offset.", "syntax": ["VLDR{<c>}{<q>}.16 <Sd>, <label>\t; Half-precision scalar", "VLDR{<c>}{<q>}.16 <Sd>, [PC, #{+/-}<imm>]\t; Half-precision scalar", "VLDR{<c>}{<q>}{.32} <Sd>, <label>\t; Single-precision scalar", "VLDR{<c>}{<q>}{.32} <Sd>, [PC, #{+/-}<imm>]\t; Single-precision scalar", "VLDR{<c>}{<q>}{.64} <Dd>, <label>\t; Double-precision scalar", "VLDR{<c>}{<q>}{.64} <Dd>, [PC, #{+/-}<imm>]\t; Double-precision scalar", "VLDR{<c>}{<q>}.16 <Sd>, <label>\t; Half-precision scalar", "VLDR{<c>}{<q>}.16 <Sd>, [PC, #{+/-}<imm>]\t; Half-precision scalar", "VLDR{<c>}{<q>}{.32} <Sd>, <label>\t; Single-precision scalar", "VLDR{<c>}{<q>}{.32} <Sd>, [PC, #{+/-}<imm>]\t; Single-precision scalar", "VLDR{<c>}{<q>}{.64} <Dd>, <label>\t; Double-precision scalar", "VLDR{<c>}{<q>}{.64} <Dd>, [PC, #{+/-}<imm>]\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", ".64\nIs an optional data size specifier for 64-bit memory accesses that can be used in the assembler source code, but is otherwise ignored.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", ".32\nIs an optional data size specifier for 32-bit memory accesses that can be used in the assembler source code, but is otherwise ignored.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<label>\nThe label of the literal data item to be loaded.", "+/-\n", "<imm>\nFor the single-precision scalar or double-precision scalar variants: is the optional unsigned immediate byte offset, a multiple of 4, in the range 0 to 1020, defaulting to 0, and encoded in the \"imm8\" field as <imm>/4."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nesize = 8 << UInt(size);  add = (U == '1');\nimm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);\ncase size of\n    when '01' d = UInt(Vd:D);\n    when '10' d = UInt(Vd:D);\n    when '11' d = UInt(D:Vd);\nn = UInt(Rn);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    base = if n == 15 then Align(PC,4) else R[n];\n    address = if add then (base + imm32) else (base - imm32);\n    case esize of\n        when 16\n            S[d] = Zeros(16) : MemA[address,2];\n        when 32\n            S[d] = MemA[address,4];\n        when 64\n            word1 = MemA[address,4];  word2 = MemA[address+4,4];\n            // Combine the word-aligned words in the correct order for current endianness.\n            D[d] = if BigEndian() then word1:word2 else word2:word1;"}, {"mnemonic": "VMOV (register)", "short_desc": "Copy between FP registers", "full_desc": "Copy between FP registers copies the contents of one FP register to another.", "syntax": ["VMOV{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VMOV{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VMOV{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VMOV{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\nsingle_register = (size == '10');  advsimd = FALSE;\nif single_register then\n    d = UInt(Vd:D);  m = UInt(Vm:M);\nelse\n    d = UInt(D:Vd);  m = UInt(M:Vm);  regs = 1;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if single_register then\n        S[d] = S[m];\n    else\n        for r = 0 to regs-1\n            D[d+r] = D[m+r];"}, {"mnemonic": "AND, ANDS (immediate)", "short_desc": "Bitwise AND (immediate)", "full_desc": "Bitwise AND (immediate) performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register.", "syntax": ["AND{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; AND", "ANDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ANDS", "AND{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; AND", "ANDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ANDS"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');\n(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = R[n] AND imm32;\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "FLDM*X (FLDMDBX, FLDMIAX)", "short_desc": "FLDM*X", "full_desc": "FLDMDBX is the Decrement Before variant of this instruction, and FLDMIAX is the Increment After variant. FLDM*X loads multiple SIMD&FP registers from consecutive locations in the Advanced SIMD and floating-point register file using an address from a general-purpose register.", "syntax": ["FLDMDBX{<c>}{<q>} <Rn>!, <dreglist>\t; Decrement Before", "FLDMIAX{<c>}{<q>} <Rn>{!}, <dreglist>\t; Increment After", "FLDMDBX{<c>}{<q>} <Rn>!, <dreglist>\t; Decrement Before", "FLDMIAX{<c>}{<q>} <Rn>{!}, <dreglist>\t; Increment After"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. If writeback is not specified, the PC can be used.", "!\nSpecifies base register writeback. Encoded in the \"W\" field as 1 if present, otherwise 0.", "<dreglist>\nIs the list of consecutively numbered 64-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"D:Vd\", and \"imm8\" is set to twice the number of registers in the list plus one. The list must contain at least one register, all registers must be in the range D0-D15, and must not contain more than 16 registers."], "decode": "if P == '0' && U == '0' && W == '0' then SEE \"Related encodings\";\nif P == '1' && W == '0' then SEE \"VLDR\";\nif P == U && W == '1' then UNDEFINED;\n// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)\nsingle_regs = FALSE;  add = (U == '1');  wback = (W == '1');\nd = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);\nregs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see \"FLDM*X\".\nif n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;\nif regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;\nif imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    address = if add then R[n] else R[n]-imm32;\n    for r = 0 to regs-1\n        if single_regs then\n            S[d+r] = MemA[address,4];  address = address+4;\n        else\n            word1 = MemA[address,4];  word2 = MemA[address+4,4];  address = address+8;\n            // Combine the word-aligned words in the correct order for current endianness.\n            D[d+r] = if BigEndian() then word1:word2 else word2:word1;\n    if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;"}, {"mnemonic": "VQRDMULH", "short_desc": "Vector Saturating Rounding Doubling Multiply Returning High Half", "full_desc": "Vector Saturating Rounding Doubling Multiply Returning High Half multiplies corresponding elements in two vectors, doubles the results, and places the most significant half of the final results in the destination vector. The results are rounded. For truncated results see .", "syntax": ["VQRDMULH{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VQRDMULH{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VQRDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VQRDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]>\t; 128-bit SIMD vector", "VQRDMULH{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VQRDMULH{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VQRDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VQRDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm[x]>\nIs the 64-bit name of the second SIMD&FP source register holding the scalar. If  is ,  is restricted to D0-D7.  is encoded in \"Vm<2:0>\", and  is encoded in \"M:Vm<3>\". If  is ,  is restricted to D0-D15.  is encoded in \"Vm\", and  is encoded in \"M\".", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '00' || size == '11' then UNDEFINED;\nscalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    round_const = 1 << (esize-1);\n    if scalar_form then op2 = SInt(Elem[D[m],index,esize]);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = SInt(Elem[D[n+r],e,esize]);\n            if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);\n            (result, sat) = SignedSatQ((2*op1*op2 + round_const) >> esize, esize);\n            Elem[D[d+r],e,esize] = result;\n            if sat then FPSCR.QC = '1';"}, {"mnemonic": "USAX", "short_desc": "Unsigned Subtract and Add with Exchange", "full_desc": "Unsigned Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one unsigned 16-bit integer subtraction and one unsigned 16-bit addition, and writes the results to the destination register. It sets .GE according to the results.", "syntax": ["USAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "USAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum  = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);\n    diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);\n    R[d]<15:0>  = sum<15:0>;\n    R[d]<31:16> = diff<15:0>;\n    PSTATE.GE<1:0> = if sum  >= 0x10000 then '11' else '00';\n    PSTATE.GE<3:2> = if diff >= 0 then '11' else '00';"}, {"mnemonic": "VUSMMLA", "short_desc": "Widening 8-bit mixed integer matrix multiply-accumulate into 2x2 matrix", "full_desc": "The widening integer matrix multiply-accumulate instruction multiplies the 2x8 matrix of unsigned 8-bit integer values held in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator held in the destination vector. This is equivalent to performing an 8-way dot product per destination element.", "syntax": ["VUSMMLA{<q>}.S8 <Qd>, <Qn>, <Qm>\t; A1", "VUSMMLA{<q>}.S8 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP third source and destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAArch32Int8MatMulExt() then UNDEFINED;\ncase B:U of\n    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;\n    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;\n    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;\n    when '11' UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(M:Vm);", "operation": "CheckAdvSIMDEnabled();\nbits(128) operand1 = Q[n>>1];\nbits(128) operand2 = Q[m>>1];\nbits(128) addend   = Q[d>>1];\n\nQ[d>>1] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);"}, {"mnemonic": "VMIN (floating-point)", "short_desc": "Vector Minimum (floating-point)", "full_desc": "Vector Minimum compares corresponding elements in two vectors, and copies the smaller of each pair into the corresponding element in the destination vector.", "syntax": ["VMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMIN{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMIN{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nmaximum = (op == '0');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];\n            if maximum then\n                Elem[D[d+r],e,esize] = FPMax(op1, op2, StandardFPSCRValue());\n            else\n                Elem[D[d+r],e,esize] = FPMin(op1, op2, StandardFPSCRValue());"}, {"mnemonic": "VBIC (register)", "short_desc": "Vector Bitwise Bit Clear (register)", "full_desc": "Vector Bitwise Bit Clear (register) performs a bitwise AND between a register value and the complement of a register value, and places the result in the destination register.", "syntax": ["VBIC{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VBIC{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VBIC{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VBIC{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        D[d+r] = D[n+r] AND NOT(D[m+r]);"}, {"mnemonic": "ADD, ADDS (register-shifted register)", "short_desc": "Add (register-shifted register)", "full_desc": "Add (register-shifted register) adds a register value and a register-shifted register value. It writes the result to the destination register, and can optionally update the condition flags based on the result.", "syntax": ["ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], shifted, '0');\n    R[d] = result;\n    if setflags then\n        PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "DBG", "short_desc": "Debug hint", "full_desc": "In Armv8,  executes as a . Arm deprecates any use of the  instruction.", "syntax": ["DBG{<c>}{<q>} #<option>\t; A1", "DBG{<c>}{<q>} #<option>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<option>\nIs a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"option\" field."], "decode": "// DBG executes as a NOP. The 'option' field is ignored", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();"}, {"mnemonic": "VQADD", "short_desc": "Vector Saturating Add", "full_desc": "Vector Saturating Add adds the values of corresponding elements of two vectors, and places the results in the destination vector.", "syntax": ["VQADD{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VQADD{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VQADD{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VQADD{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            sum = Int(Elem[D[n+r],e,esize], unsigned) + Int(Elem[D[m+r],e,esize], unsigned);\n            (Elem[D[d+r],e,esize], sat) = SatQ(sum, esize, unsigned);\n            if sat then FPSCR.QC = '1';"}, {"mnemonic": "MRC", "short_desc": "Move to general-purpose register from System register", "full_desc": "Move to general-purpose register from System register. This instruction copies the value of a System register to a general-purpose register.", "syntax": ["MRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}\t; A1", "MRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<coproc>\n", "<opc1>\nIs the opc1 parameter within the System register encoding space, in the range 0 to7, encoded in the \"opc1\" field.", "<Rt>\nIs the general-purpose register to be transferred or  (encoded as ), encoded in the \"Rt\" field. If  is used, bits [31:28] of the transferred value are written to the  condition flags.", "<CRn>\nIs the CRn parameter within the System register encoding space, in the range c0 to c15, encoded in the \"CRn\" field.", "<CRm>\nIs the CRm parameter within the System register encoding space, in the range c0 to c15, encoded in the \"CRm\" field.", "<opc2>\nIs the opc2 parameter within the System register encoding space, in the range 0 to7, encoded in the \"opc2\" field."], "decode": "t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;\n// Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    bits(32) value = AArch32.SysRegRead(cp, ThisInstr());\n    if t != 15 then\n        R[t] = value;\n    elsif AArch32.SysRegReadCanWriteAPSR(cp, ThisInstr()) then\n        PSTATE.<N,Z,C,V> = value<31:28>;\n        // value<27:0> are not used.\n    else\n        UNPREDICTABLE;"}, {"mnemonic": "VBSL", "short_desc": "Vector Bitwise Select", "full_desc": "Vector Bitwise Select sets each bit in the destination to the corresponding bit from the first source operand when the original destination bit was 1, otherwise from the second source operand.", "syntax": ["VBSL{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VBSL{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VBSL{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VBSL{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif op == '00' then SEE \"VEOR\";\nif op == '01' then operation = VBitOps_VBSL;\nif op == '10' then operation = VBitOps_VBIT;\nif op == '11' then operation = VBitOps_VBIF;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL};\n\nif ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        case operation of\n            when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));\n            when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));\n            when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));"}, {"mnemonic": "VDUP (scalar)", "short_desc": "Duplicate vector element to vector", "full_desc": "Duplicate vector element to vector duplicates a single element of a vector into every element of the destination vector.", "syntax": ["VDUP{<c>}{<q>}.<size> <Dd>, <Dm[x]>\t; ", "VDUP{<c>}{<q>}.<size> <Qd>, <Dm[x]>\t; ", "VDUP{<c>}{<q>}.<size> <Dd>, <Dm[x]>\t; ", "VDUP{<c>}{<q>}.<size> <Qd>, <Dm[x]>\t; "], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\nThe data size. It must be one of:", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm[x]>\nThe scalar. For details of how  is encoded, see the description of ."], "decode": "if imm4 == 'x000' then UNDEFINED;\nif Q == '1' && Vd<0> == '1' then UNDEFINED;\ncase imm4 of\n    when 'xxx1'  esize = 8;  elements = 8;  index = UInt(imm4<3:1>);\n    when 'xx10'  esize = 16;  elements = 4;  index = UInt(imm4<3:2>);\n    when 'x100'  esize = 32;  elements = 2;  index = UInt(imm4<3>);\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    scalar = Elem[D[m],index,esize];\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = scalar;"}, {"mnemonic": "VDOT (by element)", "short_desc": "BFloat16 floating-point indexed dot product (vector, by element)", "full_desc": "BFloat16 floating-point indexed dot product (vector, by element). This instruction delimits the source vectors into pairs of 16-bit BF16 elements. Each pair of elements in the first source vector is multiplied by the indexed pair of elements in the second source vector. The resulting single-precision products are then summed and added destructively to the single-precision element in the destination vector which aligns with the pair of BFloat16 values in the first source vector. The instruction does not update the  exception status.", "syntax": ["VDOT{<q>}.BF16 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VDOT{<q>}.BF16 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector", "VDOT{<q>}.BF16 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VDOT{<q>}.BF16 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm\" field.", "<index>\nIs the element index in the range 0 to 1, encoded in the \"M\" field."], "decode": "if !HaveAArch32BF16Ext() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(Vm);\ninteger i = UInt(M);\ninteger regs = if Q == '1' then 2 else 1;", "operation": "bits(64) operand1;\nbits(64) operand2;\nbits(64) result;\n\nCheckAdvSIMDEnabled();\n\noperand2 = Din[m];\nfor r = 0 to regs-1\n    operand1 = Din[n+r];\n    result = Din[d+r];\n    for e = 0 to 1\n        bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];\n        bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];\n        bits(16) elt2_a = Elem[operand2, 2 * i + 0, 16];\n        bits(16) elt2_b = Elem[operand2, 2 * i + 1, 16];\n        bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));\n        Elem[result, e, 32] = BFAdd(Elem[result, e, 32], sum);\n    D[d+r] = result;"}, {"mnemonic": "YIELD", "short_desc": "Yield hint", "full_desc": "is a hint instruction. Software with a multithreading capability can use a  instruction to indicate to the PE that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system performance. The PE can use this hint to suspend and resume multiple software threads if it supports the capability.", "syntax": ["YIELD{<c>}{<q>}\t; A1", "YIELD{<c>}{<q>}\t; T1", "YIELD{<c>}.W\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    Hint_Yield();"}, {"mnemonic": "CPS, CPSID, CPSIE", "short_desc": "Change PE State", "full_desc": "Change PE State changes one or more of the .{A, I, F} interrupt mask bits and, optionally, the .M mode field, without changing any other  bits.", "syntax": ["CPS{<q>} #<mode>\t; CPS", "CPSID{<q>} <iflags>\t; CPSID", "CPSID{<q>} <iflags> , #<mode>\t; CPSID", "CPSIE{<q>} <iflags>\t; CPSIE", "CPSIE{<q>} <iflags> , #<mode>\t; CPSIE", "CPSID{<q>} <iflags>\t; CPSID", "CPSIE{<q>} <iflags>\t; CPSIE", "CPS{<q>} #<mode>\t; CPS", "CPSID.W <iflags>\t; CPSID", "CPSID{<q>} <iflags>, #<mode>\t; CPSID", "CPSIE.W <iflags>\t; CPSIE", "CPSIE{<q>} <iflags>, #<mode>\t; CPSIE"], "symbols": ["<q>\nSee .", "<iflags>\nIs a sequence of one or more of the following, specifying which interrupt mask bits are affected:", "<mode>\nIs the number of the mode to change to, in the range 0 to 31, encoded in the \"mode\" field."], "decode": "if mode != '00000' && M == '0' then UNPREDICTABLE;\nif (imod<1> == '1' && A:I:F == '000') || (imod<1> == '0' && A:I:F != '000') then UNPREDICTABLE;\nenable = (imod == '10');  disable = (imod == '11');  changemode = (M == '1');\naffectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');\nif (imod == '00' && M == '0') || imod == '01' then UNPREDICTABLE;", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    EncodingSpecificOperations();\n    if PSTATE.EL != EL0 then\n        if enable then\n            if affectA then PSTATE.A = '0';\n            if affectI then PSTATE.I = '0';\n            if affectF then PSTATE.F = '0';\n        if disable then\n            if affectA then PSTATE.A = '1';\n            if affectI then PSTATE.I = '1';\n            if affectF then PSTATE.F = '1';\n        if changemode then\n            // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.\n            AArch32.WriteModeByInstr(mode);\nelse\n    EncodingSpecificOperations();\n    if PSTATE.EL != EL0 then\n        if enable then\n            if affectA then PSTATE.A = '0';\n            if affectI then PSTATE.I = '0';\n            if affectF then PSTATE.F = '0';\n        if disable then\n            if affectA then PSTATE.A = '1';\n            if affectI then PSTATE.I = '1';\n            if affectF then PSTATE.F = '1';\n        if changemode then\n            // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.\n            AArch32.WriteModeByInstr(mode);"}, {"mnemonic": "VQDMULL", "short_desc": "Vector Saturating Doubling Multiply Long", "full_desc": "Vector Saturating Doubling Multiply Long multiplies corresponding elements in two doubleword vectors, doubles the products, and places the results in a quadword vector.", "syntax": ["VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; A1", "VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>\t; A2", "VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; T1", "VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>\t; T2"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm[x]>\nIs the 64-bit name of the second SIMD&FP source register holding the scalar. If  is ,  is restricted to D0-D7.  is encoded in \"Vm<2:0>\", and  is encoded in \"M:Vm<3>\". If  is ,  is restricted to D0-D15.  is encoded in \"Vm\", and  is encoded in \"M\".", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif size == '00' || Vd<0> == '1' then UNDEFINED;\nscalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);\nesize = 8 << UInt(size);  elements = 64 DIV esize;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);\n    for e = 0 to elements-1\n        if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);\n        op1 = SInt(Elem[Din[n],e,esize]);\n        // The following only saturates if both op1 and op2 equal -(2^(esize-1))\n        (product, sat) = SignedSatQ(2*op1*op2, 2*esize);\n        Elem[Q[d>>1],e,2*esize] = product;\n        if sat then FPSCR.QC = '1';"}, {"mnemonic": "VQSHRN, VQSHRUN", "short_desc": "Vector Saturating Shift Right, Narrow", "full_desc": "Vector Saturating Shift Right, Narrow takes each element in a quadword vector of integers, right shifts them by an immediate value, and places the truncated results in a doubleword vector.", "syntax": ["VQSHRN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>\t; Signed result", "VQSHRUN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>\t; Unsigned result", "VQSHRN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>\t; Signed result", "VQSHRUN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>\t; Unsigned result"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\n", "<type>\n", "<size>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<imm>\nIs an immediate value, in the range 1 to /2, encoded in the \"imm6\" field as /2 - ."], "decode": "if imm6 == '000xxx' then SEE \"Related encodings\";\nif U == '0' && op == '0' then SEE \"VSHRN\";\nif Vm<0> == '1' then UNDEFINED;\ncase imm6 of\n    when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);\n    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);\n    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);\nsrc_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');\nd = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);\n        (result, sat) = SatQ(operand >> shift_amount, esize, dest_unsigned);\n        Elem[D[d],e,esize] = result;\n        if sat then FPSCR.QC = '1';"}, {"mnemonic": "VLD4 (multiple 4-element structures)", "short_desc": "Load multiple 4-element structures to four registers", "full_desc": "Load multiple 4-element structures to four registers loads multiple 4-element structures from memory into four registers, with de-interleaving. For more information, see . Every element of each register is loaded. For details of the addressing mode see .", "syntax": ["VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "case itype of\n    when '0000'\n        inc = 1;\n    when '0001'\n        inc = 2;\n    otherwise\n        SEE \"Related encodings\";\nif size == '11' then UNDEFINED;\nalignment = if align == '00' then 1 else 4 << UInt(align);\nebytes = 1 << UInt(size);  elements = 8 DIV ebytes;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d4 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    for e = 0 to elements-1\n        Elem[D[d], e] = MemU[address,ebytes];\n        Elem[D[d2],e] = MemU[address+ebytes,ebytes];\n        Elem[D[d3],e] = MemU[address+2*ebytes,ebytes];\n        Elem[D[d4],e] = MemU[address+3*ebytes,ebytes];\n        address = address + 4*ebytes;\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 32;"}, {"mnemonic": "VPMIN (floating-point)", "short_desc": "Vector Pairwise Minimum (floating-point)", "full_desc": "Vector Pairwise Minimum compares adjacent pairs of elements in two doubleword vectors, and copies the smaller of each pair into the corresponding element in the destination doubleword vector.", "syntax": ["VPMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; A1", "VPMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if sz == '1' && !HaveFP16Ext() then UNDEFINED;\nmaximum = (op == '0');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    bits(64) dest;\n    h = elements DIV 2;\n\n    for e = 0 to h-1\n        op1 = Elem[D[n],2*e,esize];  op2 = Elem[D[n],2*e+1,esize];\n        Elem[dest,e,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());\n        op1 = Elem[D[m],2*e,esize];  op2 = Elem[D[m],2*e+1,esize];\n        Elem[dest,e+h,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());\n\n    D[d] = dest;"}, {"mnemonic": "HLT", "short_desc": "Halting Breakpoint", "full_desc": "Halting breakpoint causes a software breakpoint to occur.", "syntax": ["HLT{<q>} {#}<imm>\t; A1", "HLT{<q>} {#}<imm>\t; T1"], "symbols": ["<q>\nSee . An  instruction must be unconditional.", "<imm>\nFor encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm12:imm4\" field. This value is for assembly and disassembly only. It is ignored by the PE, but can be used by a debugger to store more information about the halting breakpoint.", "<imm>\nFor encoding T1: is a 6-bit unsigned immediate, in the range 0 to 63, encoded in the \"imm6\" field. This value is for assembly and disassembly only. It is ignored by the PE, but can be used by a debugger to store more information about the halting breakpoint."], "decode": "if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;\nif cond != '1110' then UNPREDICTABLE; // HLT must be encoded with AL condition", "operation": "EncodingSpecificOperations();\nHalt(DebugHalt_HaltInstruction);"}, {"mnemonic": "BX", "short_desc": "Branch and Exchange", "full_desc": "Branch and Exchange causes a branch to an address and instruction set specified by a register.", "syntax": ["BX{<c>}{<q>} <Rm>\t; A1", "BX{<c>}{<q>} <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rm>\nFor encoding A1: is the general-purpose register holding the address to be branched to, encoded in the \"Rm\" field. The PC can be used.", "<Rm>\nFor encoding T1: is the general-purpose register holding the address to be branched to, encoded in the \"Rm\" field. The PC can be used."], "decode": "m = UInt(Rm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    BXWritePC(R[m], BranchType_INDIR);"}, {"mnemonic": "VMOV (between two general-purpose registers and two single-precision registers)", "short_desc": "Copy two general-purpose registers to a pair of 32-bit SIMD&FP registers", "full_desc": "Copy two general-purpose registers to a pair of 32-bit SIMD&FP registers transfers the contents of two consecutively numbered single-precision Floating-point registers to two general-purpose registers, or the contents of two general-purpose registers to a pair of single-precision Floating-point registers. The general-purpose registers do not have to be contiguous.", "syntax": ["VMOV{<c>}{<q>} <Sm>, <Sm1>, <Rt>, <Rt2>\t; From general-purpose registers", "VMOV{<c>}{<q>} <Rt>, <Rt2>, <Sm>, <Sm1>\t; To general-purpose registers", "VMOV{<c>}{<q>} <Sm>, <Sm1>, <Rt>, <Rt2>\t; From general-purpose registers", "VMOV{<c>}{<q>} <Rt>, <Rt2>, <Sm>, <Sm1>\t; To general-purpose registers"], "symbols": ["<Rt2>\nIs the second general-purpose register that  will be transferred to or from, encoded in the \"Rt2\" field.", "<Rt>\nIs the first general-purpose register that  will be transferred to or from, encoded in the \"Rt\" field.", "<Sm1>\nIs the 32-bit name of the second SIMD&FP register to be transferred. This is the next SIMD&FP register after .", "<Sm>\nIs the 32-bit name of the first SIMD&FP register to be transferred, encoded in the \"Vm:M\" field.", "<c>\nSee .", "<q>\nSee ."], "decode": "to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(Vm:M);\nif t == 15 || t2 == 15 || m == 31 then UNPREDICTABLE;\nif to_arm_registers && t == t2 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    if to_arm_registers then\n        R[t] = S[m];\n        R[t2] = S[m+1];\n    else\n        S[m] = R[t];\n        S[m+1] = R[t2];"}, {"mnemonic": "VSUBL", "short_desc": "Vector Subtract Long", "full_desc": "Vector Subtract Long subtracts the elements of one doubleword vector from the corresponding elements of another doubleword vector, and places the results in a quadword vector. Before subtracting, it sign-extends or zero-extends the elements of both operands.", "syntax": ["VSUBL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; A1", "VSUBL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        if is_vsubw then\n            op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);\n        else\n            op1 = Int(Elem[Din[n],e,esize], unsigned);\n        result = op1 - Int(Elem[Din[m],e,esize], unsigned);\n        Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;"}, {"mnemonic": "CBNZ, CBZ", "short_desc": "Compare and Branch on Nonzero or Zero", "full_desc": "Compare and Branch on Nonzero and Compare and Branch on Zero compare the value in a register with zero, and conditionally branch forward a constant value. They do not affect the condition flags.", "syntax": ["CBNZ{<q>} <Rn>, <label>\t; CBNZ", "CBZ{<q>} <Rn>, <label>\t; CBZ"], "symbols": ["<q>\nSee .", "<Rn>\nIs the general-purpose register to be tested, encoded in the \"Rn\" field.", "<label>\nIs the program label to be conditionally branched to. Its offset from the PC, a multiple of 2 and in the range 0 to 126, is encoded as \"i:imm5\" times 2."], "decode": "n = UInt(Rn);  imm32 = ZeroExtend(i:imm5:'0', 32);  nonzero = (op == '1');\nif InITBlock() then UNPREDICTABLE;", "operation": "EncodingSpecificOperations();\nif nonzero != IsZero(R[n]) then\n    BranchWritePC(PC + imm32, BranchType_DIR);"}, {"mnemonic": "LDR (literal)", "short_desc": "Load Register (literal)", "full_desc": "Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about memory accesses see .", "syntax": ["LDR{<c>}{<q>} <Rt>, <label>\t; A1", "LDR{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; A1", "LDR{<c>}{<q>} <Rt>, <label>\t; T1", "LDR{<c>}.W <Rt>, <label>\t; T2", "LDR{<c>}{<q>} <Rt>, <label>\t; T2", "LDR{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used. If the PC is used, the instruction branches to the address (data) loaded to the PC. This is an interworking branch, see .", "<Rt>\nFor encoding T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nFor encoding T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The SP can be used. The PC can be used, provided the instruction is either outside an IT block or the last instruction of an IT block. If the PC is used, the instruction branches to the address (data) loaded to the PC. This is an interworking branch, see .", "<label>\nFor encoding A1 and T2: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Permitted values of the offset are -4095 to 4095.", "<label>\nFor encoding T1: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Permitted values of the offset are Multiples of four in the range 0 to 1020.", "+/-\n", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T2: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "if P == '0' && W == '1' then SEE \"LDRT\";\nt = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);\nadd = (U == '1');  wback = (P == '0') || (W == '1');\nif wback then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    base = Align(PC,4);\n    address = if add then (base + imm32) else (base - imm32);\n    data = MemU[address,4];\n    if t == 15 then\n        if address<1:0> == '00' then\n            LoadWritePC(data);\n        else\n            UNPREDICTABLE;\n    else\n        R[t] = data;"}, {"mnemonic": "ADD, ADDS (SP plus register)", "short_desc": "Add to SP (register)", "full_desc": "Add to SP (register) adds an optionally-shifted register value to the SP value, and writes the result to the destination register.", "syntax": ["ADD{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX\t; ADD, rotate right with extend", "ADD{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}\t; ADD, shift or rotate by value", "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX\t; ADDS, rotate right with extend", "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}\t; ADDS, shift or rotate by value", "ADD{<c>}{<q>} {<Rdm>,} SP, <Rdm>\t; T1", "ADD{<c>}{<q>} {SP,} SP, <Rm>\t; T2", "ADD{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX\t; ADD, rotate right with extend", "ADD{<c>}.W {<Rd>,} SP, <Rm>\t; ADD, shift or rotate by value", "ADD{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}\t; ADD, shift or rotate by value", "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX\t; ADDS, rotate right with extend", "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}\t; ADDS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "SP,\nIs the stack pointer.", "<Rdm>\nIs the general-purpose destination and second source register, encoded in the \"Rdm\" field. If omitted, this register is the SP. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch to the address calculated by the operation. This is a simple branch, see .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the SP. Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the SP.", "<Rm>\nFor encoding A1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T3: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T3: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(SP, shifted, '0');\n    if d == 15 then\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "SHA256SU1", "short_desc": "SHA256 schedule update 1", "full_desc": "SHA256 schedule update 1.", "syntax": ["SHA256SU1.32 <Qd>, <Qn>, <Qm>\t; A1", "SHA256SU1.32 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA256Ext() then UNDEFINED;\nif Q != '1' then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    bits(128) result;\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    X = Q[d>>1]; Y = Q[n>>1]; Z = Q[m>>1];\n    T0 = Z<31:0> : Y<127:32>;\n\n    T1 = Z<127:64>;\n    for e = 0 to 1\n        elt = Elem[T1, e, 32];\n        elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n        elt = elt + Elem[X, e, 32] + Elem[T0, e, 32];\n        Elem[result, e, 32] = elt;\n\n    T1 = result<63:0>;\n    for e = 2 to 3\n        elt = Elem[T1, e - 2, 32];\n        elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n        elt = elt + Elem[X, e, 32] + Elem[T0, e, 32];\n        Elem[result, e, 32] = elt;\n\n    Q[d>>1] = result;"}, {"mnemonic": "RORS (register)", "short_desc": "Rotate Right, setting flags (register)", "syntax": ["RORS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Flag setting", "RORS{<q>} {<Rdm>,} <Rdm>, <Rs>\t; Rotate right", "RORS.W {<Rd>,} <Rm>, <Rs>\t; Flag setting", "RORS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rs>\nIs the second general-purpose source register holding a rotate amount in its bottom 8 bits, encoded in the \"Rs\" field."]}, {"mnemonic": "VRINTN (Advanced SIMD)", "short_desc": "Vector Round floating-point to integer to Nearest", "full_desc": "Vector Round floating-point to integer to Nearest rounds a vector of floating-point values to integral floating-point values of the same size using the Round to Nearest rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTN{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTN{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VRINTN{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTN{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if op<2> != op<0> then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\n// Rounding encoded differently from other VCVT and VRINT instructions\nrounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        op1 = Elem[D[m+r],e,esize];\n        result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);\n        Elem[D[d+r],e,esize] = result;"}, {"mnemonic": "ASR (register)", "short_desc": "Arithmetic Shift Right (register)", "syntax": ["ASR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Not flag setting", "ASR<c>{<q>} {<Rdm>,} <Rdm>, <Rs>\t; Arithmetic shift right", "ASR<c>.W {<Rd>,} <Rm>, <Rs>\t; Not flag setting", "ASR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rs>\nIs the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."]}, {"mnemonic": "VST2 (multiple 2-element structures)", "short_desc": "Store multiple 2-element structures from two or four registers", "full_desc": "Store multiple 2-element structures from two or four registers stores multiple 2-element structures from two or four registers to memory, with interleaving. For more information, see . Every element of each register is saved. For details of the addressing mode see .", "syntax": ["VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "regs = 1;  if align == '11' then UNDEFINED;\nif size == '11' then UNDEFINED;\ninc = if itype == '1001' then 2 else 1;\nalignment = if align == '00' then 1 else 4 << UInt(align);\nebytes = 1 << UInt(size);  elements = 8 DIV ebytes;\nd = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d2+regs > 32 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = TRUE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            MemU[address,       ebytes] = Elem[D[d+r], e];\n            MemU[address+ebytes,ebytes] = Elem[D[d2+r],e];\n            address = address + 2*ebytes;\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 16*regs;"}, {"mnemonic": "RORS (immediate)", "short_desc": "Rotate Right, setting flags (immediate)", "full_desc": "Rotate Right, setting flags (immediate) provides the value of the contents of a register rotated by a constant value. The bits that are rotated off the right end are inserted into the vacated bit positions on the left.", "syntax": ["RORS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value", "RORS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction performs an exception return, that restores  from SPSR_<current_mode>.", "<Rd>\nFor encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T3: is the general-purpose source register, encoded in the \"Rm\" field.", "<imm>\nFor encoding A1: is the shift amount, in the range 1 to 31, encoded in the \"imm5\" field.", "<imm>\nFor encoding T3: is the shift amount, in the range 1 to 31, encoded in the \"imm3:imm2\" field."]}, {"mnemonic": "AESD", "short_desc": "AES single round decryption", "full_desc": "AES single round decryption.", "syntax": ["AESD.<dt> <Qd>, <Qm>\t; A1", "AESD.<dt> <Qd>, <Qm>\t; T1"], "symbols": ["<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAESExt() then UNDEFINED;\nif size != '00' then UNDEFINED;\nif Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    op1 = Q[d>>1]; op2 = Q[m>>1];\n    Q[d>>1] = AESInvSubBytes(AESInvShiftRows(op1 EOR op2));"}, {"mnemonic": "SUB, SUBS (immediate)", "short_desc": "Subtract (immediate)", "full_desc": "Subtract (immediate) subtracts an immediate value from a register value, and writes the result to the destination register.", "syntax": ["SUB{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; SUB", "SUBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; SUBS", "SUB<c>{<q>} <Rd>, <Rn>, #<imm3>\t; T1", "SUBS{<q>} <Rd>, <Rn>, #<imm3>\t; T1", "SUB<c>{<q>} <Rdn>, #<imm8>\t; T2", "SUB<c>{<q>} {<Rdn>,} <Rdn>, #<imm8>\t; T2", "SUBS{<q>} <Rdn>, #<imm8>\t; T2", "SUBS{<q>} {<Rdn>,} <Rdn>, #<imm8>\t; T2", "SUB<c>.W {<Rd>,} <Rn>, #<const>\t; SUB", "SUB{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; SUB", "SUBS.W {<Rd>,} <Rn>, #<const>\t; SUBS", "SUBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; SUBS", "SUB{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>\t; T4", "SUBW{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>\t; T4", "SUBS{<c>}{<q>} PC, LR, #<imm8>\t; T5"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdn>\nIs the general-purpose source and destination register, encoded in the \"Rdn\" field.", "<imm8>\nFor encoding T2: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.", "<imm8>\nFor encoding T5: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field. If  is the LR, and zero is used, see .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . If the PC is used:", "<Rd>\nFor encoding T1, T3 and T4: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1 and T4: is the general-purpose source register, encoded in the \"Rn\" field. If the SP is used, see . If the PC is used, see .", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nFor encoding T3: is the general-purpose source register, encoded in the \"Rn\" field. If the SP is used, see .", "<imm3>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"imm3\" field.", "<imm12>\nIs a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T3: an immediate value. See  for the range of values."], "decode": "if Rn == '1111' && S == '0' then SEE \"ADR\";\nif Rn == '1101' then SEE \"SUB (SP minus immediate)\";\nd = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');\n    if d == 15 then\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VSRA", "short_desc": "Vector Shift Right and Accumulate", "full_desc": "Vector Shift Right and Accumulate takes each element in a vector, right shifts them by an immediate value, and accumulates the truncated results into the destination vector. For rounded results, see .", "syntax": ["VSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector", "VSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\n", "<size>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nIs an immediate value, in the range 1 to , encoded in the \"imm6\" field as  - ."], "decode": "if (L:imm6) == '0000xxx' then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\ncase L:imm6 of\n    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);\n    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);\n    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);\n    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);\nunsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;\n            Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;"}, {"mnemonic": "SBC, SBCS (register)", "short_desc": "Subtract with Carry (register)", "full_desc": "Subtract with Carry (register) subtracts an optionally-shifted register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register.", "syntax": ["SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; SBC, rotate right with extend", "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; SBC, shift or rotate by value", "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; SBCS, rotate right with extend", "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; SBCS, shift or rotate by value", "SBC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "SBCS{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; SBC, rotate right with extend", "SBC<c>.W {<Rd>,} <Rn>, <Rm>\t; SBC, shift or rotate by value", "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; SBC, shift or rotate by value", "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; SBCS, rotate right with extend", "SBCS.W {<Rd>,} <Rn>, <Rm>\t; SBCS, shift or rotate by value", "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; SBCS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdn>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "LDRSH (immediate)", "short_desc": "Load Register Signed Halfword (immediate)", "full_desc": "Load Register Signed Halfword (immediate) calculates an address from a base register value and an immediate offset, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing.  For information about memory accesses see .", "syntax": ["LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "LDRSH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRSH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1", "LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]\t; Offset", "LDRSH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRSH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. For PC use see .", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T2: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field."], "decode": "if Rn == '1111' then SEE \"LDRSH (literal)\";\nif P == '0' && W == '1' then SEE \"LDRSHT\";\nt = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 || (wback && n == t) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n    address = if index then offset_addr else R[n];\n    data = MemU[address,2];\n    if wback then R[n] = offset_addr;\n    R[t] = SignExtend(data, 32);"}, {"mnemonic": "AESE", "short_desc": "AES single round encryption", "full_desc": "AES single round encryption.", "syntax": ["AESE.<dt> <Qd>, <Qm>\t; A1", "AESE.<dt> <Qd>, <Qm>\t; T1"], "symbols": ["<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAESExt() then UNDEFINED;\nif size != '00' then UNDEFINED;\nif Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    op1 = Q[d>>1]; op2 = Q[m>>1];\n    Q[d>>1] = AESSubBytes(AESShiftRows(op1 EOR op2));"}, {"mnemonic": "VCVTA (floating-point)", "short_desc": "Convert floating-point to integer with Round to Nearest with Ties to Away", "full_desc": "Convert floating-point to integer with Round to Nearest with Ties to Away converts a value in a register from floating-point to a 32-bit integer using the Round to Nearest with Ties to Away rounding mode, and places the result in a second register.", "syntax": ["VCVTA{<q>}.<dt>.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTA{<q>}.<dt>.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTA{<q>}.<dt>.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVTA{<q>}.<dt>.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTA{<q>}.<dt>.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTA{<q>}.<dt>.F64 <Sd>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<dt>\n", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nrounding = FPDecodeRM(RM);  unsigned = (op == '0');\nd = UInt(Vd:D);\ncase size of\n    when '01' esize = 16; m = UInt(Vm:M);\n    when '10' esize = 32; m = UInt(Vm:M);\n    when '11' esize = 64; m = UInt(M:Vm);", "operation": "EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\ncase esize of\n    when 16\n        S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);\n    when 32\n        S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);\n    when 64\n        S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);"}, {"mnemonic": "VABS", "short_desc": "Vector Absolute", "full_desc": "Vector Absolute takes the absolute value of each element in a vector, and places the results in a second vector. The floating-point version only clears the sign bit.", "syntax": ["VABS{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VABS{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VABS{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VABS{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VABS{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VABS{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VABS{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VABS{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VABS{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VABS{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if size == '11' then UNDEFINED;\nif F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nadvsimd = TRUE;  floating_point = (F == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if advsimd then  // Advanced SIMD instruction\n        for r = 0 to regs-1\n            for e = 0 to elements-1\n                if floating_point then\n                    Elem[D[d+r],e,esize] = FPAbs(Elem[D[m+r],e,esize]);\n                else\n                    result = Abs(SInt(Elem[D[m+r],e,esize]));\n                    Elem[D[d+r],e,esize] = result<esize-1:0>;\n    else             // VFP instruction\n        case esize of\n            when 16 S[d] = Zeros(16) : FPAbs(S[m]<15:0>);\n            when 32 S[d] = FPAbs(S[m]);\n            when 64 D[d] = FPAbs(D[m]);"}, {"mnemonic": "UXTAH", "short_desc": "Unsigned Extend and Add Halfword", "full_desc": "Unsigned Extend and Add Halfword extracts a 16-bit value from a register, zero-extends it to 32 bits, adds the result to a value from another register, and writes the final result to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.", "syntax": ["UXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; A1", "UXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "if Rn == '1111' then SEE \"UXTH\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d] = R[n] + ZeroExtend(rotated<15:0>, 32);"}, {"mnemonic": "VCLE (immediate #0)", "short_desc": "Vector Compare Less Than or Equal to Zero", "full_desc": "Vector Compare Less Than or Equal to Zero takes each element in a vector, and compares it with zero. If it is less than or equal to zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VCLE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nfloating_point = (F == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if floating_point then\n                bits(esize) zero = FPZero('0');\n                test_passed = FPCompareGE(zero, Elem[D[m+r],e,esize], StandardFPSCRValue());\n            else\n                test_passed = (SInt(Elem[D[m+r],e,esize]) <= 0);\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "VSHL (immediate)", "short_desc": "Vector Shift Left (immediate)", "full_desc": "Vector Shift Left (immediate) takes each element in a vector of integers, left shifts them by an immediate value, and places the results in the destination vector.", "syntax": ["VSHL{<c>}{<q>}.I<size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSHL{<c>}{<q>}.I<size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector", "VSHL{<c>}{<q>}.I<size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSHL{<c>}{<q>}.I<size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nIs an immediate value, in the range 0 to -1, encoded in the \"imm6\" field."], "decode": "if L:imm6 == '0000xxx' then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\ncase L:imm6 of\n    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;\n    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;\n    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;\n    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = LSL(Elem[D[m+r],e,esize], shift_amount);"}, {"mnemonic": "VABD (integer)", "short_desc": "Vector Absolute Difference (integer)", "full_desc": "Vector Absolute Difference (integer) subtracts the elements of one vector from the corresponding elements of another vector, and places the absolute values of the results in the elements of the destination vector.", "syntax": ["VABD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VABD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VABD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VABD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nunsigned = (U == '1');  long_destination = FALSE;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];\n            op2 = Elem[Din[m+r],e,esize];\n            absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = absdiff<2*esize-1:0>;\n            else\n                Elem[D[d+r],e,esize] = absdiff<esize-1:0>;"}, {"mnemonic": "CMN (immediate)", "short_desc": "Compare Negative (immediate)", "full_desc": "Compare Negative (immediate) adds a register value and an immediate value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN{<c>}{<q>} <Rn>, #<const>\t; A1", "CMN{<c>}{<q>} <Rn>, #<const>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "n = UInt(Rn);  imm32 = A32ExpandImm(imm12);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result, nzcv) = AddWithCarry(R[n], imm32, '0');\n    PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VCLZ", "short_desc": "Vector Count Leading Zeros", "full_desc": "Vector Count Leading Zeros counts the number of consecutive zeros, starting from the most significant bit, in each element in a vector, and places the results in a second vector.", "syntax": ["VCLZ{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCLZ{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VCLZ{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCLZ{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = CountLeadingZeroBits(Elem[D[m+r],e,esize])<esize-1:0>;"}, {"mnemonic": "SHA256SU0", "short_desc": "SHA256 schedule update 0", "full_desc": "SHA256 schedule update 0.", "syntax": ["SHA256SU0.32 <Qd>, <Qm>\t; A1", "SHA256SU0.32 <Qd>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA256Ext() then UNDEFINED;\nif size != '10' then UNDEFINED;\nif Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    bits(128) result;\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    X = Q[d>>1]; Y = Q[m>>1];\n    T = Y<31:0> : X<127:32>;\n    for e = 0 to 3\n        elt = Elem[T, e, 32];\n        elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);\n        Elem[result, e, 32] = elt + Elem[X, e, 32];\n    Q[d>>1] = result;"}, {"mnemonic": "MOV, MOVS (register)", "short_desc": "Move (register)", "full_desc": "Move (register) copies a value from a register to the destination register.", "syntax": ["MOV{<c>}{<q>} <Rd>, <Rm>, RRX\t; MOV, rotate right with extend", "MOV{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; MOV, shift or rotate by value", "MOVS{<c>}{<q>} <Rd>, <Rm>, RRX\t; MOVS, rotate right with extend", "MOVS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; MOVS, shift or rotate by value", "MOV{<c>}{<q>} <Rd>, <Rm>\t; T1", "MOV<c>{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; T2", "MOVS{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; T2", "MOV{<c>}{<q>} <Rd>, <Rm>, RRX\t; MOV, rotate right with extend", "MOV{<c>}.W <Rd>, <Rm> {, LSL #0}\t; MOV, shift or rotate by value", "MOV<c>.W <Rd>, <Rm> {, <shift> #<amount>}\t; MOV, shift or rotate by value", "MOV{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; MOV, shift or rotate by value", "MOVS{<c>}{<q>} <Rd>, <Rm>, RRX\t; MOVS, rotate right with extend", "MOVS.W <Rd>, <Rm> {, <shift> #<amount>}\t; MOVS, shift or rotate by value", "MOVS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; MOVS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"D:Rd\" field. If the PC is used:", "<Rd>\nFor encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1 and T1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used. Arm deprecates use of the instruction if  is the PC.", "<Rm>\nFor encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 0 to 31 (when <shift> = LSL), or 1 to 31 (when <shift> = ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T3: is the shift amount, in the range 0 to 31 (when <shift> = LSL) or 1 to 31 (when <shift> = ROR), or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = shifted;\n    if d == 15 then\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "SXTB16", "short_desc": "Signed Extend Byte 16", "full_desc": "Signed Extend Byte 16 extracts two 8-bit values from a register, sign-extends them to 16 bits each, and writes the results to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit values.", "syntax": ["SXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; A1", "SXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d]<15:0>  = SignExtend(rotated<7:0>, 16);\n    R[d]<31:16> = SignExtend(rotated<23:16>, 16);"}, {"mnemonic": "VRINTZ (floating-point)", "short_desc": "Round floating-point to integer towards Zero", "full_desc": "Round floating-point to integer towards Zero rounds a floating-point value to an integral floating-point value of the same size, using the Round towards Zero rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTZ{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTZ{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTZ{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VRINTZ{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTZ{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTZ{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nrounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);\nexact = FALSE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\n    case esize of\n        when 16\n            S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);\n        when 32\n            S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);\n        when 64\n            D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);"}, {"mnemonic": "VMOV (scalar to general-purpose register)", "short_desc": "Copy a vector element to a general-purpose register with sign or zero extension", "full_desc": "Copy a vector element to a general-purpose register with sign or zero extension copies a byte, halfword, or word from an Advanced SIMD scalar to a general-purpose register. Bytes and halfwords can be either zero-extended or sign-extended.", "syntax": ["VMOV{<c>}{<q>}{.<dt>} <Rt>, <Dn[x]>\t; A1", "VMOV{<c>}{<q>}{.<dt>} <Rt>, <Dn[x]>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<dt>\nThe data type. It must be one of:", "<Rt>\nThe destination general-purpose register.", "<Dn[x]>\nThe scalar. For details of how  is encoded see the description of ."], "decode": "case U:opc1:opc2 of\n    when 'x1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);\n    when 'x0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);\n    when '00x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);\n    when '10x00'  UNDEFINED;\n    when 'x0x10'  UNDEFINED;\nt = UInt(Rt);  n = UInt(N:Vn);  unsigned = (U == '1');\nif t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if unsigned then\n        R[t] = ZeroExtend(Elem[D[n],index,esize], 32);\n    else\n        R[t] = SignExtend(Elem[D[n],index,esize], 32);"}, {"mnemonic": "VCMLA", "short_desc": "Vector Complex Multiply Accumulate", "full_desc": "Vector Complex Multiply Accumulate.", "syntax": ["VCMLA{<q>}.<dt> <Dd>, <Dn>, <Dm>, #<rotate>\t; 64-bit SIMD vector", "VCMLA{<q>}.<dt> <Qd>, <Qn>, <Qm>, #<rotate>\t; 128-bit SIMD vector", "VCMLA{<q>}.<dt> <Dd>, <Dn>, <Dm>, #<rotate>\t; 64-bit SIMD vector", "VCMLA{<q>}.<dt> <Qd>, <Qn>, <Qm>, #<rotate>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<rotate>\n"], "decode": "if !HaveFCADDExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);\nesize = 16 << UInt(S);\nif !HaveFP16Ext() && esize == 16 then UNDEFINED;\nelements = 64 DIV esize;\nregs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations();\nCheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    operand1 = D[n+r];\n    operand2 = D[m+r];\n    operand3 = D[d+r];\n    for e = 0 to (elements DIV 2)-1\n        case rot of\n            when '00'\n               element1 = Elem[operand2,e*2,esize];\n               element2 = Elem[operand1,e*2,esize];\n               element3 = Elem[operand2,e*2+1,esize];\n               element4 = Elem[operand1,e*2,esize];\n            when '01'\n               element1 = FPNeg(Elem[operand2,e*2+1,esize]);\n               element2 = Elem[operand1,e*2+1,esize];\n               element3 = Elem[operand2,e*2,esize];\n               element4 = Elem[operand1,e*2+1,esize];\n            when '10'\n               element1 = FPNeg(Elem[operand2,e*2,esize]);\n               element2 = Elem[operand1,e*2,esize];\n               element3 = FPNeg(Elem[operand2,e*2+1,esize]);\n               element4 = Elem[operand1,e*2,esize];\n            when '11'\n               element1 = Elem[operand2,e*2+1,esize];\n               element2 = Elem[operand1,e*2+1,esize];\n               element3 = FPNeg(Elem[operand2,e*2,esize]);\n               element4 = Elem[operand1,e*2+1,esize];\n        result1 = FPMulAdd(Elem[operand3,e*2,esize],element2,element1, StandardFPSCRValue());\n        result2 = FPMulAdd(Elem[operand3,e*2+1,esize],element4,element3, StandardFPSCRValue());\n        Elem[D[d+r],e*2,esize] = result1;\n        Elem[D[d+r],e*2+1,esize] = result2;"}, {"mnemonic": "BIC, BICS (register)", "short_desc": "Bitwise Bit Clear (register)", "full_desc": "Bitwise Bit Clear (register) performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; BIC, rotate right with extend", "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; BIC, shift or rotate by value", "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; BICS, rotate right with extend", "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; BICS, shift or rotate by value", "BIC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "BICS{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; BIC, rotate right with extend", "BIC<c>.W {<Rd>,} <Rn>, <Rm>\t; BIC, shift or rotate by value", "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; BIC, shift or rotate by value", "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; BICS, rotate right with extend", "BICS.W {<Rd>,} <Rn>, <Rm>\t; BICS, shift or rotate by value", "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; BICS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdn>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] AND NOT(shifted);\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "SMULL, SMULLS", "short_desc": "Signed Multiply Long", "full_desc": "Signed Multiply Long multiplies two 32-bit signed values to produce a 64-bit result.", "syntax": ["SMULLS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; Flag setting", "SMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; Not flag setting", "SMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<RdLo>\nIs the general-purpose destination register for the lower 32 bits of the result, encoded in the \"RdLo\" field.", "<RdHi>\nIs the general-purpose destination register for the upper 32 bits of the result, encoded in the \"RdHi\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."], "decode": "dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\nif dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif dHi == dLo then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = SInt(R[n]) * SInt(R[m]);\n    R[dHi] = result<63:32>;\n    R[dLo] = result<31:0>;\n    if setflags then\n        PSTATE.N = result<63>;\n        PSTATE.Z = IsZeroBit(result<63:0>);\n        // PSTATE.C, PSTATE.V unchanged"}, {"mnemonic": "LSL (register)", "short_desc": "Logical Shift Left (register)", "syntax": ["LSL{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Not flag setting", "LSL<c>{<q>} {<Rdm>,} <Rdm>, <Rs>\t; Logical shift left", "LSL<c>.W {<Rd>,} <Rm>, <Rs>\t; Not flag setting", "LSL{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rs>\nIs the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."]}, {"mnemonic": "VLD3 (multiple 3-element structures)", "short_desc": "Load multiple 3-element structures to three registers", "full_desc": "Load multiple 3-element structures to three registers loads multiple 3-element structures from memory into three registers, with de-interleaving. For more information, see . Every element of each register is loaded. For details of the addressing mode see .", "syntax": ["VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "case itype of\n    when '0100'\n        inc = 1;\n    when '0101'\n        inc = 2;\n    otherwise\n        SEE \"Related encodings\";\nif size == '11' || align<1> == '1' then UNDEFINED;\nalignment = if align<0> == '0' then 1 else 8;\nebytes = 1 << UInt(size);  elements = 8 DIV ebytes;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d3 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    for e = 0 to elements-1\n        Elem[D[d], e] = MemU[address,ebytes];\n        Elem[D[d2],e] = MemU[address+ebytes,ebytes];\n        Elem[D[d3],e] = MemU[address+2*ebytes,ebytes];\n        address = address + 3*ebytes;\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 24;"}, {"mnemonic": "LDREXB", "short_desc": "Load Register Exclusive Byte", "full_desc": "Load Register Exclusive Byte derives an address from a base register value, loads a byte from memory, zero-extends it to form a 32-bit word, writes it to a register and:", "syntax": ["LDREXB{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "LDREXB{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    AArch32.SetExclusiveMonitors(address,1);\n    R[t] = ZeroExtend(MemA[address,1], 32);"}, {"mnemonic": "VNMUL", "short_desc": "Vector Negate Multiply", "full_desc": "Vector Negate Multiply multiplies together two floating-point register values, and writes the negation of the result to the destination register.", "syntax": ["VNMUL{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VNMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VNMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar", "VNMUL{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VNMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VNMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\nif size == '01' && !HaveFP16Ext() then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nvtype = VFPNegMul_VNMUL;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL};\n\nif ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    case esize of\n        when 16\n            product16 = FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);\n            case vtype of\n                when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), FPNeg(product16), FPSCR);\n                when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), product16, FPSCR);\n                when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);\n        when 32\n            product32 = FPMul(S[n], S[m], FPSCR);\n            case vtype of\n                when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);\n                when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);\n                when VFPNegMul_VNMUL  S[d] = FPNeg(product32);\n        when 64\n            product64 = FPMul(D[n], D[m], FPSCR);\n            case vtype of\n                when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);\n                when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);\n                when VFPNegMul_VNMUL  D[d] = FPNeg(product64);"}, {"mnemonic": "LDRH (register)", "short_desc": "Load Register Halfword (register)", "full_desc": "Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. The offset register value can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see .", "syntax": ["LDRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]\t; Offset", "LDRH{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>\t; Post-indexed", "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!\t; Pre-indexed", "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]\t; T1", "LDRH{<c>}.W <Rt>, [<Rn>, {+}<Rm>]\t; T2", "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant.", "<Rn>\nFor encoding T1 and T2: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<imm>\nIf present, the size of the left shift to apply to the value from , in the range 1-3.  is encoded in imm2. If absent, no shift is specified and imm2 is encoded as ."], "decode": "if P == '0' && W == '1' then SEE \"LDRHT\";\nt = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\n(shift_t, shift_n) = (SRType_LSL, 0);\nif t == 15 || m == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if index then offset_addr else R[n];\n    data = MemU[address,2];\n    if wback then R[n] = offset_addr;\n    R[t] = ZeroExtend(data, 32);"}, {"mnemonic": "MLA, MLAS", "short_desc": "Multiply Accumulate", "full_desc": "Multiply Accumulate multiplies two register values, and adds a third register value. The least significant 32 bits of the result are written to the destination register. These 32 bits do not depend on whether the source register values are considered to be signed values or unsigned values.", "syntax": ["MLAS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; Flag setting", "MLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; Not flag setting", "MLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  setflags = (S == '1');\nif d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results\n    operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results\n    addend   = SInt(R[a]);  // addend   = UInt(R[a]) produces the same final results\n    result = operand1 * operand2 + addend;\n    R[d] = result<31:0>;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result<31:0>);\n        // PSTATE.C, PSTATE.V unchanged"}, {"mnemonic": "QSAX", "short_desc": "Saturating Subtract and Add with Exchange", "full_desc": "Saturating Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one 16-bit integer subtraction and one 16-bit addition, saturates the results to the 16-bit signed integer range -2 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["QSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "QSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum  = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);\n    diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);\n    R[d]<15:0>  = SignedSat(sum, 16);\n    R[d]<31:16> = SignedSat(diff, 16);"}, {"mnemonic": "SHADD8", "short_desc": "Signed Halving Add 8", "full_desc": "Signed Halving Add 8 performs four signed 8-bit integer additions, halves the results, and writes the results to the destination register.", "syntax": ["SHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);\n    sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);\n    sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);\n    sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);\n    R[d]<7:0>   = sum1<8:1>;\n    R[d]<15:8>  = sum2<8:1>;\n    R[d]<23:16> = sum3<8:1>;\n    R[d]<31:24> = sum4<8:1>;"}, {"mnemonic": "VQRSHL", "short_desc": "Vector Saturating Rounding Shift Left", "full_desc": "Vector Saturating Rounding Shift Left takes each element in a vector, shifts them by a value from the least significant byte of the corresponding element of a second vector, and places the results in the destination vector. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift.", "syntax": ["VQRSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>\t; 64-bit SIMD vector", "VQRSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>\t; 128-bit SIMD vector", "VQRSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>\t; 64-bit SIMD vector", "VQRSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            shift = SInt(Elem[D[n+r],e,esize]<7:0>);\n            round_const = 1 << (-1-shift); // 0 for left shift, 2^(n-1) for right shift\n            operand = Int(Elem[D[m+r],e,esize], unsigned);\n            (result, sat) = SatQ((operand + round_const) << shift, esize, unsigned);\n            Elem[D[d+r],e,esize] = result;\n            if sat then FPSCR.QC = '1';"}, {"mnemonic": "VSQRT", "short_desc": "Square Root", "full_desc": "Square Root calculates the square root of the value in a floating-point register and writes the result to another floating-point register.", "syntax": ["VSQRT{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VSQRT{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VSQRT{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VSQRT{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VSQRT{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VSQRT{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nif FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    case esize of\n        when 16 S[d] = Zeros(16) : FPSqrt(S[m]<15:0>, FPSCR);\n        when 32 S[d] = FPSqrt(S[m], FPSCR);\n        when 64 D[d] = FPSqrt(D[m], FPSCR);"}, {"mnemonic": "SUB, SUBS (SP minus register)", "short_desc": "Subtract from SP (register)", "full_desc": "Subtract from SP (register) subtracts an optionally-shifted register value from the SP value, and writes the result to the destination register.", "syntax": ["SUB{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX\t; SUB, rotate right with extend", "SUB{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}\t; SUB, shift or rotate by value", "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX\t; SUBS, rotate right with extend", "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}\t; SUBS, shift or rotate by value", "SUB{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX\t; SUB, rotate right with extend", "SUB{<c>}.W {<Rd>,} SP, <Rm>\t; SUB, shift or rotate by value", "SUB{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}\t; SUB, shift or rotate by value", "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX\t; SUBS, rotate right with extend", "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}\t; SUBS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the SP. Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the SP.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(SP, NOT(shifted), '1');\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VRSHRN (zero)", "short_desc": "Vector Rounding Shift Right and Narrow", "syntax": ["VRSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; A1", "VRSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."]}, {"mnemonic": "SXTAB", "short_desc": "Signed Extend and Add Byte", "full_desc": "Signed Extend and Add Byte extracts an 8-bit value from a register, sign-extends it to 32 bits, adds the result to the value in another register, and writes the final result to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.", "syntax": ["SXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; A1", "SXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "if Rn == '1111' then SEE \"SXTB\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d] = R[n] + SignExtend(rotated<7:0>, 32);"}, {"mnemonic": "VMUL (by scalar)", "short_desc": "Vector Multiply (by scalar)", "full_desc": "Vector Multiply multiplies each element in a vector by a scalar, and places the results in a second vector.", "syntax": ["VMUL{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VMUL{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector", "VMUL{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VMUL{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register. When  is I16 or F16, this is encoded in the \"Vm<2:0>\" field. Otherwise it is encoded in the \"Vm\" field.", "<index>\nIs the element index. When  is I16 or F16, this is in the range 0 to 3 and is encoded in the \"M:Vm<3>\" field. Otherwise it is in the range 0 to 1 and is encoded in the \"M\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;\nunsigned = FALSE;  // \"Don't care\" value: TRUE produces same functionality\nfloating_point = (F == '1');  long_destination = FALSE;\nd = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;\nif size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);\nif size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);\n            if floating_point then\n                Elem[D[d+r],e,esize] = FPMul(op1, op2, StandardFPSCRValue());\n            else\n                if long_destination then\n                    Elem[Q[d>>1],e,2*esize] = (op1val*op2val)<2*esize-1:0>;\n                else\n                    Elem[D[d+r],e,esize] = (op1val*op2val)<esize-1:0>;"}, {"mnemonic": "LDRSHT", "short_desc": "Load Register Signed Halfword Unprivileged", "full_desc": "Load Register Signed Halfword Unprivileged loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRSHT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}\t; A1", "LDRSHT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>\t; A2", "LDRSHT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 and encoded in the \"imm8\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');\nregister_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);\nif t == 15 || n == 15 || n == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode\n    EncodingSpecificOperations();\n    offset = if register_form then R[m] else imm32;\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if postindex then R[n] else offset_addr;\n    data = MemU_unpriv[address,2];\n    if postindex then R[n] = offset_addr;\n    R[t] = SignExtend(data, 32);"}, {"mnemonic": "CSDB", "short_desc": "Consumption of Speculative Data Barrier", "full_desc": "Consumption of Speculative Data Barrier is a memory barrier that controls speculative execution and data value prediction.", "syntax": ["CSDB{<c>}{<q>}\t; A1", "CSDB{<c>}.W\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "if cond != '1110' then UNPREDICTABLE;      // CSDB must be encoded with AL condition", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n\n    ConsumptionOfSpeculativeDataBarrier();"}, {"mnemonic": "AESMC", "short_desc": "AES mix columns", "full_desc": "AES mix columns.", "syntax": ["AESMC.<dt> <Qd>, <Qm>\t; A1", "AESMC.<dt> <Qd>, <Qm>\t; T1"], "symbols": ["<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAESExt() then UNDEFINED;\nif size != '00' then UNDEFINED;\nif Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    Q[d>>1] = AESMixColumns(Q[m>>1]);"}, {"mnemonic": "VMAXNM", "short_desc": "Floating-point Maximum Number", "full_desc": "This instruction determines the floating-point maximum number.", "syntax": ["VMAXNM{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMAXNM{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMAXNM{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VMAXNM{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VMAXNM{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VMAXNM{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMAXNM{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMAXNM{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VMAXNM{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VMAXNM{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nmaximum = (op == '0');\nadvsimd = TRUE;\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\nif advsimd then             // Advanced SIMD instruction\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[n+r], e, esize]; op2 = Elem[D[m+r], e, esize];\n            if maximum then\n                Elem[D[d+r], e, esize] = FPMaxNum(op1, op2, StandardFPSCRValue());\n            else\n                Elem[D[d+r], e, esize] = FPMinNum(op1, op2, StandardFPSCRValue());\nelse                        // VFP instruction\n    case esize of\n        when 16\n            if maximum then\n                S[d] = Zeros(16) : FPMaxNum(S[n]<15:0>, S[m]<15:0>, FPSCR);\n            else\n                S[d] = Zeros(16) : FPMinNum(S[n]<15:0>, S[m]<15:0>, FPSCR);\n        when 32\n            if maximum then\n                S[d] = FPMaxNum(S[n], S[m], FPSCR);\n            else\n                S[d] = FPMinNum(S[n], S[m], FPSCR);\n        when 64\n            if maximum then\n                D[d] = FPMaxNum(D[n], D[m], FPSCR);\n            else\n                D[d] = FPMinNum(D[n], D[m], FPSCR);"}, {"mnemonic": "LSR (register)", "short_desc": "Logical Shift Right (register)", "syntax": ["LSR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Not flag setting", "LSR<c>{<q>} {<Rdm>,} <Rdm>, <Rs>\t; Logical shift right", "LSR<c>.W {<Rd>,} <Rm>, <Rs>\t; Not flag setting", "LSR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rs>\nIs the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."]}, {"mnemonic": "VMLSL (integer)", "short_desc": "Vector Multiply Subtract Long (integer)", "full_desc": "Vector Multiply Subtract Long multiplies corresponding elements in two vectors, and subtract the products from the corresponding elements of the destination vector. The destination vector element is twice as long as the elements that are multiplied.", "syntax": ["VMLSL{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm>\t; A1", "VMLSL{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\nThe data type for the elements of the operands. It must be one of:", "<size>\nThe data size for the elements of the operands. It must be one of:", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vd<0> == '1' then UNDEFINED;\nadd = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);\n            addend = if add then product else -product;\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;\n            else\n                Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;"}, {"mnemonic": "VUMMLA", "short_desc": "Widening 8-bit unsigned integer matrix multiply-accumulate into 2x2 matrix", "full_desc": "The widening integer matrix multiply-accumulate instruction multiplies the 2x8 matrix of unsigned 8-bit integer values held in the first source vector by the 8x2 matrix of unsigned 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator held in the destination vector. This is equivalent to performing an 8-way dot product per destination element.", "syntax": ["VUMMLA{<q>}.U8 <Qd>, <Qn>, <Qm>\t; A1", "VUMMLA{<q>}.U8 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP third source and destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAArch32Int8MatMulExt() then UNDEFINED;\ncase B:U of\n    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;\n    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;\n    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;\n    when '11' UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(M:Vm);", "operation": "CheckAdvSIMDEnabled();\nbits(128) operand1 = Q[n>>1];\nbits(128) operand2 = Q[m>>1];\nbits(128) addend   = Q[d>>1];\n\nQ[d>>1] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);"}, {"mnemonic": "RBIT", "short_desc": "Reverse Bits", "full_desc": "Reverse Bits reverses the bit order in a 32-bit register.", "syntax": ["RBIT{<c>}{<q>} <Rd>, <Rm>\t; A1", "RBIT{<c>}{<q>} <Rd>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field.", "<Rm>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rm\" field. It must be encoded with an identical value in the \"Rn\" field."], "decode": "d = UInt(Rd);  m = UInt(Rm);\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    bits(32) result;\n    for i = 0 to 31\n        result<31-i> = R[m]<i>;\n    R[d] = result;"}, {"mnemonic": "LDRD (immediate)", "short_desc": "Load Register Dual (immediate)", "full_desc": "Load Register Dual (immediate) calculates an address from a base register value and an immediate offset, loads two words from memory, and writes them to two registers. It can use offset, post-indexed, or pre-indexed addressing. For information about memory accesses see .", "syntax": ["LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field. This register must be even-numbered and not R14.", "<Rt>\nFor encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nFor encoding A1: is the second general-purpose register to be transferred. This register must be .", "<Rt2>\nFor encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. For PC use see .", "+/-\n", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is the unsigned immediate byte offset, a multiple of 4, in the range 0 to 1020, defaulting to 0 if omitted, and encoded in the \"imm8\" field as <imm>/4."], "decode": "if Rn == '1111' then SEE \"LDRD (literal)\";\nif Rt<0> == '1' then UNPREDICTABLE;\nt = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif P == '0' && W == '1' then UNPREDICTABLE;\nif wback && (n == t || n == t2) then UNPREDICTABLE;\nif t2 == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n    address = if index then offset_addr else R[n];\n    if address == Align(address, 8) then\n        data = MemA[address,8];\n        if BigEndian()  then\n            R[t] = data<63:32>;\n            R[t2] = data<31:0>;\n        else\n            R[t] = data<31:0>;\n            R[t2] = data<63:32>;\n    else\n        R[t] = MemA[address,4];\n        R[t2] = MemA[address+4,4];\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "SMLALBB, SMLALBT, SMLALTB, SMLALTT", "short_desc": "Signed Multiply Accumulate Long (halfwords)", "full_desc": "Signed Multiply Accumulate Long (halfwords) multiplies two signed 16-bit values to produce a 32-bit value, and accumulates this with a 64-bit value. The multiply acts on two signed 16-bit quantities, taken from either the bottom or the top half of their respective source registers. The other halves of these source registers are ignored. The 32-bit product is sign-extended and accumulated with a 64-bit accumulate value.", "syntax": ["SMLALBB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALBB", "SMLALBT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALBT", "SMLALTB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALTB", "SMLALTT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALTT", "SMLALBB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALBB", "SMLALBT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALBT", "SMLALTB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALTB", "SMLALTT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLALTT"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<RdLo>\nIs the general-purpose source register holding the lower 32 bits of the addend, and the destination register for the lower 32 bits of the result, encoded in the \"RdLo\" field.", "<RdHi>\nIs the general-purpose source register holding the upper 32 bits of the addend, and the destination register for the upper 32 bits of the result, encoded in the \"RdHi\" field.", "<Rn>\nFor encoding A1: is the first general-purpose source register holding the multiplicand in the bottom or top half (selected by ), encoded in the \"Rn\" field.", "<Rn>\nFor encoding T1: is the first general-purpose source register holding the multiplicand in the bottom or top half (selected by <x>), encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register holding the multiplier in the bottom or top half (selected by ), encoded in the \"Rm\" field.", "<Rm>\nFor encoding T1: is the second general-purpose source register holding the multiplier in the bottom or top half (selected by <x>), encoded in the \"Rm\" field."], "decode": "dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);\nn_high = (N == '1');  m_high = (M == '1');\nif dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif dHi == dLo then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;\n    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;\n    result = SInt(operand1) * SInt(operand2) + SInt(R[dHi]:R[dLo]);\n    R[dHi] = result<63:32>;\n    R[dLo] = result<31:0>;"}, {"mnemonic": "CLZ", "short_desc": "Count Leading Zeros", "full_desc": "Count Leading Zeros returns the number of binary zero bits before the first binary one bit in a value.", "syntax": ["CLZ{<c>}{<q>} <Rd>, <Rm>\t; A1", "CLZ{<c>}{<q>} <Rd>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field.", "<Rm>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rm\" field. It must be encoded with an identical value in the \"Rn\" field."], "decode": "d = UInt(Rd);  m = UInt(Rm);\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = CountLeadingZeroBits(R[m]);\n    R[d] = result<31:0>;"}, {"mnemonic": "VCVTP (Advanced SIMD)", "short_desc": "Vector Convert floating-point to integer with Round towards +Infinity", "full_desc": "Vector Convert floating-point to integer with Round towards +Infinity converts each element in a vector from floating-point to integer using the Round towards +Infinity rounding mode, and places the results in a second vector.", "syntax": ["VCVTP{<q>}.<dt>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVTP{<q>}.<dt>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector", "VCVTP{<q>}.<dt>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVTP{<q>}.<dt>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<dt2>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\nrounding = FPDecodeRM(RM);  unsigned = (op == '1');\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nbits(esize) result;\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,\n                                         StandardFPSCRValue(), rounding);"}, {"mnemonic": "VPADDL", "short_desc": "Vector Pairwise Add Long", "full_desc": "Vector Pairwise Add Long adds adjacent pairs of elements of two vectors, and places the results in the destination vector.", "syntax": ["VPADDL{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VPADDL{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VPADDL{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VPADDL{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nunsigned = (op == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    h = elements DIV 2;\n\n    for r = 0 to regs-1\n        for e = 0 to h-1\n            op1 = Elem[D[m+r],2*e,esize];  op2 = Elem[D[m+r],2*e+1,esize];\n            result = Int(op1, unsigned) + Int(op2, unsigned);\n            Elem[D[d+r],e,2*esize] = result<2*esize-1:0>;"}, {"mnemonic": "CMP (immediate)", "short_desc": "Compare (immediate)", "full_desc": "Compare (immediate) subtracts an immediate value from a register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP{<c>}{<q>} <Rn>, #<const>\t; A1", "CMP{<c>}{<q>} <Rn>, #<imm8>\t; T1", "CMP{<c>}.W <Rn>, #<const>\t; T2", "CMP{<c>}{<q>} <Rn>, #<const>\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is a general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nFor encoding T2: is the general-purpose source register, encoded in the \"Rn\" field.", "<imm8>\nIs a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T2: an immediate value. See  for the range of values."], "decode": "n = UInt(Rn);  imm32 = A32ExpandImm(imm12);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');\n    PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VZIP", "short_desc": "Vector Zip", "full_desc": "Vector Zip interleaves the elements of two vectors.", "syntax": ["VZIP{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VZIP{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VZIP{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VZIP{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' || (Q == '0' && size == '10') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nquadword_operation = (Q == '1');  esize = 8 << UInt(size);\nd = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    if quadword_operation then\n        if d == m then\n            Q[d>>1] = bits(128) UNKNOWN;  Q[m>>1] = bits(128) UNKNOWN;\n        else\n            bits(256) zipped_q;\n            for e = 0 to (128 DIV esize) - 1\n                Elem[zipped_q,2*e,esize] = Elem[Q[d>>1],e,esize];\n                Elem[zipped_q,2*e+1,esize] = Elem[Q[m>>1],e,esize];\n            Q[d>>1] = zipped_q<127:0>;  Q[m>>1] = zipped_q<255:128>;\n    else\n        if d == m then\n            D[d] = bits(64) UNKNOWN;  D[m] = bits(64) UNKNOWN;\n        else\n            bits(128) zipped_d;\n            for e = 0 to (64 DIV esize) - 1\n                Elem[zipped_d,2*e,esize] = Elem[D[d],e,esize];\n                Elem[zipped_d,2*e+1,esize] = Elem[D[m],e,esize];\n            D[d] = zipped_d<63:0>;  D[m] = zipped_d<127:64>;"}, {"mnemonic": "VCVT (between floating-point and fixed-point, Advanced SIMD)", "short_desc": "Vector Convert between floating-point and fixed-point", "full_desc": "Vector Convert between floating-point and fixed-point converts each element in a vector from floating-point to fixed-point, or from fixed-point to floating-point, and places the results in a second vector.", "syntax": ["VCVT{<c>}{<q>}.<dt1>.<dt2> <Dd>, <Dm>, #<fbits>\t; 64-bit SIMD vector", "VCVT{<c>}{<q>}.<dt1>.<dt2> <Qd>, <Qm>, #<fbits>\t; 128-bit SIMD vector", "VCVT{<c>}{<q>}.<dt1>.<dt2> <Dd>, <Dm>, #<fbits>\t; 64-bit SIMD vector", "VCVT{<c>}{<q>}.<dt1>.<dt2> <Qd>, <Qm>, #<fbits>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt1>\n", "<dt2>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<fbits>\nThe number of fraction bits in the fixed point number, in the range 1 to 32 for 32-bit elements, or in the range 1 to 16 for 16-bit elements:"], "decode": "if imm6 == '000xxx' then SEE \"Related encodings\";\nif op<1> == '0' && !HaveFP16Ext() then UNDEFINED;\nif op<1> == '0' && imm6 == '10xxxx' then UNDEFINED;\nif imm6 == '0xxxxx' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nto_fixed = (op<0> == '1');  frac_bits = 64 - UInt(imm6);\nunsigned = (U == '1');\ncase op<1> of\n     when '0' esize = 16; elements = 4;\n     when '1' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    bits(esize) result;\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[m+r],e,esize];\n            if to_fixed then\n                result = FPToFixed(op1, frac_bits, unsigned, StandardFPSCRValue(),\n                                   FPRounding_ZERO);\n            else\n                result = FixedToFP(op1, frac_bits, unsigned, StandardFPSCRValue(),\n                                   FPRounding_TIEEVEN);\n            Elem[D[d+r],e,esize] = result;"}, {"mnemonic": "VDOT (vector)", "short_desc": "BFloat16 floating-point (BF16) dot product (vector)", "full_desc": "BFloat16 floating-point (BF16) dot product (vector). This instruction delimits the source vectors into pairs of 16-bit BF16 elements. Within each pair, the elements in the first source vector are multiplied by the corresponding elements in the second source vector. The resulting single-precision products are then summed and added destructively to the single-precision element in the destination vector which aligns with the pair of BF16 values in the first source vector. The instruction does not update the  exception status.", "syntax": ["VDOT{<q>}.BF16 <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VDOT{<q>}.BF16 <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VDOT{<q>}.BF16 <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VDOT{<q>}.BF16 <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if !HaveAArch32BF16Ext() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(M:Vm);\ninteger regs = if Q == '1' then 2 else 1;", "operation": "bits(64) operand1;\nbits(64) operand2;\nbits(64) result;\n\nCheckAdvSIMDEnabled();\n\nfor r = 0 to regs-1\n    operand1 = Din[n+r];\n    operand2 = Din[m+r];\n    result = Din[d+r];\n    for e = 0 to 1\n        bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];\n        bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];\n        bits(16) elt2_a = Elem[operand2, 2 * e + 0, 16];\n        bits(16) elt2_b = Elem[operand2, 2 * e + 1, 16];\n        bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));\n        Elem[result, e, 32] = BFAdd(Elem[result, e, 32], sum);\n    D[d+r] = result;"}, {"mnemonic": "STREXH", "short_desc": "Store Register Exclusive Halfword", "full_desc": "Store Register Exclusive Halfword derives an address from a base register value, stores a halfword from a register to the derived address if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.", "syntax": ["STREXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; A1", "STREXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the destination general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rd\" field. The value returned is:", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);\nif d == 15 || t == 15 || n == 15 then UNPREDICTABLE;\nif d == n || d == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    if AArch32.ExclusiveMonitorsPass(address,2) then\n        MemA[address,2] = R[t]<15:0>;\n        R[d] = ZeroExtend('0');\n    else\n        R[d] = ZeroExtend('1');"}, {"mnemonic": "ADD (immediate, to PC)", "short_desc": "Add to PC", "syntax": ["ADD{<c>}{<q>} <Rd>, PC, #<const>\t; A1", "ADD{<c>}{<q>} <Rd>, PC, #<imm8>\t; T1", "ADDW{<c>}{<q>} <Rd>, PC, #<imm12>\t; T3", "ADD{<c>}{<q>} <Rd>, PC, #<imm12>\t; T3"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If the PC is used, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see .", "<Rd>\nFor encoding T1 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<label>\nFor encoding A1: the label of an instruction or literal data item whose address is to be loaded into . The assembler calculates the required value of the offset from the  value of the  instruction to this label.", "<label>\nFor encoding T1: the label of an instruction or literal data item whose address is to be loaded into . The assembler calculates the required value of the offset from the  value of the  instruction to this label. Permitted values of the size of the offset are multiples of 4 in the range 0 to 1020.", "<label>\nFor encoding T3: the label of an instruction or literal data item whose address is to be loaded into . The assembler calculates the required value of the offset from the  value of the  instruction to this label.", "<imm8>\nIs an unsigned immediate, a multiple of 4, in the range 0 to 1020, encoded in the \"imm8\" field as <imm8>/4.", "<imm12>\nIs a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.", "<const>\nAn immediate value. See  for the range of values."]}, {"mnemonic": "VMUL (floating-point)", "short_desc": "Vector Multiply (floating-point)", "full_desc": "Vector Multiply multiplies corresponding elements in two vectors, and places the results in the destination vector.", "syntax": ["VMUL{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMUL{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VMUL{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar", "VMUL{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMUL{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VMUL{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nadvsimd = TRUE;\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if advsimd then  // Advanced SIMD instruction\n        for r = 0 to regs-1\n            for e = 0 to elements-1\n                Elem[D[d+r],e,esize] = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());\n    else             // VFP instruction\n        case esize of\n            when 16\n                S[d] = Zeros(16) : FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);\n            when 32\n                S[d] = FPMul(S[n], S[m], FPSCR);\n            when 64\n                D[d] = FPMul(D[n], D[m], FPSCR);"}, {"mnemonic": "UXTB", "short_desc": "Unsigned Extend Byte", "full_desc": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to 32 bits, and writes the result to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.", "syntax": ["UXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; A1", "UXTB{<c>}{<q>} {<Rd>,} <Rm>\t; T1", "UXTB{<c>}.W {<Rd>,} <Rm>\t; T2", "UXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d] = ZeroExtend(rotated<7:0>, 32);"}, {"mnemonic": "PSSBB", "short_desc": "Physical Speculative Store Bypass Barrier", "full_desc": "Physical Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing earlier stores to the same physical address.", "syntax": ["PSSBB{<q>}\t; A1", "PSSBB{<q>}\t; T1"], "symbols": ["<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    SpeculativeStoreBypassBarrierToPA();"}, {"mnemonic": "VSTR", "short_desc": "Store SIMD&FP register", "full_desc": "Store SIMD&FP register stores a single register from the Advanced SIMD and floating-point register file to memory, using an address from a general-purpose register, with an optional offset.", "syntax": ["VSTR{<c>}{<q>}.16 <Sd>, [<Rn>{, #{+/-}<imm>}]\t; Half-precision scalar", "VSTR{<c>}{<q>}{.32} <Sd>, [<Rn>{, #{+/-}<imm>}]\t; Single-precision scalar", "VSTR{<c>}{<q>}{.64} <Dd>, [<Rn>{, #{+/-}<imm>}]\t; Double-precision scalar", "VSTR{<c>}{<q>}.16 <Sd>, [<Rn>{, #{+/-}<imm>}]\t; Half-precision scalar", "VSTR{<c>}{<q>}{.32} <Sd>, [<Rn>{, #{+/-}<imm>}]\t; Single-precision scalar", "VSTR{<c>}{<q>}{.64} <Dd>, [<Rn>{, #{+/-}<imm>}]\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", ".64\nIs an optional data size specifier for 64-bit memory accesses that can be used in the assembler source code, but is otherwise ignored.", "<Dd>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"D:Vd\" field.", ".32\nIs an optional data size specifier for 32-bit memory accesses that can be used in the assembler source code, but is otherwise ignored.", "<Sd>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vd:D\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "+/-\n", "<imm>\nFor the single-precision scalar or double-precision scalar variants: is the optional unsigned immediate byte offset, a multiple of 4, in the range 0 to 1020, defaulting to 0, and encoded in the \"imm8\" field as <imm>/4."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nesize = 8 << UInt(size);  add = (U == '1');\nimm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);\ncase size of\n    when '01' d = UInt(Vd:D);\n    when '10' d = UInt(Vd:D);\n    when '11' d = UInt(D:Vd);\nn = UInt(Rn);\nif n == 15 && CurrentInstrSet() != InstrSet_A32 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    address = if add then (R[n] + imm32) else (R[n] - imm32);\n    case esize of\n        when 16\n            MemA[address,2] = S[d]<15:0>;\n        when 32\n            MemA[address,4] = S[d];\n        when 64\n            // Store as two word-aligned words in the correct order for current endianness.\n            MemA[address,4]   = if BigEndian() then D[d]<63:32> else D[d]<31:0>;\n            MemA[address+4,4] = if BigEndian() then D[d]<31:0>  else D[d]<63:32>;"}, {"mnemonic": "TST (immediate)", "short_desc": "Test (immediate)", "full_desc": "Test (immediate) performs a bitwise AND operation on a register value and an immediate value. It updates the condition flags based on the result, and discards the result.", "syntax": ["TST{<c>}{<q>} <Rn>, #<const>\t; A1", "TST{<c>}{<q>} <Rn>, #<const>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "n = UInt(Rn);\n(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = R[n] AND imm32;\n    PSTATE.N = result<31>;\n    PSTATE.Z = IsZeroBit(result);\n    PSTATE.C = carry;\n    // PSTATE.V unchanged"}, {"mnemonic": "VMSR", "short_desc": "Move general-purpose register to SIMD&FP Special register", "full_desc": "Move general-purpose register to SIMD&FP Special register moves the value of a general-purpose register to a floating-point System register.", "syntax": ["VMSR{<c>}{<q>} <spec_reg>, <Rt>\t; A1", "VMSR{<c>}{<q>} <spec_reg>, <Rt>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<spec_reg>\n", "<Rt>\nIs the general-purpose source register, encoded in the \"Rt\" field."], "decode": "t = UInt(Rt);\nif reg != '000x' && reg != '1000' then\n    Constraint c = ConstrainUnpredictable(Unpredictable_VMSR);\n    assert c IN {Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNDEF\n            UNDEFINED;\n        when Constraint_NOP\n            EndOfInstruction();\nif t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if reg == '0001' then                 // FPSCR\n        CheckVFPEnabled(TRUE);\n        FPSCR = R[t];\n    elsif PSTATE.EL == EL0 then\n        UNDEFINED;                        // Non-FPSCR registers accessible only at PL1 or above\n    else\n        CheckVFPEnabled(FALSE);           // Non-FPSCR registers are not affected by FPEXC.EN\n        case reg of\n            when '0000'                   // VMSR access to FPSID is ignored\n            when '1000'  FPEXC = R[t];\n            otherwise    Unreachable();   // Dealt with above or in encoding-specific pseudocode"}, {"mnemonic": "LDRB (literal)", "short_desc": "Load Register Byte (literal)", "full_desc": "Load Register Byte (literal) calculates an address from the PC value and an immediate offset, loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRB{<c>}{<q>} <Rt>, <label>\t; A1", "LDRB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; A1", "LDRB{<c>}{<q>} <Rt>, <label>\t; T1", "LDRB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<label>\nThe label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Permitted values of the offset are -4095 to 4095.", "+/-\n", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "if P == '0' && W == '1' then SEE \"LDRBT\";\nt = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);\nadd = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 || wback then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    base = Align(PC,4);\n    address = if add then (base + imm32) else (base - imm32);\n    R[t] = ZeroExtend(MemU[address,1], 32);"}, {"mnemonic": "RSB, RSBS (register-shifted register)", "short_desc": "Reverse Subtract (register-shifted register)", "full_desc": "Reverse Subtract (register-shifted register) subtracts a register value from a register-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.", "syntax": ["RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');\n    R[d] = result;\n    if setflags then\n        PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "LDAEXH", "short_desc": "Load-Acquire Exclusive Halfword", "full_desc": "Load-Acquire Exclusive Halfword loads a halfword from memory, zero-extends it to form a 32-bit word, writes it to a register and:", "syntax": ["LDAEXH{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "LDAEXH{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    AArch32.SetExclusiveMonitors(address, 2);\n    R[t] = ZeroExtend(MemO[address, 2], 32);"}, {"mnemonic": "VRINTX (floating-point)", "short_desc": "Round floating-point to integer inexact", "full_desc": "Round floating-point to integer inexact rounds a floating-point value to an integral floating-point value of the same size, using the rounding mode specified in the FPSCR, and raises an Inexact exception when the result value is not numerically equal to the input value. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTX{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTX{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTX{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VRINTX{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTX{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTX{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nexact = TRUE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\n    rounding = FPRoundingMode(FPSCR);\n    case esize of\n        when 16\n            S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);\n        when 32\n            S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);\n        when 64\n            D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);"}, {"mnemonic": "UXTB16", "short_desc": "Unsigned Extend Byte 16", "full_desc": "Unsigned Extend Byte 16 extracts two 8-bit values from a register, zero-extends them to 16 bits each, and writes the results to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit values.", "syntax": ["UXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; A1", "UXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field.", "<Rm>\nFor encoding T1: is the second general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d]<15:0>  = ZeroExtend(rotated<7:0>, 16);\n    R[d]<31:16> = ZeroExtend(rotated<23:16>, 16);"}, {"mnemonic": "STRB (register)", "short_desc": "Store Register Byte (register)", "full_desc": "Store Register Byte (register) calculates an address from a base register value and an offset register value, and stores a byte from a register to memory. The offset register value can optionally be shifted. For information about memory accesses see .", "syntax": ["STRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]\t; Offset", "STRB{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}\t; Post-indexed", "STRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!\t; Pre-indexed", "STRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]\t; T1", "STRB{<c>}.W <Rt>, [<Rn>, {+}<Rm>]\t; T2", "STRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant, but this is deprecated.", "<Rn>\nFor encoding T1 and T2: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\nThe shift to apply to the value read from . If absent, no shift is applied. Otherwise, see .", "<imm>\nIf present, the size of the left shift to apply to the value from , in the range 1-3.  is encoded in imm2. If absent, no shift is specified and imm2 is encoded as ."], "decode": "if P == '0' && W == '1' then SEE \"STRBT\";\nt = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);\nif t == 15 || m == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if index then offset_addr else R[n];\n    MemU[address,1] = R[t]<7:0>;\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "SHA1M", "short_desc": "SHA1 hash update (majority)", "full_desc": "SHA1 hash update (majority).", "syntax": ["SHA1M.32 <Qd>, <Qn>, <Qm>\t; A1", "SHA1M.32 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA1Ext() then UNDEFINED;\nif Q != '1' then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    X = Q[d>>1];\n    Y = Q[n>>1]<31:0>; // Note: 32 bits wide\n    W = Q[m>>1];\n    for e = 0 to 3\n        t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);\n        Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n        X<63:32> = ROL(X<63:32>, 30);\n        <Y, X> = ROL(Y:X, 32);\n    Q[d>>1] = X;"}, {"mnemonic": "VLD1 (multiple single elements)", "short_desc": "Load multiple single 1-element structures to one, two, three, or four registers", "full_desc": "Load multiple single 1-element structures to one, two, three, or four registers loads elements from memory into one, two, three, or four registers, without de-interleaving. Every element of each register is loaded. For details of the addressing mode see .", "syntax": ["VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2, A3 and A4: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2, T3 and T4: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "regs = 1;  if align<1> == '1' then UNDEFINED;\nalignment = if align == '00' then 1 else 4 << UInt(align);\nebytes = 1 << UInt(size);  elements = 8 DIV ebytes;\nd = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d+regs > 32 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            bits(ebytes*8) data;\n            if ebytes != 8 then\n                data = MemU[address,ebytes];\n            else\n                - = AArch32.CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);\n                data<31:0> = if BigEndian() then MemU[address+4,4] else MemU[address,4];\n                data<63:32> = if BigEndian() then MemU[address,4] else MemU[address+4,4];\n            Elem[D[d+r],e] = data;\n            address = address + ebytes;\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 8*regs;"}, {"mnemonic": "SB", "short_desc": "Speculation Barrier", "full_desc": "Speculation Barrier is a barrier that controls speculation.", "syntax": ["SB{<q>}\t; A1", "SB{<q>}\t; T1"], "symbols": ["<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    SpeculationBarrier();"}, {"mnemonic": "VRINTM (floating-point)", "short_desc": "Round floating-point to integer towards -Infinity", "full_desc": "Round floating-point to integer towards -Infinity rounds a floating-point value to an integral floating-point value of the same size using the Round towards -Infinity rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTM{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTM{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTM{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VRINTM{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTM{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTM{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nrounding = FPDecodeRM(RM);  exact = FALSE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\ncase esize of\n    when 16\n        S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);\n    when 32\n        S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);\n    when 64\n        D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);"}, {"mnemonic": "RSB, RSBS (immediate)", "short_desc": "Reverse Subtract (immediate)", "full_desc": "Reverse Subtract (immediate) subtracts a register value from an immediate value, and writes the result to the destination register.", "syntax": ["RSB{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; RSB", "RSBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; RSBS", "RSB<c>{<q>} {<Rd>, }<Rn>, #0\t; T1", "RSBS{<q>} {<Rd>, }<Rn>, #0\t; T1", "RSB<c>.W {<Rd>,} <Rn>, #0\t; RSB", "RSB{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; RSB", "RSBS.W {<Rd>,} <Rn>, #0\t; RSBS", "RSBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; RSBS"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1 and T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1 and T2: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T2: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result, nzcv) = AddWithCarry(NOT(R[n]), imm32, '1');\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "PUSH (multiple registers)", "short_desc": "Push multiple registers to Stack", "syntax": ["PUSH{<c>}{<q>} <registers>\t; A1", "PUSH{<c>}.W <registers>\t; T1", "PUSH{<c>}{<q>} <registers>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<registers>\nFor encoding A1: is a list of two or more registers to be stored, separated by commas and surrounded by { and }. The lowest-numbered register is stored to the lowest memory address, through to the highest-numbered register to the highest memory address. See also .", "<registers>\nFor encoding T1: is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The lowest-numbered register is stored to the lowest memory address, through to the highest-numbered register to the highest memory address. See also ."]}, {"mnemonic": "VRSHR (zero)", "short_desc": "Vector Rounding Shift Right", "syntax": ["VRSHR{<c>}{<q>}.<dt> <Dd>, <Dm>, #0\t; 64-bit SIMD vector", "VRSHR{<c>}{<q>}.<dt> <Qd>, <Qm>, #0\t; 128-bit SIMD vector", "VRSHR{<c>}{<q>}.<dt> <Dd>, <Dm>, #0\t; 64-bit SIMD vector", "VRSHR{<c>}{<q>}.<dt> <Qd>, <Qm>, #0\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nIs the data type for the elements of the vectors, and must be one of: S8, S16, S32, S64, U8, U16, U32 or U64.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"N:Vn\" and \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"N:Vn\" and \"M:Vm\" field."]}, {"mnemonic": "SHASX", "short_desc": "Signed Halving Add and Subtract with Exchange", "full_desc": "Signed Halving Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one signed 16-bit integer addition and one signed 16-bit subtraction, halves the results, and writes the results to the destination register.", "syntax": ["SHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);\n    sum  = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);\n    R[d]<15:0>  = diff<16:1>;\n    R[d]<31:16> = sum<16:1>;"}, {"mnemonic": "LDREXD", "short_desc": "Load Register Exclusive Doubleword", "full_desc": "Load Register Exclusive Doubleword derives an address from a base register value, loads a 64-bit doubleword from memory, writes it to two registers and:", "syntax": ["LDREXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]\t; A1", "LDREXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.  must be even-numbered and not R14.", "<Rt>\nFor encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nFor encoding A1: is the second general-purpose register to be transferred.  must be .", "<Rt2>\nFor encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt);  t2 = t + 1;  n = UInt(Rn);\nif Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    AArch32.SetExclusiveMonitors(address,8);\n    value = MemA[address,8];\n    // Extract words from 64-bit loaded value such that R[t] is\n    // loaded from address and R[t2] from address+4.\n    R[t]  = if BigEndian() then value<63:32> else value<31:0>;\n    R[t2] = if BigEndian() then value<31:0> else value<63:32>;"}, {"mnemonic": "VST3 (multiple 3-element structures)", "short_desc": "Store multiple 3-element structures from three registers", "full_desc": "Store multiple 3-element structures from three registers stores multiple 3-element structures to memory from three registers, with interleaving. For more information, see . Every element of each register is saved. For details of the addressing mode see .", "syntax": ["VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' || align<1> == '1' then UNDEFINED;\ncase itype of\n    when '0100'\n        inc = 1;\n    when '0101'\n        inc = 2;\n    otherwise\n        SEE \"Related encodings\";\nalignment = if align<0> == '0' then 1 else 8;\nebytes = 1 << UInt(size);  elements = 8 DIV ebytes;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d3 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = TRUE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    for e = 0 to elements-1\n        MemU[address,         ebytes] = Elem[D[d], e];\n        MemU[address+ebytes,  ebytes] = Elem[D[d2],e];\n        MemU[address+2*ebytes,ebytes] = Elem[D[d3],e];\n        address = address + 3*ebytes;\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 24;"}, {"mnemonic": "VADD (integer)", "short_desc": "Vector Add (integer)", "full_desc": "Vector Add (integer) adds corresponding elements in two vectors, and places the results in the destination vector.", "syntax": ["VADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] + Elem[D[m+r],e,esize];"}, {"mnemonic": "SUB (immediate, from PC)", "short_desc": "Subtract from PC", "syntax": ["SUB{<c>}{<q>} <Rd>, PC, #<const>\t; A2", "SUB{<c>}{<q>} <Rd>, PC, #<imm12>\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A2: is the general-purpose destination register, encoded in the \"Rd\" field. If the PC is used, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see .", "<Rd>\nFor encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field.", "<label>\nFor encoding A2: the label of an instruction or literal data item whose address is to be loaded into . The assembler calculates the required value of the offset from the  value of the  instruction to this label.", "<label>\nFor encoding T2: the label of an instruction or literal data item whose address is to be loaded into . The assembler calculates the required value of the offset from the  value of the  instruction to this label.", "<imm12>\nIs a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.", "<const>\nAn immediate value. See  for the range of values."]}, {"mnemonic": "LSRS (register)", "short_desc": "Logical Shift Right, setting flags (register)", "syntax": ["LSRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Flag setting", "LSRS{<q>} {<Rdm>,} <Rdm>, <Rs>\t; Logical shift right", "LSRS.W {<Rd>,} <Rm>, <Rs>\t; Flag setting", "LSRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rs>\nIs the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."]}, {"mnemonic": "VCVTN (Advanced SIMD)", "short_desc": "Vector Convert floating-point to integer with Round to Nearest", "full_desc": "Vector Convert floating-point to integer with Round to Nearest converts each element in a vector from floating-point to integer using the Round to Nearest rounding mode, and places the results in a second vector.", "syntax": ["VCVTN{<q>}.<dt>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVTN{<q>}.<dt>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector", "VCVTN{<q>}.<dt>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVTN{<q>}.<dt>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<dt2>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\nrounding = FPDecodeRM(RM);  unsigned = (op == '1');\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nbits(esize) result;\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,\n                                         StandardFPSCRValue(), rounding);"}, {"mnemonic": "VQRSHRN, VQRSHRUN", "short_desc": "Vector Saturating Rounding Shift Right, Narrow", "full_desc": "Vector Saturating Rounding Shift Right, Narrow takes each element in a quadword vector of integers, right shifts them by an immediate value, and places the rounded results in a doubleword vector.", "syntax": ["VQRSHRN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>\t; Signed result", "VQRSHRUN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>\t; Unsigned result", "VQRSHRN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>\t; Signed result", "VQRSHRUN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>\t; Unsigned result"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\n", "<type>\n", "<size>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<imm>\nIs an immediate value, in the range 1 to /2, encoded in the \"imm6\" field as /2 - ."], "decode": "if imm6 == '000xxx' then SEE \"Related encodings\";\nif U == '0' && op == '0' then SEE \"VRSHRN\";\nif Vm<0> == '1' then UNDEFINED;\ncase imm6 of\n    when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);\n    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);\n    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);\nsrc_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');\nd = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    round_const = 1 << (shift_amount - 1);\n    for e = 0 to elements-1\n        operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);\n        (result, sat) = SatQ((operand + round_const) >> shift_amount, esize, dest_unsigned);\n        Elem[D[d],e,esize] = result;\n        if sat then FPSCR.QC = '1';"}, {"mnemonic": "SEL", "short_desc": "Select Bytes", "full_desc": "Select Bytes selects each byte of its result from either its first operand or its second operand, according to the values of the .GE flags.", "syntax": ["SEL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SEL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    R[d]<7:0>   = if PSTATE.GE<0> == '1' then R[n]<7:0>   else R[m]<7:0>;\n    R[d]<15:8>  = if PSTATE.GE<1> == '1' then R[n]<15:8>  else R[m]<15:8>;\n    R[d]<23:16> = if PSTATE.GE<2> == '1' then R[n]<23:16> else R[m]<23:16>;\n    R[d]<31:24> = if PSTATE.GE<3> == '1' then R[n]<31:24> else R[m]<31:24>;"}, {"mnemonic": "AESIMC", "short_desc": "AES inverse mix columns", "full_desc": "AES inverse mix columns.", "syntax": ["AESIMC.<dt> <Qd>, <Qm>\t; A1", "AESIMC.<dt> <Qd>, <Qm>\t; T1"], "symbols": ["<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAESExt() then UNDEFINED;\nif size != '00' then UNDEFINED;\nif Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    Q[d>>1] = AESInvMixColumns(Q[m>>1]);"}, {"mnemonic": "VADDHN", "short_desc": "Vector Add and Narrow, returning High Half", "full_desc": "Vector Add and Narrow, returning High Half adds corresponding elements in two quadword vectors, and places the most significant half of each result in a doubleword vector. The results are truncated. For rounded results, see .", "syntax": ["VADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>\t; A1", "VADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize];\n        Elem[D[d],e,esize] = result<2*esize-1:esize>;"}, {"mnemonic": "MOVT", "short_desc": "Move Top", "full_desc": "Move Top writes an immediate value to the top halfword of the destination register. It does not affect the contents of the bottom halfword.", "syntax": ["MOVT{<c>}{<q>} <Rd>, #<imm16>\t; A1", "MOVT{<c>}{<q>} <Rd>, #<imm16>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<imm16>\nFor encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm4:imm12\" field.", "<imm16>\nFor encoding T1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm4:i:imm3:imm8\" field."], "decode": "d = UInt(Rd);  imm16 = imm4:imm12;\nif d == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    R[d]<31:16> = imm16;\n    // R[d]<15:0> unchanged"}, {"mnemonic": "VCVT (between floating-point and fixed-point, floating-point)", "short_desc": "Convert between floating-point and fixed-point", "full_desc": "Convert between floating-point and fixed-point converts a value in a register from floating-point to fixed-point, or from fixed-point to floating-point. Software can specify the fixed-point value as either signed or unsigned.", "syntax": ["VCVT{<c>}{<q>}.F16.<dt> <Sdm>, <Sdm>, #<fbits>\t; Half-precision scalar", "VCVT{<c>}{<q>}.<dt>.F16 <Sdm>, <Sdm>, #<fbits>\t; Half-precision scalar", "VCVT{<c>}{<q>}.F32.<dt> <Sdm>, <Sdm>, #<fbits>\t; Single-precision scalar", "VCVT{<c>}{<q>}.<dt>.F32 <Sdm>, <Sdm>, #<fbits>\t; Single-precision scalar", "VCVT{<c>}{<q>}.F64.<dt> <Ddm>, <Ddm>, #<fbits>\t; Double-precision scalar", "VCVT{<c>}{<q>}.<dt>.F64 <Ddm>, <Ddm>, #<fbits>\t; Double-precision scalar", "VCVT{<c>}{<q>}.F16.<dt> <Sdm>, <Sdm>, #<fbits>\t; Half-precision scalar", "VCVT{<c>}{<q>}.<dt>.F16 <Sdm>, <Sdm>, #<fbits>\t; Half-precision scalar", "VCVT{<c>}{<q>}.F32.<dt> <Sdm>, <Sdm>, #<fbits>\t; Single-precision scalar", "VCVT{<c>}{<q>}.<dt>.F32 <Sdm>, <Sdm>, #<fbits>\t; Single-precision scalar", "VCVT{<c>}{<q>}.F64.<dt> <Ddm>, <Ddm>, #<fbits>\t; Double-precision scalar", "VCVT{<c>}{<q>}.<dt>.F64 <Ddm>, <Ddm>, #<fbits>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<dt>\n", "<Sdm>\nIs the 32-bit name of the SIMD&FP destination and source register, encoded in the \"Vd:D\" field.", "<Ddm>\nIs the 64-bit name of the SIMD&FP destination and source register, encoded in the \"D:Vd\" field.", "<fbits>\nThe number of fraction bits in the fixed-point number:"], "decode": "if sf == '00' || (sf == '01' && !HaveFP16Ext()) then UNDEFINED;\nif sf == '01' && cond != '1110' then UNPREDICTABLE;\nto_fixed = (op == '1');  unsigned = (U == '1');\nsize = if sx == '0' then 16 else 32;\nfrac_bits = size - UInt(imm4:i);\ncase sf of\n    when '01' fp_size = 16; d = UInt(Vd:D);\n    when '10' fp_size = 32; d = UInt(Vd:D);\n    when '11' fp_size = 64; d = UInt(D:Vd);\n\nif frac_bits < 0 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    if to_fixed then\n        bits(size) result;\n        case fp_size of\n            when 16\n                result = FPToFixed(S[d]<15:0>, frac_bits, unsigned, FPSCR, FPRounding_ZERO);\n                S[d] = Extend(result, 32, unsigned);\n            when 32\n                result = FPToFixed(S[d], frac_bits, unsigned, FPSCR, FPRounding_ZERO);\n                S[d] = Extend(result, 32, unsigned);\n            when 64\n                result = FPToFixed(D[d], frac_bits, unsigned, FPSCR, FPRounding_ZERO);\n                D[d] = Extend(result, 64, unsigned);\n    else\n        case fp_size of\n            when 16\n                bits(16) fp16 = FixedToFP(S[d]<size-1:0>, frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);\n                S[d] = Zeros(16):fp16;\n            when 32\n                S[d] = FixedToFP(S[d]<size-1:0>, frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);\n            when 64\n                D[d] = FixedToFP(D[d]<size-1:0>, frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);"}, {"mnemonic": "VRHADD", "short_desc": "Vector Rounding Halving Add", "full_desc": "Vector Rounding Halving Add adds corresponding elements in two vectors of integers, shifts each result right one bit, and places the final results in the destination vector.", "syntax": ["VRHADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VRHADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VRHADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VRHADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '11' then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Int(Elem[D[n+r],e,esize], unsigned);\n            op2 = Int(Elem[D[m+r],e,esize], unsigned);\n            result = op1 + op2 + 1;\n            Elem[D[d+r],e,esize] = result<esize:1>;"}, {"mnemonic": "QSUB16", "short_desc": "Saturating Subtract 16", "full_desc": "Saturating Subtract 16 performs two 16-bit integer subtractions, saturates the results to the 16-bit signed integer range -2 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["QSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "QSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);\n    diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);\n    R[d]<15:0>  = SignedSat(diff1, 16);\n    R[d]<31:16> = SignedSat(diff2, 16);"}, {"mnemonic": "VUSDOT (vector)", "short_desc": "Dot Product vector form with mixed-sign integers", "full_desc": "Dot Product vector form with mixed-sign integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in the corresponding 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["VUSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VUSDOT{<q>}.S8 <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VUSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VUSDOT{<q>}.S8 <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP third source and destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP third source and destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if !HaveAArch32Int8MatMulExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(M:Vm);\ninteger regs = if Q == '1' then 2 else 1;", "operation": "CheckAdvSIMDEnabled();\nbits(64) operand1;\nbits(64) operand2;\nbits(64) result;\n\nfor r = 0 to regs-1\n    operand1 = Din[n+r];\n    operand2 = Din[m+r];\n    result = Din[d+r];\n    for e = 0 to 1\n        bits(32) res = Elem[result, e, 32];\n        for b = 0 to 3\n            element1 = UInt(Elem[operand1, 4 * e + b, 8]);\n            element2 = SInt(Elem[operand2, 4 * e + b, 8]);\n            res = res + element1 * element2;\n        Elem[result, e, 32] = res;\n    D[d+r] = result;"}, {"mnemonic": "UQASX", "short_desc": "Unsigned Saturating Add and Subtract with Exchange", "full_desc": "Unsigned Saturating Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one unsigned 16-bit integer addition and one unsigned 16-bit subtraction, saturates the results to the 16-bit unsigned integer range 0 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["UQASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UQASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);\n    sum  = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);\n    R[d]<15:0>  = UnsignedSat(diff, 16);\n    R[d]<31:16> = UnsignedSat(sum, 16);"}, {"mnemonic": "MSR (register)", "short_desc": "Move general-purpose register to Special register", "full_desc": "Move general-purpose register to Special register moves selected bits of a general-purpose register to the ,  or _<current_mode>.", "syntax": ["MSR{<c>}{<q>} <spec_reg>, <Rn>\t; A1", "MSR{<c>}{<q>} <spec_reg>, <Rn>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<spec_reg>\nIs one of:", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field."], "decode": "n = UInt(Rn);  write_spsr = (R == '1');\nif mask == '0000' then UNPREDICTABLE;\nif n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if write_spsr then\n        if PSTATE.M IN {M32_User,M32_System} then\n            UNPREDICTABLE;\n        else\n            SPSRWriteByInstr(R[n], mask);\n    else\n        // Attempts to change to an illegal mode will invoke the Illegal Execution state mechanism\n        CPSRWriteByInstr(R[n], mask);"}, {"mnemonic": "VTST", "short_desc": "Vector Test Bits", "full_desc": "Vector Test Bits takes each element in a vector, and bitwise ANDs it with the corresponding element of a second vector. If the result is not zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VTST{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VTST{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VTST{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VTST{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '11' then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if !IsZero(Elem[D[n+r],e,esize] AND Elem[D[m+r],e,esize]) then\n                Elem[D[d+r],e,esize] = Ones(esize);\n            else\n                Elem[D[d+r],e,esize] = Zeros(esize);"}, {"mnemonic": "WFE", "short_desc": "Wait For Event", "full_desc": "Wait For Event is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. Wakeup events include the event signaled as a result of executing the  instruction on any PE in the multiprocessor system. For more information, see .", "syntax": ["WFE{<c>}{<q>}\t; A1", "WFE{<c>}{<q>}\t; T1", "WFE{<c>}.W\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if IsEventRegisterSet() then\n        ClearEventRegister();\n    else\n        if PSTATE.EL == EL0 then\n            // Check for traps described by the OS which may be EL1 or EL2.\n            AArch32.CheckForWFxTrap(EL1, TRUE);\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n            // Check for traps described by the Hypervisor.\n            AArch32.CheckForWFxTrap(EL2, TRUE);\n        if HaveEL(EL3) && PSTATE.M != M32_Monitor then\n            // Check for traps described by the Secure Monitor.\n            AArch32.CheckForWFxTrap(EL3, TRUE);\n        WaitForEvent();"}, {"mnemonic": "VFMAB, VFMAT (BFloat16, vector)", "short_desc": "BFloat16 floating-point widening multiply-add long (vector)", "full_desc": "The Bfloat16 floating-point widening multiply-add long instruction widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first and second source vectors from Bfloat16 to single-precision format. The instruction then multiplies and adds these values to the overlapping single-precision elements of the destination vector.", "syntax": ["VFMA<bt>{<q>}.BF16 <Qd>, <Qn>, <Qm>\t; A1", "VFMA<bt>{<q>}.BF16 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<bt>\n", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAArch32BF16Ext() then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(M:Vm);\ninteger elements = 128 DIV 32;\ninteger sel = UInt(Q);", "operation": "CheckAdvSIMDEnabled();\nbits(128) operand1 = Q[n>>1];\nbits(128) operand2 = Q[m>>1];\nbits(128) operand3 = Q[d>>1];\nbits(128) result;\n\nfor e = 0 to elements-1\n    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);\n    bits(32) element2 = Elem[operand2, 2 * e + sel, 16] : Zeros(16);\n    bits(32) addend = Elem[operand3, e, 32];\n    Elem[result, e, 32] = FPMulAdd(addend, element1, element2,\n                                   StandardFPSCRValue());\n\nQ[d>>1] = result;"}, {"mnemonic": "VMULL (integer and polynomial)", "short_desc": "Vector Multiply Long (integer and polynomial)", "full_desc": "Vector Multiply Long multiplies corresponding elements in two vectors. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["VMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; A1", "VMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nunsigned = (U == '1'); polynomial = (op == '1'); long_destination = TRUE;\nesize = 8 << UInt(size); elements = 64 DIV esize;\nif polynomial then\n    if U == '1' || size == '01' then UNDEFINED;\n    if size == '10' then    // .p64\n        if !HaveBit128PMULLExt() then UNDEFINED;\n        esize = 64; elements = 1;\nif Vd<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);\n            op2 = Elem[Din[m+r],e,esize];  op2val = Int(op2, unsigned);\n            if polynomial then\n                product = PolynomialMult(op1,op2);\n            else\n                product = (op1val*op2val)<2*esize-1:0>;\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = product;\n            else\n                Elem[D[d+r],e,esize] = product<esize-1:0>;"}, {"mnemonic": "LDRB (immediate)", "short_desc": "Load Register Byte (immediate)", "full_desc": "Load Register Byte (immediate) calculates an address from a base register value and an immediate offset, loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing.  For information about memory accesses see .", "syntax": ["LDRB{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "LDRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1", "LDRB{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]\t; T2", "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T2", "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]\t; Offset", "LDRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1, T2 and T3: is the general-purpose base register, encoded in the \"Rn\" field. For PC use see .", "<Rn>\nFor encoding T1: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is an optional 5-bit unsigned immediate byte offset, in the range 0 to 31, defaulting to 0 and encoded in the \"imm5\" field.", "<imm>\nFor encoding T2: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T3: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field."], "decode": "if Rn == '1111' then SEE \"LDRB (literal)\";\nif P == '0' && W == '1' then SEE \"LDRBT\";\nt = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 || (wback && n == t) then UNPREDICTABLE;", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        R[t] = ZeroExtend(MemU[address,1], 32);\n        if wback then R[n] = offset_addr;\nelse\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        R[t] = ZeroExtend(MemU[address,1], 32);\n        if wback then R[n] = offset_addr;"}, {"mnemonic": "STLEX", "short_desc": "Store-Release Exclusive Word", "full_desc": "Store-Release Exclusive Word stores a word from a register to memory if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.", "syntax": ["STLEX{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; A1", "STLEX{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the destination general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rd\" field. The value returned is:", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);\nif d == 15 || t == 15 || n == 15 then UNPREDICTABLE;\nif d == n || d == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    if AArch32.ExclusiveMonitorsPass(address,4) then\n        MemO[address, 4] = R[t];\n        R[d] = ZeroExtend('0');\n    else\n        R[d] = ZeroExtend('1');"}, {"mnemonic": "ORR, ORRS (immediate)", "short_desc": "Bitwise OR (immediate)", "full_desc": "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and an immediate value, and writes the result to the destination register.", "syntax": ["ORR{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ORR", "ORRS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ORRS", "ORR{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ORR", "ORRS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ORRS"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');\n(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = R[n] OR imm32;\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "VMRS", "short_desc": "Move SIMD&FP Special register to general-purpose register", "full_desc": "Move SIMD&FP Special register to general-purpose register moves the value of an Advanced SIMD and floating-point System register to a general-purpose register. When the specified System register is the , a form of the instruction transfers the .{N, Z, C, V} condition flags to the .{N, Z, C, V} condition flags.", "syntax": ["VMRS{<c>}{<q>} <Rt>, <spec_reg>\t; A1", "VMRS{<c>}{<q>} <Rt>, <spec_reg>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose destination register, encoded in the \"Rt\" field. Is one of:", "<spec_reg>\n"], "decode": "t = UInt(Rt);\nif !(reg IN {'000x', '0101', '011x', '1000'}) then UNPREDICTABLE;\nif t == 15 && reg != '0001' then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if reg == '0001' then                 // FPSCR\n        CheckVFPEnabled(TRUE);\n        if t == 15 then\n            PSTATE.<N,Z,C,V> = FPSR.<N,Z,C,V>;\n        else\n            R[t] = FPSCR;\n    elsif PSTATE.EL == EL0 then\n        UNDEFINED;                        // Non-FPSCR registers accessible only at PL1 or above\n    else\n        CheckVFPEnabled(FALSE);           // Non-FPSCR registers are not affected by FPEXC.EN\n        AArch32.CheckAdvSIMDOrFPRegisterTraps(reg);\n        case reg of\n            when '0000'  R[t] = FPSID;\n            when '0101'  R[t] = MVFR2;\n            when '0110'  R[t] = MVFR1;\n            when '0111'  R[t] = MVFR0;\n            when '1000'  R[t] = FPEXC;\n            otherwise    Unreachable();   // Dealt with above or in encoding-specific pseudocode"}, {"mnemonic": "FSTMDBX, FSTMIAX", "short_desc": "FSTMX", "full_desc": "FSTMX stores multiple SIMD&FP registers from the Advanced SIMD and floating-point register file to consecutive locations in using an address from a general-purpose register.", "syntax": ["FSTMDBX{<c>}{<q>} <Rn>!, <dreglist>\t; Decrement Before", "FSTMIAX{<c>}{<q>} <Rn>{!}, <dreglist>\t; Increment After", "FSTMDBX{<c>}{<q>} <Rn>!, <dreglist>\t; Decrement Before", "FSTMIAX{<c>}{<q>} <Rn>{!}, <dreglist>\t; Increment After"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. If writeback is not specified, the PC can be used. However, Arm deprecates use of the PC.", "!\nSpecifies base register writeback. Encoded in the \"W\" field as 1 if present, otherwise 0.", "<dreglist>\nIs the list of consecutively numbered 64-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"D:Vd\", and \"imm8\" is set to twice the number of registers in the list plus one. The list must contain at least one register, all registers must be in the range D0-D15, and must not contain more than 16 registers."], "decode": "if P == '0' && U == '0' && W == '0' then SEE \"Related encodings\";\nif P == '1' && W == '0' then SEE \"VSTR\";\nif P == U && W == '1' then UNDEFINED;\n// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)\nsingle_regs = FALSE;  add = (U == '1');  wback = (W == '1');\nd = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);\nregs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see \"FSTMX\".\nif n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;\nif regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;\nif imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    address = if add then R[n] else R[n]-imm32;\n    for r = 0 to regs-1\n        if single_regs then\n            MemA[address,4] = S[d+r];  address = address+4;\n        else\n            // Store as two word-aligned words in the correct order for current endianness.\n            MemA[address,4] = if BigEndian() then D[d+r]<63:32> else D[d+r]<31:0>;\n            MemA[address+4,4] = if BigEndian() then D[d+r]<31:0> else D[d+r]<63:32>;\n            address = address+8;\n    if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;"}, {"mnemonic": "VMLA (floating-point)", "short_desc": "Vector Multiply Accumulate (floating-point)", "full_desc": "Vector Multiply Accumulate multiplies corresponding elements in two vectors, and accumulates the results into the elements of the destination vector.", "syntax": ["VMLA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMLA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMLA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VMLA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VMLA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VMLA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMLA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMLA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VMLA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VMLA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nadvsimd = TRUE;  add = (op == '0');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if advsimd then  // Advanced SIMD instruction\n        for r = 0 to regs-1\n            for e = 0 to elements-1\n                product = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());\n                addend = if add then product else FPNeg(product);\n                Elem[D[d+r],e,esize] = FPAdd(Elem[D[d+r],e,esize], addend, StandardFPSCRValue());\n    else             // VFP instruction\n        case esize of\n            when 16\n                addend16 = if add then FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR) else FPNeg(FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR));\n                S[d] = Zeros(16) : FPAdd(S[d]<15:0>, addend16, FPSCR);\n            when 32\n                addend32 = if add then FPMul(S[n], S[m], FPSCR) else FPNeg(FPMul(S[n], S[m], FPSCR));\n                S[d] = FPAdd(S[d], addend32, FPSCR);\n            when 64\n                addend64 = if add then FPMul(D[n], D[m], FPSCR) else FPNeg(FPMul(D[n], D[m], FPSCR));\n                D[d] = FPAdd(D[d], addend64, FPSCR);"}, {"mnemonic": "QADD8", "short_desc": "Saturating Add 8", "full_desc": "Saturating Add 8 performs four 8-bit integer additions, saturates the results to the 8-bit signed integer range -2 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["QADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "QADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);\n    sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);\n    sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);\n    sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);\n    R[d]<7:0>   = SignedSat(sum1, 8);\n    R[d]<15:8>  = SignedSat(sum2, 8);\n    R[d]<23:16> = SignedSat(sum3, 8);\n    R[d]<31:24> = SignedSat(sum4, 8);"}, {"mnemonic": "LDM, LDMIA, LDMFD", "short_desc": "Load Multiple (Increment After, Full Descending)", "full_desc": "Load Multiple (Increment After, Full Descending) loads multiple registers from consecutive memory locations using an address from a base register. The consecutive memory locations start at this address, and the address just above the highest of those locations can optionally be written back to the base register.", "syntax": ["LDM{IA}{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "LDMFD{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "LDM{IA}{<c>}{<q>} <Rn>{!}, <registers>\t; T1", "LDMFD{<c>}{<q>} <Rn>{!}, <registers>\t; T1", "LDM{IA}{<c>}.W <Rn>{!}, <registers>\t; T2", "LDMFD{<c>}.W <Rn>{!}, <registers>\t; T2", "LDM{IA}{<c>}{<q>} <Rn>{!}, <registers>\t; T2", "LDMFD{<c>}{<q>} <Rn>{!}, <registers>\t; T2"], "symbols": ["IA\nIs an optional suffix for the Increment After form.", "<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nFor encoding A1 and T2: the address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "!\nFor encoding T1: the address adjusted by the size of the data loaded is written back to the base register. It is omitted if  is included in , otherwise it must be present.", "<registers>\nFor encoding A1: is a list of one or more registers to be loaded, separated by commas and surrounded by { and }.", "<registers>\nFor encoding T1: is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The registers in the list must be in the range R0-R7, encoded in the \"register_list\" field.", "<registers>\nFor encoding T2: is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The registers in the list must be in the range R0-R12, encoded in the \"register_list\" field, and can optionally contain one of  the LR or the PC. If the LR is in the list, the \"M\" field is set to 1, otherwise it defaults to 0. If the PC is in the list, the \"P\" field is set to 1, otherwise it defaults to 0."], "decode": "n = UInt(Rn);  registers = register_list;  wback = (W == '1');\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;\nif wback && registers<n> == '1' then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    for i = 0 to 14\n        if registers<i> == '1' then\n            R[i] = MemA[address,4];  address = address + 4;\n    if registers<15> == '1' then\n        LoadWritePC(MemA[address,4]);\n    if wback && registers<n> == '0' then R[n] = R[n] + 4*BitCount(registers);\n    if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;"}, {"mnemonic": "SHA1H", "short_desc": "SHA1 fixed rotate", "full_desc": "SHA1 fixed rotate.", "syntax": ["SHA1H.32 <Qd>, <Qm>\t; A1", "SHA1H.32 <Qd>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA1Ext() then UNDEFINED;\nif size != '10' then UNDEFINED;\nif Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    Q[d>>1] = ZeroExtend(ROL(Q[m>>1]<31:0>, 30), 128);"}, {"mnemonic": "VABAL", "short_desc": "Vector Absolute Difference and Accumulate Long", "full_desc": "Vector Absolute Difference and Accumulate Long subtracts the elements of one vector from the corresponding elements of another vector, and accumulates the absolute values of the results into the elements of the destination vector.", "syntax": ["VABAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; A1", "VABAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vd<0> == '1' then UNDEFINED;\nunsigned = (U == '1');  long_destination = TRUE;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];\n            op2 = Elem[Din[m+r],e,esize];\n            absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + absdiff;\n            else\n                Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + absdiff;"}, {"mnemonic": "LDAH", "short_desc": "Load-Acquire Halfword", "full_desc": "Load-Acquire Halfword loads a halfword from memory, zero-extends it to form a 32-bit word and writes it to a register. The instruction also has memory ordering semantics as described in .", "syntax": ["LDAH{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "LDAH{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    R[t] = ZeroExtend(MemO[address, 2], 32);"}, {"mnemonic": "SRS, SRSDA, SRSDB, SRSIA, SRSIB", "short_desc": "Store Return State", "full_desc": "Store Return State stores the LR_<current_mode> and _<current_mode> to the stack of a specified mode. For information about memory accesses see .", "syntax": ["SRSDA{<c>}{<q>} SP{!}, #<mode>\t; Decrement After", "SRSDB{<c>}{<q>} SP{!}, #<mode>\t; Decrement Before", "SRS{IA}{<c>}{<q>} SP{!}, #<mode>\t; Increment After", "SRSIB{<c>}{<q>} SP{!}, #<mode>\t; Increment Before", "SRSDB{<c>}{<q>} SP{!}, #<mode>\t; T1", "SRS{IA}{<c>}{<q>} SP{!}, #<mode>\t; T2"], "symbols": ["IA\nFor encoding A1: is an optional suffix to indicate the Increment After variant.", "IA\nFor encoding T2: is an optional suffix for the Increment After form.", "<c>\nFor encoding A1: see .  must be  or omitted.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "<mode>\nIs the number of the mode whose Banked SP is used as the base register, encoded in the \"mode\" field. For details of PE modes and their numbers see ."], "decode": "wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        if PSTATE.EL == EL2 then          // UNDEFINED at EL2\n            UNDEFINED;\n    \n        // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these\n        // to be security holes\n        if PSTATE.M IN {M32_User,M32_System} then\n            UNPREDICTABLE;\n        elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP\n            UNPREDICTABLE;\n        elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP\n            if !HaveEL(EL3) || !IsSecure()  then\n                UNPREDICTABLE;\n            elsif !ELUsingAArch32(EL3) then\n                AArch64.MonitorModeTrap();\n        elsif BadMode(mode) then\n            UNPREDICTABLE;\n    \n        base = Rmode[13,mode];\n        address = if increment then base else base-8;\n        if wordhigher then address = address+4;\n        MemA[address,4]   = LR;\n        MemA[address+4,4] = SPSR[];\n        if wback then Rmode[13,mode] = if increment then base+8 else base-8;\nelse\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        if PSTATE.EL == EL2 then          // UNDEFINED at EL2\n            UNDEFINED;\n    \n        // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these\n        // to be security holes\n        if PSTATE.M IN {M32_User,M32_System} then\n            UNPREDICTABLE;\n        elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP\n            UNPREDICTABLE;\n        elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP\n            if !HaveEL(EL3) || !IsSecure()  then\n                UNPREDICTABLE;\n            elsif !ELUsingAArch32(EL3) then\n                AArch64.MonitorModeTrap();\n        elsif BadMode(mode) then\n            UNPREDICTABLE;\n    \n        base = Rmode[13,mode];\n        address = if increment then base else base-8;\n        if wordhigher then address = address+4;\n        MemA[address,4]   = LR;\n        MemA[address+4,4] = SPSR[];\n        if wback then Rmode[13,mode] = if increment then base+8 else base-8;"}, {"mnemonic": "AND, ANDS (register-shifted register)", "short_desc": "Bitwise AND (register-shifted register)", "full_desc": "Bitwise AND (register-shifted register) performs a bitwise AND of a register value and a register-shifted register value. It writes the result to the destination register, and can optionally update the condition flags based on the result.", "syntax": ["ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] AND shifted;\n    R[d] = result;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result);\n        PSTATE.C = carry;\n        // PSTATE.V unchanged"}, {"mnemonic": "SMLAL, SMLALS", "short_desc": "Signed Multiply Accumulate Long", "full_desc": "Signed Multiply Accumulate Long multiplies two signed 32-bit values to produce a 64-bit value, and accumulates this with a 64-bit value.", "syntax": ["SMLALS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; Flag setting", "SMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; Not flag setting", "SMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<RdLo>\nIs the general-purpose source register holding the lower 32 bits of the addend, and the destination register for the lower 32 bits of the result, encoded in the \"RdLo\" field.", "<RdHi>\nIs the general-purpose source register holding the upper 32 bits of the addend, and the destination register for the upper 32 bits of the result, encoded in the \"RdHi\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."], "decode": "dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\nif dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif dHi == dLo then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = SInt(R[n]) * SInt(R[m]) + SInt(R[dHi]:R[dLo]);\n    R[dHi] = result<63:32>;\n    R[dLo] = result<31:0>;\n    if setflags then\n        PSTATE.N = result<63>;\n        PSTATE.Z = IsZeroBit(result<63:0>);\n        // PSTATE.C, PSTATE.V unchanged"}, {"mnemonic": "SSAX", "short_desc": "Signed Subtract and Add with Exchange", "full_desc": "Signed Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one 16-bit integer subtraction and one 16-bit addition, and writes the results to the destination register. It sets .GE according to the results.", "syntax": ["SSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum  = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);\n    diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);\n    R[d]<15:0>  = sum<15:0>;\n    R[d]<31:16> = diff<15:0>;\n    PSTATE.GE<1:0> = if sum  >= 0 then '11' else '00';\n    PSTATE.GE<3:2> = if diff >= 0 then '11' else '00';"}, {"mnemonic": "MLS", "short_desc": "Multiply and Subtract", "full_desc": "Multiply and Subtract multiplies two register values, and subtracts the product from a third register value. The least significant 32 bits of the result are written to the destination register. These 32 bits do not depend on whether the source register values are considered to be signed values or unsigned values.", "syntax": ["MLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; A1", "MLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the third general-purpose source register holding the minuend, encoded in the \"Ra\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);\nif d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results\n    operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results\n    addend   = SInt(R[a]);  // addend   = UInt(R[a]) produces the same final results\n    result = addend - operand1 * operand2;\n    R[d] = result<31:0>;"}, {"mnemonic": "LSLS (immediate)", "short_desc": "Logical Shift Left, setting flags (immediate)", "full_desc": "Logical Shift Left, setting flags (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSLS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value", "LSLS{<q>} {<Rd>,} <Rm>, #<imm>\t; T2", "LSLS.W {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value", "LSLS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction performs an exception return, that restores  from SPSR_<current_mode>.", "<Rd>\nFor encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.", "<imm>\nFor encoding A1: is the shift amount, in the range 0 to 31, encoded in the \"imm5\" field as <imm> modulo 32.", "<imm>\nFor encoding T2: is the shift amount, in the range 1 to 31, encoded in the \"imm5\" field as <amount> modulo 32.", "<imm>\nFor encoding T3: is the shift amount, in the range 0 to 31,  encoded in the \"imm3:imm2\" field as <imm> modulo 32."]}, {"mnemonic": "UMAAL", "short_desc": "Unsigned Multiply Accumulate Accumulate Long", "full_desc": "Unsigned Multiply Accumulate Accumulate Long multiplies two unsigned 32-bit values to produce a 64-bit value, adds two unsigned 32-bit values, and writes the 64-bit result to two registers.", "syntax": ["UMAAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; A1", "UMAAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<RdLo>\nIs the general-purpose source register holding the first addend and the destination register for the lower 32 bits of the result, encoded in the \"RdLo\" field.", "<RdHi>\nIs the general-purpose source register holding the second addend and the destination register for the upper 32 bits of the result, encoded in the \"RdHi\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."], "decode": "dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);\nif dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif dHi == dLo then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]) + UInt(R[dLo]);\n    R[dHi] = result<63:32>;\n    R[dLo] = result<31:0>;"}, {"mnemonic": "VCVT (integer to floating-point, floating-point)", "short_desc": "Convert integer to floating-point", "full_desc": "Convert integer to floating-point converts a 32-bit integer to floating-point using the rounding mode specified by the , and places the result in a second register.", "syntax": ["VCVT{<c>}{<q>}.F16.<dt> <Sd>, <Sm>\t; Half-precision scalar", "VCVT{<c>}{<q>}.F32.<dt> <Sd>, <Sm>\t; Single-precision scalar", "VCVT{<c>}{<q>}.F64.<dt> <Dd>, <Sm>\t; Double-precision scalar", "VCVT{<c>}{<q>}.F16.<dt> <Sd>, <Sm>\t; Half-precision scalar", "VCVT{<c>}{<q>}.F32.<dt> <Sd>, <Sm>\t; Single-precision scalar", "VCVT{<c>}{<q>}.F64.<dt> <Dd>, <Sm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<dt>\n", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if opc2 != '000' && opc2 != '10x' then SEE \"Related encodings\";\nif size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nto_integer = (opc2<2> == '1');\nif to_integer then\n    unsigned = (opc2<0> == '0');\n    rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);\n    d = UInt(Vd:D);\n    case size of\n        when '01' esize = 16; m = UInt(Vm:M);\n        when '10' esize = 32; m = UInt(Vm:M);\n        when '11' esize = 64; m = UInt(M:Vm);\nelse\n    unsigned = (op == '0');\n    rounding = FPRoundingMode(FPSCR);\n    m = UInt(Vm:M);\n    case size of\n        when '01' esize = 16; d = UInt(Vd:D);\n        when '10' esize = 32; d = UInt(Vd:D);\n        when '11' esize = 64; d = UInt(D:Vd);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    if to_integer then\n        case esize of\n            when 16\n                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);\n            when 32\n                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);\n            when 64\n                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);\n    else\n        case esize of\n            when 16\n                bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);\n                S[d] = Zeros(16):fp16;\n            when 32\n                S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);\n            when 64\n                D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);"}, {"mnemonic": "VMLA (by scalar)", "short_desc": "Vector Multiply Accumulate (by scalar)", "full_desc": "Vector Multiply Accumulate multiplies elements of a vector by a scalar, and adds the products to corresponding elements of the destination vector.", "syntax": ["VMLA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VMLA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>\t; 128-bit SIMD vector", "VMLA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VMLA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm[x]>\nIs the 64-bit name of the second SIMD&FP source register holding the scalar. If  is  or ,  is restricted to D0-D7.  is encoded in \"Vm<2:0>\", and  is encoded in \"M:Vm<3>\". If  is  or ,  is restricted to D0-D15.  is encoded in \"Vm\", and  is encoded in \"M\"."], "decode": "if size == '11' then SEE \"Related encodings\";\nif size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;\nunsigned = FALSE;  // \"Don't care\" value: TRUE produces same functionality\nadd = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;\nd = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;\nif size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);\nif size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);\n            if floating_point then\n                fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));\n                Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());\n            else\n                addend = if add then op1val*op2val else -op1val*op2val;\n                if long_destination then\n                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;\n                else\n                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;"}, {"mnemonic": "ADD, ADDS (immediate)", "short_desc": "Add (immediate)", "full_desc": "Add (immediate) adds an immediate value to a register value, and writes the result to the destination register.", "syntax": ["ADD{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ADD", "ADDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ADDS", "ADD<c>{<q>} <Rd>, <Rn>, #<imm3>\t; T1", "ADDS{<q>} <Rd>, <Rn>, #<imm3>\t; T1", "ADD<c>{<q>} <Rdn>, #<imm8>\t; T2", "ADD<c>{<q>} {<Rdn>,} <Rdn>, #<imm8>\t; T2", "ADDS{<q>} <Rdn>, #<imm8>\t; T2", "ADDS{<q>} {<Rdn>,} <Rdn>, #<imm8>\t; T2", "ADD<c>.W {<Rd>,} <Rn>, #<const>\t; ADD", "ADD{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ADD", "ADDS.W {<Rd>,} <Rn>, #<const>\t; ADDS", "ADDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; ADDS", "ADD{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>\t; T4", "ADDW{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>\t; T4"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdn>\nIs the general-purpose source and destination register, encoded in the \"Rdn\" field.", "<imm8>\nIs a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . If the PC is used:", "<Rd>\nFor encoding T1, T3 and T4: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1 and T4: is the general-purpose source register, encoded in the \"Rn\" field. If the SP is used, see . If the PC is used, see .", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nFor encoding T3: is the general-purpose source register, encoded in the \"Rn\" field. If the SP is used, see .", "<imm3>\nIs a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"imm3\" field.", "<imm12>\nIs a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T3: an immediate value. See  for the range of values."], "decode": "if Rn == '1111' && S == '0' then SEE \"ADR\";\nif Rn == '1101' then SEE \"ADD (SP plus immediate)\";\nd = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        (result, nzcv) = AddWithCarry(R[n], imm32, '0');\n        if d == 15 then          // Can only occur for A32 encoding\n            if setflags then\n                ALUExceptionReturn(result);\n            else\n                ALUWritePC(result);\n        else\n            R[d] = result;\n            if setflags then\n                PSTATE.<N,Z,C,V> = nzcv;\nelse\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        (result, nzcv) = AddWithCarry(R[n], imm32, '0');\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "STRH (immediate)", "short_desc": "Store Register Halfword (immediate)", "full_desc": "Store Register Halfword (immediate) calculates an address from a base register value and an immediate offset, and stores a halfword from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about memory accesses see .", "syntax": ["STRH{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "STRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "STRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1", "STRH{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]\t; T2", "STRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T2", "STRH{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]\t; Offset", "STRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant, but this is deprecated.", "<Rn>\nFor encoding A1, T1, T2, T3: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is the optional positive unsigned immediate byte offset, a multiple of 2, in the range 0 to 62, defaulting to 0 and encoded in the \"imm5\" field as <imm>/2.", "<imm>\nFor encoding T2: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T3: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field."], "decode": "if P == '0' && W == '1' then SEE \"STRHT\";\nt = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        MemU[address,2] = R[t]<15:0>;\n        if wback then R[n] = offset_addr;\nelse\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        MemU[address,2] = R[t]<15:0>;\n        if wback then R[n] = offset_addr;"}, {"mnemonic": "SSAT16", "short_desc": "Signed Saturate 16", "full_desc": "Signed Saturate 16 saturates two signed 16-bit values to a selected signed range.", "syntax": ["SSAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>\t; A1", "SSAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<imm>\nIs the bit position for saturation, in the range 1 to 16, encoded in the \"sat_imm\" field as <imm>-1.", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;\nif d == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result1, sat1) = SignedSatQ(SInt(R[n]<15:0>), saturate_to);\n    (result2, sat2) = SignedSatQ(SInt(R[n]<31:16>), saturate_to);\n    R[d]<15:0> = SignExtend(result1, 16);\n    R[d]<31:16> = SignExtend(result2, 16);\n    if sat1 || sat2 then\n        PSTATE.Q = '1';"}, {"mnemonic": "ERET", "short_desc": "Exception Return", "full_desc": "Exception Return.", "syntax": ["ERET{<c>}{<q>}\t; A1", "ERET{<c>}{<q>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if !Halted() then\n        if PSTATE.M IN {M32_User,M32_System} then\n            UNPREDICTABLE;                        // UNDEFINED or NOP\n        else\n            new_pc_value = if PSTATE.EL == EL2 then ELR_hyp else R[14];\n            AArch32.ExceptionReturn(new_pc_value, SPSR[]);\n    else                                          // Perform DRPS operation in Debug state\n        if PSTATE.M == M32_User then\n            UNDEFINED;\n        elsif PSTATE.M == M32_System then\n            UNPREDICTABLE;                        // UNDEFINED or NOP\n        else\n            SynchronizeContext();\n            SetPSTATEFromPSR(SPSR[]);\n            // PSTATE.{N,Z,C,V,Q,GE,SS,A,I,F} are not observable and ignored in Debug state, so\n            // behave as if UNKNOWN.\n            PSTATE.<N,Z,C,V,Q,GE,SS,A,I,F> = bits(13) UNKNOWN;\n            // In AArch32 Debug state, all instructions are T32 and unconditional.\n            PSTATE.IT = '00000000';  PSTATE.T = '1';        // PSTATE.J is RES0\n            DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;\n            UpdateEDSCRFields();                  // Update EDSCR PE state flags"}, {"mnemonic": "MOV, MOVS (register-shifted register)", "short_desc": "Move (register-shifted register)", "full_desc": "Move (register-shifted register) copies a register-shifted register value to the destination register. It can optionally update the condition flags based on the value.", "syntax": ["MOVS{<c>}{<q>} <Rd>, <Rm>, <shift> <Rs>\t; Flag setting", "MOV{<c>}{<q>} <Rd>, <Rm>, <shift> <Rs>\t; Not flag setting", "MOV<c>{<q>} <Rdm>, <Rdm>, ASR <Rs>\t; Arithmetic shift right", "MOVS{<q>} <Rdm>, <Rdm>, ASR <Rs>\t; Arithmetic shift right", "MOV<c>{<q>} <Rdm>, <Rdm>, LSL <Rs>\t; Logical shift left", "MOVS{<q>} <Rdm>, <Rdm>, LSL <Rs>\t; Logical shift left", "MOV<c>{<q>} <Rdm>, <Rdm>, LSR <Rs>\t; Logical shift right", "MOVS{<q>} <Rdm>, <Rdm>, LSR <Rs>\t; Logical shift right", "MOV<c>{<q>} <Rdm>, <Rdm>, ROR <Rs>\t; Rotate right", "MOVS{<q>} <Rdm>, <Rdm>, ROR <Rs>\t; Rotate right", "MOVS.W <Rd>, <Rm>, <shift> <Rs>\t; Flag setting", "MOVS{<c>}{<q>} <Rd>, <Rm>, <shift> <Rs>\t; Flag setting", "MOV<c>.W <Rd>, <Rm>, <shift> <Rs>\t; Not flag setting", "MOV{<c>}{<q>} <Rd>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the general-purpose source register and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    (result, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    R[d] = result;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result);\n        PSTATE.C = carry;\n        // PSTATE.V unchanged"}, {"mnemonic": "VRSHRN", "short_desc": "Vector Rounding Shift Right and Narrow", "full_desc": "Vector Rounding Shift Right and Narrow takes each element in a vector, right shifts them by an immediate value, and places the rounded results in the destination vector. For truncated results, see .", "syntax": ["VRSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>\t; A1", "VRSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<imm>\nIs an immediate value, in the range 1 to /2, encoded in the \"imm6\" field as /2 - ."], "decode": "if imm6 == '000xxx' then SEE \"Related encodings\";\nif Vm<0> == '1' then UNDEFINED;\ncase imm6 of\n    when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);\n    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);\n    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);\nd = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    round_const = 1 << (shift_amount-1);\n    for e = 0 to elements-1\n        result = LSR(Elem[Qin[m>>1],e,2*esize] + round_const, shift_amount);\n        Elem[D[d],e,esize] = result<esize-1:0>;"}, {"mnemonic": "USUB8", "short_desc": "Unsigned Subtract 8", "full_desc": "Unsigned Subtract 8 performs four 8-bit unsigned integer subtractions, and writes the results to the destination register. It sets .GE according to the results of the subtractions.", "syntax": ["USUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "USUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);\n    diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);\n    diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);\n    diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);\n    R[d]<7:0>   = diff1<7:0>;\n    R[d]<15:8>  = diff2<7:0>;\n    R[d]<23:16> = diff3<7:0>;\n    R[d]<31:24> = diff4<7:0>;\n    PSTATE.GE<0>  = if diff1 >= 0 then '1' else '0';\n    PSTATE.GE<1>  = if diff2 >= 0 then '1' else '0';\n    PSTATE.GE<2>  = if diff3 >= 0 then '1' else '0';\n    PSTATE.GE<3>  = if diff4 >= 0 then '1' else '0';"}, {"mnemonic": "STRD (register)", "short_desc": "Store Register Dual (register)", "full_desc": "Store Register Dual (register) calculates an address from a base register value and a register offset, and stores two words from two registers to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about memory accesses see .", "syntax": ["STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]\t; Offset", "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], {+/-}<Rm>\t; Post-indexed", "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the first general-purpose register to be transferred, encoded in the \"Rt\" field. This register must be even-numbered and not R14.", "<Rt2>\nIs the second general-purpose register to be transferred. This register must be .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant, but this is deprecated.", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field."], "decode": "if Rt<0> == '1' then UNPREDICTABLE;\nt = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif P == '0' && W == '1' then UNPREDICTABLE;\nif t2 == 15 || m == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);\n    address = if index then offset_addr else R[n];\n    if address == Align(address, 8) then\n        bits(64) data;\n        if BigEndian() then\n            data<63:32> = R[t];\n            data<31:0> = R[t2];\n        else\n            data<31:0> = R[t];\n            data<63:32> = R[t2];\n        MemA[address,8] = data;\n    else\n        MemA[address,4] = R[t];\n        MemA[address+4,4] = R[t2];\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "RRX", "short_desc": "Rotate Right with Extend", "full_desc": "Rotate Right with Extend provides the value of the contents of a register shifted right by one place, with the Carry flag shifted into bit[31].", "syntax": ["RRX{<c>}{<q>} {<Rd>,} <Rm>\t; MOV, rotate right with extend", "RRX{<c>}{<q>} {<Rd>,} <Rm>\t; MOV, rotate right with extend"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see .", "<Rd>\nFor encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T3: is the general-purpose source register, encoded in the \"Rm\" field."]}, {"mnemonic": "VPADD (integer)", "short_desc": "Vector Pairwise Add (integer)", "full_desc": "Vector Pairwise Add (integer) adds adjacent pairs of elements of two vectors, and places the results in the destination vector.", "syntax": ["VPADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; A1", "VPADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' || Q == '1' then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    bits(64) dest;\n    h = elements DIV 2;\n\n    for e = 0 to h-1\n        Elem[dest,e,esize]   = Elem[D[n],2*e,esize] + Elem[D[n],2*e+1,esize];\n        Elem[dest,e+h,esize] = Elem[D[m],2*e,esize] + Elem[D[m],2*e+1,esize];\n\n    D[d] = dest;"}, {"mnemonic": "BFI", "short_desc": "Bit Field Insert", "full_desc": "Bit Field Insert copies any number of low order bits from a register into the same number of adjacent bits at any position in the destination register.", "syntax": ["BFI{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>\t; A1", "BFI{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field.", "<lsb>\nFor encoding A1: is the least significant destination bit, in the range 0 to 31, encoded in the \"lsb\" field.", "<lsb>\nFor encoding T1: is the least significant destination bit, in the range 0 to 31, encoded in the \"imm3:imm2\" field.", "<width>\nIs the number of bits to be copied, in the range 1 to 32-<lsb>, encoded in the \"msb\" field as <lsb>+<width>-1."], "decode": "if Rn == '1111' then SEE \"BFC\";\nd = UInt(Rd);  n = UInt(Rn);  msbit = UInt(msb);  lsbit = UInt(lsb);\nif d == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if msbit >= lsbit then\n        R[d]<msbit:lsbit> = R[n]<(msbit-lsbit):0>;\n        // Other bits of R[d] are unchanged\n    else\n        UNPREDICTABLE;"}, {"mnemonic": "VFMSL (vector)", "short_desc": "Vector Floating-point Multiply-Subtract Long from accumulator (vector)", "full_desc": "Vector Floating-point Multiply-Subtract Long from accumulator (vector). This instruction negates the values in the vector of one SIMD&FP register, multiplies these with the corresponding values in another vector, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.", "syntax": ["VFMSL{<q>}.F16 <Dd>, <Sn>, <Sm>\t; 64-bit SIMD vector", "VFMSL{<q>}.F16 <Qd>, <Dn>, <Dm>\t; 128-bit SIMD vector", "VFMSL{<q>}.F16 <Dd>, <Sn>, <Sm>\t; 64-bit SIMD vector", "VFMSL{<q>}.F16 <Qd>, <Dn>, <Dm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;\nif Q == '1' && Vd<0> == '1' then UNDEFINED;\n\ninteger d = UInt(D:Vd);\ninteger n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);\ninteger m = if Q == '1' then UInt(M:Vm) else UInt(Vm:M);\ninteger esize = 32;\ninteger regs = if Q=='1' then 2 else 1;\ninteger datasize = if Q=='1' then 64 else 32;\nboolean sub_op = S=='1';", "operation": "CheckAdvSIMDEnabled();\nbits(datasize) operand1 ;\nbits(datasize) operand2 ;\nbits(64) operand3;\nbits(64) result;\nbits(esize DIV 2) element1;\nbits(esize DIV 2) element2;\n\nif Q=='0' then\n    operand1 = S[n]<datasize-1:0>;\n    operand2 = S[m]<datasize-1:0>;\nelse\n    operand1 = D[n]<datasize-1:0>;\n    operand2 = D[m]<datasize-1:0>;\nfor r = 0 to regs-1\n    operand3 = D[d+r];\n    for e = 0 to 1\n        element1 = Elem[operand1, 2*r+e, esize DIV 2];\n        element2 = Elem[operand2, 2*r+e, esize DIV 2];\n        if sub_op then element1 = FPNeg(element1);\n        Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());\n    D[d+r] = result;"}, {"mnemonic": "PLI (immediate, literal)", "short_desc": "Preload Instruction (immediate, literal)", "full_desc": "Preload Instruction signals the memory system that instruction memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as pre-loading the cache line containing the specified address into the instruction cache.", "syntax": ["PLI{<c>}{<q>} [<Rn> {, #{+/-}<imm>}]\t; A1", "PLI{<c>}{<q>} <label>\t; A1", "PLI{<c>}{<q>} [PC, #{+/-}<imm>]\t; A1", "PLI{<c>}{<q>} [<Rn> {, #{+}<imm>}]\t; T1", "PLI{<c>}{<q>} [<Rn> {, #-<imm>}]\t; T2", "PLI{<c>}{<q>} <label>\t; T3", "PLI{<c>}{<q>} [PC, #{+/-}<imm>]\t; T3"], "symbols": ["<c>\nFor encoding A1: see . Must be  or omitted.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<label>\nThe label of the instruction that is likely to be accessed in the near future. The assembler calculates the required value of the offset from the  value of the instruction to this label. The offset must be in the range \u20134095 to 4095.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T2: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field.", "<imm>\nFor encoding T3: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    base = if n == 15 then Align(PC,4) else R[n];\n    address = if add then (base + imm32) else (base - imm32);\n    Hint_PreloadInstr(address);"}, {"mnemonic": "VQRDMLSH", "short_desc": "Vector Saturating Rounding Doubling Multiply Subtract Returning High Half", "full_desc": "Vector Saturating Rounding Doubling Multiply Subtract Returning High Half. This instruction multiplies the vector elements of the first source SIMD&FP register with either the corresponding vector elements of the second source SIMD&FP register or the value of a vector element of the second source SIMD&FP register, without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.", "syntax": ["VQRDMLSH{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VQRDMLSH{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VQRDMLSH{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VQRDMLSH{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>\t; 128-bit SIMD vector", "VQRDMLSH{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VQRDMLSH{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VQRDMLSH{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VQRDMLSH{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm[x]>\nIs the 64-bit name of the second SIMD&FP source register holding the scalar. If  is ,  is restricted to D0-D7.  is encoded in \"Vm<2:0>\", and  is encoded in \"M:Vm<3>\". If  is ,  is restricted to D0-D15.  is encoded in \"Vm\", and  is encoded in \"M\".", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if !HaveQRDMLAHExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '00' || size == '11' then UNDEFINED;\nadd = FALSE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations();  CheckAdvSIMDEnabled();\nround_const = 1 << (esize-1);\nif scalar_form then op2 = SInt(Elem[D[m],index,esize]);\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        op1 = SInt(Elem[D[n+r],e,esize]);\n        op3 = SInt(Elem[D[d+r],e,esize]) << esize;\n        if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);\n        (result, sat) = SignedSatQ((op3 - 2*(op1*op2) + round_const) >> esize, esize);\n        Elem[D[d+r],e,esize] = result;\n        if sat then FPSCR.QC = '1';"}, {"mnemonic": "VRINTZ (Advanced SIMD)", "short_desc": "Vector round floating-point to integer towards Zero", "full_desc": "Vector round floating-point to integer towards Zero rounds a vector of floating-point values to integral floating-point values of the same size, using the Round towards Zero rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTZ{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTZ{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VRINTZ{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTZ{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\nrounding = FPRounding_ZERO;  exact = FALSE;\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        op1 = Elem[D[m+r],e,esize];\n        result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);\n        Elem[D[d+r],e,esize] = result;"}, {"mnemonic": "VQDMLSL", "short_desc": "Vector Saturating Doubling Multiply Subtract Long", "full_desc": "Vector Saturating Doubling Multiply Subtract Long multiplies corresponding elements in two doubleword vectors, subtracts double the products from corresponding elements of a quadword vector, and places the results in the same quadword vector.", "syntax": ["VQDMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; A1", "VQDMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]\t; A2", "VQDMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; T1", "VQDMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]\t; T2"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nFor encoding A1 and T1: is the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dm>\nFor encoding A2 and T2: is the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm<2:0>\" field when  is S16, otherwise the \"Vm\" field.", "<index>\nIs the element index in the range 0 to 3, encoded in the \"M:Vm<3>\" field when  is S16, otherwise in range 0 to 1, encoded in the \"M\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif size == '00' || Vd<0> == '1' then UNDEFINED;\nadd = (op == '0');\nscalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);\nesize = 8 << UInt(size);  elements = 64 DIV esize;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);\n    for e = 0 to elements-1\n        if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);\n        op1 = SInt(Elem[Din[n],e,esize]);\n        // The following only saturates if both op1 and op2 equal -(2^(esize-1))\n        (product, sat1) = SignedSatQ(2*op1*op2, 2*esize);\n        if add then\n            result = SInt(Elem[Qin[d>>1],e,2*esize]) + SInt(product);\n        else\n            result = SInt(Elem[Qin[d>>1],e,2*esize]) - SInt(product);\n        (Elem[Q[d>>1],e,2*esize], sat2) = SignedSatQ(result, 2*esize);\n        if sat1 || sat2 then FPSCR.QC = '1';"}, {"mnemonic": "VCADD", "short_desc": "Vector Complex Add", "full_desc": "Vector Complex Add.", "syntax": ["VCADD{<q>}.<dt> <Dd>, <Dn>, <Dm>, #<rotate>\t; 64-bit SIMD vector", "VCADD{<q>}.<dt> <Qd>, <Qn>, <Qm>, #<rotate>\t; 128-bit SIMD vector", "VCADD{<q>}.<dt> <Dd>, <Dn>, <Dm>, #<rotate>\t; 64-bit SIMD vector", "VCADD{<q>}.<dt> <Qd>, <Qn>, <Qm>, #<rotate>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<rotate>\n"], "decode": "if !HaveFCADDExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);\nesize = 16 << UInt(S);\nif !HaveFP16Ext() && esize == 16 then UNDEFINED;\nelements = 64 DIV esize;\nregs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations();\nCheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    operand1 = D[n+r];\n    operand2 = D[m+r];\n    operand3 = D[d+r];\n    for e = 0 to (elements DIV 2)-1\n        case rot of\n            when '0'\n                element1 = FPNeg(Elem[operand2,e*2+1,esize]);\n                element3 = Elem[operand2,e*2,esize];\n            when '1'\n                element1 = Elem[operand2,e*2+1,esize];\n                element3 = FPNeg(Elem[operand2,e*2,esize]);\n        result1 = FPAdd(Elem[operand1,e*2,esize],element1,StandardFPSCRValue());\n        result2 = FPAdd(Elem[operand1,e*2+1,esize],element3,StandardFPSCRValue());\n        Elem[D[d+r],e*2,esize] = result1;\n        Elem[D[d+r],e*2+1,esize] = result2;"}, {"mnemonic": "VQABS", "short_desc": "Vector Saturating Absolute", "full_desc": "Vector Saturating Absolute takes the absolute value of each element in a vector, and places the results in the destination vector.", "syntax": ["VQABS{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VQABS{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VQABS{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VQABS{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            result = Abs(SInt(Elem[D[m+r],e,esize]));\n            (Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);\n            if sat then FPSCR.QC = '1';"}, {"mnemonic": "SSBB", "short_desc": "Speculative Store Bypass Barrier", "full_desc": "Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing earlier stores to the same virtual address under certain conditions.", "syntax": ["SSBB{<q>}\t; A1", "SSBB{<q>}\t; T1"], "symbols": ["<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    SpeculativeStoreBypassBarrierToVA();"}, {"mnemonic": "VUDOT (vector)", "short_desc": "Dot Product vector form with unsigned integers.", "full_desc": "Dot Product vector form with unsigned integers. This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["VUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VUDOT{<q>}.U8 <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VUDOT{<q>}.U8 <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if !HaveDOTPExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nboolean signed = U=='0';\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(M:Vm);\ninteger esize = 32;\ninteger regs = if Q == '1' then 2 else 1;", "operation": "bits(64) operand1;\nbits(64) operand2;\nbits(64) result;\nCheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    operand1 = D[n+r];\n    operand2 = D[m+r];\n    result = D[d+r];\n    integer element1, element2;\n    for e = 0 to 1\n        integer res = 0;\n        for i = 0 to 3\n            if signed then\n                element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n                element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n            else\n                element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n                element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n            res = res + element1 * element2;\n        Elem[result, e, esize] = Elem[result, e, esize] + res;\n    D[d+r] = result;"}, {"mnemonic": "VRINTP (floating-point)", "short_desc": "Round floating-point to integer towards +Infinity", "full_desc": "Round floating-point to integer towards +Infinity rounds a floating-point value to an integral floating-point value of the same size using the Round towards +Infinity rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTP{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTP{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTP{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VRINTP{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTP{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTP{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nrounding = FPDecodeRM(RM);  exact = FALSE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\ncase esize of\n    when 16\n        S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);\n    when 32\n        S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);\n    when 64\n        D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);"}, {"mnemonic": "VORR (immediate)", "short_desc": "Vector Bitwise OR (immediate)", "full_desc": "Vector Bitwise OR (immediate) performs a bitwise OR between a register value and an immediate value, and returns the result into the destination vector.", "syntax": ["VORR{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VORR{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VORR{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VORR{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VORR{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VORR{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VORR{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VORR{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<imm>\nIs a constant of the specified type that is replicated to fill the destination register. For details of the range of constants available and the encoding of , see ."], "decode": "if cmode<0> == '0' || cmode<3:2> == '11' then SEE \"VMOV (immediate)\";\nif Q == '1' && Vd<0> == '1' then UNDEFINED;\nimm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);\nd = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        D[d+r] = D[d+r] OR imm64;"}, {"mnemonic": "VCEQ (immediate #0)", "short_desc": "Vector Compare Equal to Zero", "full_desc": "Vector Compare Equal to Zero takes each element in a vector, and compares it with zero.  If it is equal to zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VCEQ{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nfloating_point = (F == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if floating_point then\n                bits(esize) zero = FPZero('0');\n                test_passed = FPCompareEQ(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());\n            else\n                test_passed = (Elem[D[m+r],e,esize] == Zeros(esize));\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "VST1 (multiple single elements)", "short_desc": "Store multiple single elements from one, two, three, or four registers", "full_desc": "Store multiple single elements from one, two, three, or four registers stores elements to memory from one, two, three, or four registers, without interleaving.  Every element of each register is stored. For details of the addressing mode see .", "syntax": ["VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2, A3 and A4: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2, T3 and T4: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "regs = 1;  if align<1> == '1' then UNDEFINED;\nalignment = if align == '00' then 1 else 4 << UInt(align);\nebytes = 1 << UInt(size);  elements = 8 DIV ebytes;\nd = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d+regs > 32 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = TRUE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if ebytes != 8 then\n                MemU[address,ebytes] = Elem[D[d+r],e];\n            else\n                - = AArch32.CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);\n                bits(64) data = Elem[D[d+r],e];\n                MemU[address,4] = if BigEndian() then data<63:32> else data<31:0>;\n                MemU[address+4,4] = if BigEndian() then data<31:0> else data<63:32>;\n            address = address + ebytes;\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 8*regs;"}, {"mnemonic": "VUZP (alias)", "short_desc": "Vector Unzip", "syntax": ["VUZP{<c>}{<q>}.32 <Dd>, <Dm>\t; 64-bit SIMD vector", "VUZP{<c>}{<q>}.32 <Dd>, <Dm>\t; 64-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."]}, {"mnemonic": "LSRS (immediate)", "short_desc": "Logical Shift Right, setting flags (immediate)", "full_desc": "Logical Shift Right, setting flags (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and writes the result to the destination register.", "syntax": ["LSRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value", "LSRS{<q>} {<Rd>,} <Rm>, #<imm>\t; T2", "LSRS.W {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value", "LSRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOVS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction performs an exception return, that restores  from SPSR_<current_mode>.", "<Rd>\nFor encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.", "<imm>\nFor encoding A1 and T2: is the shift amount, in the range 1 to 32, encoded in the \"imm5\" field as <imm> modulo 32.", "<imm>\nFor encoding T3: is the shift amount, in the range 1 to 32, encoded in the \"imm3:imm2\" field as <imm> modulo 32."]}, {"mnemonic": "LDRD (literal)", "short_desc": "Load Register Dual (literal)", "full_desc": "Load Register Dual (literal) calculates an address from the PC value and an immediate offset, loads two words from memory, and writes them to two registers. For information about memory accesses see .", "syntax": ["LDRD{<c>}{<q>} <Rt>, <Rt2>, <label>\t; A1", "LDRD{<c>}{<q>} <Rt>, <Rt2>, [PC, #{+/-}<imm>]\t; A1", "LDRD{<c>}{<q>} <Rt>, <Rt2>, <label>\t; T1", "LDRD{<c>}{<q>} <Rt>, <Rt2>, [PC, #{+/-}<imm>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field. This register must be even-numbered and not R14.", "<Rt>\nFor encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nFor encoding A1: is the second general-purpose register to be transferred. This register must be .", "<Rt2>\nFor encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<label>\nFor encoding A1: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Any value in the range -255 to 255 is permitted.", "<label>\nFor encoding T1: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Permitted values of the offset are multiples of 4 in the range -1020 to 1020.", "+/-\n", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 and encoded in the \"imm8\" field."], "decode": "if Rt<0> == '1' then UNPREDICTABLE;\nt = UInt(Rt);  t2 = t+1;  imm32 = ZeroExtend(imm4H:imm4L, 32);  add = (U == '1');\nif t2 == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);\n    if address == Align(address, 8) then\n        data = MemA[address,8];\n        if BigEndian() then\n            R[t] = data<63:32>;\n            R[t2] = data<31:0>;\n        else\n            R[t] = data<31:0>;\n            R[t2] = data<63:32>;\n    else\n        R[t] = MemA[address,4];\n        R[t2] = MemA[address+4,4];"}, {"mnemonic": "VADD (floating-point)", "short_desc": "Vector Add (floating-point)", "full_desc": "Vector Add (floating-point) adds corresponding elements in two vectors, and places the results in the destination vector.", "syntax": ["VADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VADD{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VADD{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VADD{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar", "VADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VADD{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VADD{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VADD{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nadvsimd = TRUE;\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if advsimd then  // Advanced SIMD instruction\n        for r = 0 to regs-1\n            for e = 0 to elements-1\n                Elem[D[d+r],e,esize] = FPAdd(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize],\n                                             StandardFPSCRValue());\n    else             // VFP instruction\n        case esize of\n            when 16\n                S[d] = Zeros(16) : FPAdd(S[n]<15:0>, S[m]<15:0>, FPSCR);\n            when 32\n                S[d] = FPAdd(S[n], S[m], FPSCR);\n            when 64\n                D[d] = FPAdd(D[n], D[m], FPSCR);"}, {"mnemonic": "SMLSLD, SMLSLDX", "short_desc": "Signed Multiply Subtract Long Dual", "full_desc": "Signed Multiply Subtract Long Dual performs two signed 16 x 16-bit multiplications. It adds the difference of the products to a 64-bit accumulate operand.", "syntax": ["SMLSLD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLSLD", "SMLSLDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLSLDX", "SMLSLD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLSLD", "SMLSLDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; SMLSLDX"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<RdLo>\nIs the general-purpose source register holding the lower 32 bits of the addend, and the destination register for the lower 32 bits of the result, encoded in the \"RdLo\" field.", "<RdHi>\nIs the general-purpose source register holding the upper 32 bits of the addend, and the destination register for the upper 32 bits of the result, encoded in the \"RdHi\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');\nif dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif dHi == dLo then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand2 = if m_swap then ROR(R[m],16) else R[m];\n    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);\n    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);\n    result = product1 - product2 + SInt(R[dHi]:R[dLo]);\n    R[dHi] = result<63:32>;\n    R[dLo] = result<31:0>;"}, {"mnemonic": "BIC, BICS (register-shifted register)", "short_desc": "Bitwise Bit Clear (register-shifted register)", "full_desc": "Bitwise Bit Clear (register-shifted register) performs a bitwise AND of a register value and the complement of a register-shifted register value. It writes the result to the destination register, and can optionally update the condition flags based on the result.", "syntax": ["BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] AND NOT(shifted);\n    R[d] = result;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result);\n        PSTATE.C = carry;\n        // PSTATE.V unchanged"}, {"mnemonic": "CMP (register-shifted register)", "short_desc": "Compare (register-shifted register)", "full_desc": "Compare (register-shifted register) subtracts a register-shifted register value from a register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>\t; A1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<type>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nshift_t = DecodeRegShift(stype);\nif n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');\n    PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "SSAT", "short_desc": "Signed Saturate", "full_desc": "Signed Saturate saturates an optionally-shifted signed value to a selectable signed range.", "syntax": ["SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>\t; Arithmetic shift right", "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}\t; Logical shift left", "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>\t; Arithmetic shift right", "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}\t; Logical shift left"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<imm>\nIs the bit position for saturation, in the range 1 to 32, encoded in the \"sat_imm\" field as <imm>-1.", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field.", "<amount>\nFor encoding A1: is the optional shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm5\" field.", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 32 encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T1: is the optional shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm3:imm2\" field.", "<amount>\nFor encoding T1: is the shift amount, in the range 1 to 31 encoded in the \"imm3:imm2\" field as <amount>."], "decode": "d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;\n(shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);\nif d == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand = Shift(R[n], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored\n    (result, sat) = SignedSatQ(SInt(operand), saturate_to);\n    R[d] = SignExtend(result, 32);\n    if sat then\n        PSTATE.Q = '1';"}, {"mnemonic": "PUSH (single register)", "short_desc": "Push Single Register to Stack", "syntax": ["PUSH{<c>}{<q>} <single_register_list>\t; Pre-indexed", "PUSH{<c>}{<q>} <single_register_list>\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<single_register_list>\nIs the general-purpose register  to be stored surrounded by { and }.", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, but this is deprecated.", "<Rt>\nFor encoding T4: is the general-purpose register to be transferred, encoded in the \"Rt\" field."]}, {"mnemonic": "VCVTN (floating-point)", "short_desc": "Convert floating-point to integer with Round to Nearest", "full_desc": "Convert floating-point to integer with Round to Nearest converts a value in a register from floating-point to a 32-bit integer using the Round to Nearest rounding mode, and places the result in a second register.", "syntax": ["VCVTN{<q>}.<dt>.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTN{<q>}.<dt>.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTN{<q>}.<dt>.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVTN{<q>}.<dt>.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTN{<q>}.<dt>.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTN{<q>}.<dt>.F64 <Sd>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<dt>\n", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nrounding = FPDecodeRM(RM);  unsigned = (op == '0');\nd = UInt(Vd:D);\ncase size of\n    when '01' esize = 16; m = UInt(Vm:M);\n    when '10' esize = 32; m = UInt(Vm:M);\n    when '11' esize = 64; m = UInt(M:Vm);", "operation": "EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\ncase esize of\n    when 16\n        S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);\n    when 32\n        S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);\n    when 64\n        S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);"}, {"mnemonic": "SASX", "short_desc": "Signed Add and Subtract with Exchange", "full_desc": "Signed Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one 16-bit integer addition and one 16-bit subtraction, and writes the results to the destination register. It sets .GE according to the results.", "syntax": ["SASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);\n    sum  = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);\n    R[d]<15:0>  = diff<15:0>;\n    R[d]<31:16> = sum<15:0>;\n    PSTATE.GE<1:0> = if diff >= 0 then '11' else '00';\n    PSTATE.GE<3:2> = if sum  >= 0 then '11' else '00';"}, {"mnemonic": "LDRH (literal)", "short_desc": "Load Register Halfword (literal)", "full_desc": "Load Register Halfword (literal) calculates an address from the PC value and an immediate offset, loads a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRH{<c>}{<q>} <Rt>, <label>\t; A1", "LDRH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; A1", "LDRH{<c>}{<q>} <Rt>, <label>\t; T1", "LDRH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<label>\nFor encoding A1: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Any value in the range -255 to 255 is permitted.", "<label>\nFor encoding T1: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Permitted values of the offset are -4095 to 4095.", "+/-\n", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "if P == '0' && W == '1' then SEE \"LDRHT\";\nt = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);\nadd = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 || wback then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    base = Align(PC,4);\n    address = if add then (base + imm32) else (base - imm32);\n    data = MemU[address,2];\n    R[t] = ZeroExtend(data, 32);"}, {"mnemonic": "VSDOT (by element)", "short_desc": "Dot Product index form with signed integers.", "full_desc": "Dot Product index form with signed integers. This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["VSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VSDOT{<q>}.S8 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector", "VSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VSDOT{<q>}.S8 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm\" field.", "<index>\nIs the element index in the range 0 to 1, encoded in the \"M\" field."], "decode": "if !HaveDOTPExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;\nboolean signed = (U=='0');\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(Vm<3:0>);\ninteger index = UInt(M);\ninteger esize = 32;\ninteger regs = if Q == '1' then 2 else 1;", "operation": "bits(64) operand1;\nbits(64) operand2 = D[m];\nbits(64) result;\nCheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    operand1 = D[n+r];\n    result = D[d+r];\n    integer element1, element2;\n    for e = 0 to 1\n        integer res = 0;\n        for i = 0 to 3\n            if signed then\n                element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n                element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n            else\n                element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n                element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n            res = res + element1 * element2;\n        Elem[result, e, esize] = Elem[result, e, esize] + res;\n    D[d+r] = result;"}, {"mnemonic": "STREXB", "short_desc": "Store Register Exclusive Byte", "full_desc": "Store Register Exclusive Byte derives an address from a base register value, stores a byte from a register to the derived address if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.", "syntax": ["STREXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; A1", "STREXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the destination general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rd\" field. The value returned is:", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);\nif d == 15 || t == 15 || n == 15 then UNPREDICTABLE;\nif d == n || d == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    if AArch32.ExclusiveMonitorsPass(address,1) then\n        MemA[address,1] = R[t]<7:0>;\n        R[d] = ZeroExtend('0');\n    else\n        R[d] = ZeroExtend('1');"}, {"mnemonic": "ADD, ADDS (register)", "short_desc": "Add (register)", "full_desc": "Add (register) adds a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ADD, rotate right with extend", "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ADD, shift or rotate by value", "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ADDS, rotate right with extend", "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ADDS, shift or rotate by value", "ADD<c>{<q>} <Rd>, <Rn>, <Rm>\t; T1", "ADDS{<q>} {<Rd>,} <Rn>, <Rm>\t; T1", "ADD<c>{<q>} <Rdn>, <Rm>\t; T2", "ADD{<c>}{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T2", "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ADD, rotate right with extend", "ADD<c>.W {<Rd>,} <Rn>, <Rm>\t; ADD, shift or rotate by value", "ADD{<c>}.W {<Rd>,} <Rn>, <Rm>\t; ADD, shift or rotate by value", "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ADD, shift or rotate by value", "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ADDS, rotate right with extend", "ADDS.W {<Rd>,} <Rn>, <Rm>\t; ADDS, shift or rotate by value", "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ADDS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdn>\nIs the general-purpose source and destination register, encoded in the \"DN:Rdn\" field. If the PC is used, the instruction is a branch to the address calculated by the operation. This is a simple branch, see .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . If the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nFor encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used. If the SP is used, see .", "<Rn>\nFor encoding T1: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nFor encoding T3: is the first general-purpose source register, encoded in the \"Rn\" field. If the SP is used, see .", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T3: is the second general-purpose source register, encoded in the \"Rm\" field.", "<Rm>\nFor encoding T2: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T3: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "if Rn == '1101' then SEE \"ADD (SP plus register)\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], shifted, '0');\n    if d == 15 then\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "UXTH", "short_desc": "Unsigned Extend Halfword", "full_desc": "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends it to 32 bits, and writes the result to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.", "syntax": ["UXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; A1", "UXTH{<c>}{<q>} {<Rd>,} <Rm>\t; T1", "UXTH{<c>}.W {<Rd>,} <Rm>\t; T2", "UXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d] = ZeroExtend(rotated<15:0>, 32);"}, {"mnemonic": "STRH (register)", "short_desc": "Store Register Halfword (register)", "full_desc": "Store Register Halfword (register) calculates an address from a base register value and an offset register value, and stores a halfword from a register to memory. The offset register value can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see .", "syntax": ["STRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]\t; Offset", "STRH{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>\t; Post-indexed", "STRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!\t; Pre-indexed", "STRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]\t; T1", "STRH{<c>}.W <Rt>, [<Rn>, {+}<Rm>]\t; T2", "STRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant, but this is deprecated.", "<Rn>\nFor encoding T1 and T2: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<imm>\nIf present, the size of the left shift to apply to the value from , in the range 1-3.  is encoded in imm2. If absent, no shift is specified and imm2 is encoded as ."], "decode": "if P == '0' && W == '1' then SEE \"STRHT\";\nt = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\n(shift_t, shift_n) = (SRType_LSL, 0);\nif t == 15 || m == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if index then offset_addr else R[n];\n    MemU[address,2] = R[t]<15:0>;\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "ORR, ORRS (register-shifted register)", "short_desc": "Bitwise OR (register-shifted register)", "full_desc": "Bitwise OR (register-shifted register) performs a bitwise (inclusive) OR of a register value and a register-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.", "syntax": ["ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] OR shifted;\n    R[d] = result;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result);\n        PSTATE.C = carry;\n        // PSTATE.V unchanged"}, {"mnemonic": "VCLE (register)", "short_desc": "Vector Compare Less Than or Equal", "syntax": ["VCLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field."]}, {"mnemonic": "VACGT", "short_desc": "Vector Absolute Compare Greater Than", "full_desc": "Vector Absolute Compare Greater Than takes the absolute value of each element in a vector, and compares it with the absolute value of the corresponding element of a second vector. If the first is greater than the second, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VACGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VACGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VACGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VACGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nor_equal = (op == '0');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = FPAbs(Elem[D[n+r],e,esize]);  op2 = FPAbs(Elem[D[m+r],e,esize]);\n            if or_equal then\n                test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());\n            else\n                test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "QSUB", "short_desc": "Saturating Subtract", "full_desc": "Saturating Subtract subtracts one register value from another register value, saturates the result to the 32-bit signed integer range -2 <= x <= 2 - 1, and writes the result to the destination register. If saturation occurs, it sets .Q to 1.", "syntax": ["QSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>\t; A1", "QSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the second general-purpose source register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (R[d], sat) = SignedSatQ(SInt(R[m]) - SInt(R[n]), 32);\n    if sat then\n        PSTATE.Q = '1';"}, {"mnemonic": "CRC32", "short_desc": "CRC32", "full_desc": "performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, or 32 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial  is used for the CRC calculation.", "syntax": ["CRC32B{<q>} <Rd>, <Rn>, <Rm>\t; CRC32B", "CRC32H{<q>} <Rd>, <Rn>, <Rm>\t; CRC32H", "CRC32W{<q>} <Rd>, <Rn>, <Rm>\t; CRC32W", "CRC32B{<q>} <Rd>, <Rn>, <Rm>\t; CRC32B", "CRC32H{<q>} <Rd>, <Rn>, <Rm>\t; CRC32H", "CRC32W{<q>} <Rd>, <Rn>, <Rm>\t; CRC32W"], "symbols": ["<q>\nSee . An  instruction must be unconditional.", "<Rd>\nIs the general-purpose accumulator output register, encoded in the \"Rd\" field.", "<Rn>\nIs the general-purpose accumulator input register, encoded in the \"Rn\" field.", "<Rm>\nIs the general-purpose data source register, encoded in the \"Rm\" field."], "decode": "if ! HaveCRCExt() then UNDEFINED;\nd = UInt(Rd); n = UInt(Rn); m = UInt(Rm);\nsize = 8 << UInt(sz);\ncrc32c = (C == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif size == 64 then UNPREDICTABLE;\nif cond != '1110' then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n\n    acc = R[n];             // accumulator\n    val = R[m]<size-1:0>;   // input value\n    poly = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\n    tempacc = BitReverse(acc):Zeros(size);\n    tempval = BitReverse(val):Zeros(32);\n    // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation\n    R[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"}, {"mnemonic": "VMLA (integer)", "short_desc": "Vector Multiply Accumulate (integer)", "full_desc": "Vector Multiply Accumulate multiplies corresponding elements in two vectors, and adds the products to the corresponding elements of the destination vector.", "syntax": ["VMLA{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMLA{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMLA{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMLA{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\nThe data type for the elements of the operands. It must be one of:", "<size>\nThe data size for the elements of the operands. It must be one of:", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nadd = (op == '0');  long_destination = FALSE;\nunsigned = FALSE;  // \"Don't care\" value: TRUE produces same functionality\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);\n            addend = if add then product else -product;\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;\n            else\n                Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;"}, {"mnemonic": "PLI (register)", "short_desc": "Preload Instruction (register)", "full_desc": "Preload Instruction signals the memory system that instruction memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as pre-loading the cache line containing the specified address into the instruction cache.", "syntax": ["PLI{<c>}{<q>} [<Rn>, {+/-}<Rm> , RRX]\t; Rotate right with extend", "PLI{<c>}{<q>} [<Rn>, {+/-}<Rm> {, <shift> #<amount>}]\t; Shift or rotate by value", "PLI{<c>}{<q>} [<Rn>, {+}<Rm> {, LSL #<amount>}]\t; T1"], "symbols": ["<c>\nFor encoding A1: see .  must be  or omitted.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T1: is the shift amount, in the range 0 to 3, defaulting to 0 and encoded in the \"imm2\" field."], "decode": "n = UInt(Rn);  m = UInt(Rm);  add = (U == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);\nif m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    address = if add then (R[n] + offset) else (R[n] - offset);\n    Hint_PreloadInstr(address);"}, {"mnemonic": "VSLI", "short_desc": "Vector Shift Left and Insert", "full_desc": "Vector Shift Left and Insert takes each element in the operand vector, left shifts them by an immediate value, and inserts the results in the destination vector. Bits shifted out of the left of each element are lost.", "syntax": ["VSLI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSLI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector", "VSLI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSLI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nIs an immediate value, in the range 0 to -1, encoded in the \"imm6\" field."], "decode": "if (L:imm6) == '0000xxx' then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\ncase L:imm6 of\n    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;\n    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;\n    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;\n    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    mask = LSL(Ones(esize), shift_amount);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            shifted_op = LSL(Elem[D[m+r],e,esize], shift_amount);\n            Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;"}, {"mnemonic": "VSHR (zero)", "short_desc": "Vector Shift Right", "syntax": ["VSHR{<c>}{<q>}.<dt> <Dd>, <Dm>, #0\t; 64-bit SIMD vector", "VSHR{<c>}{<q>}.<dt> <Qd>, <Qm>, #0\t; 128-bit SIMD vector", "VSHR{<c>}{<q>}.<dt> <Dd>, <Dm>, #0\t; 64-bit SIMD vector", "VSHR{<c>}{<q>}.<dt> <Qd>, <Qm>, #0\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nIs the data type for the elements of the vectors, and must be one of: S8, S16, S32, S64, U8, U16, U32 or U64.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"N:Vn\" and \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"N:Vn\" and \"M:Vm\" field."]}, {"mnemonic": "UHSUB16", "short_desc": "Unsigned Halving Subtract 16", "full_desc": "Unsigned Halving Subtract 16 performs two unsigned 16-bit integer subtractions, halves the results, and writes the results to the destination register.", "syntax": ["UHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);\n    diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);\n    R[d]<15:0>  = diff1<16:1>;\n    R[d]<31:16> = diff2<16:1>;"}, {"mnemonic": "STRD (immediate)", "short_desc": "Store Register Dual (immediate)", "full_desc": "Store Register Dual (immediate) calculates an address from a base register value and an immediate offset, and stores two words from two registers to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about memory accesses see .", "syntax": ["STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field. This register must be even-numbered and not R14.", "<Rt>\nFor encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nFor encoding A1: is the second general-purpose register to be transferred. This register must be .", "<Rt2>\nFor encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is the unsigned immediate byte offset, a multiple of 4, in the range 0 to 1020, defaulting to 0 if omitted, and encoded in the \"imm8\" field as <imm>/4."], "decode": "if Rt<0> == '1' then UNPREDICTABLE;\nt = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif P == '0' && W == '1' then UNPREDICTABLE;\nif wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;\nif t2 == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n    address = if index then offset_addr else R[n];\n    if address == Align(address, 8) then\n        bits(64) data;\n        if BigEndian() then\n            data<63:32> = R[t];\n            data<31:0> = R[t2];\n        else\n            data<31:0> = R[t];\n            data<63:32> = R[t2];\n        MemA[address,8] = data;\n    else\n        MemA[address,4] = R[t];\n        MemA[address+4,4] = R[t2];\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "LDAEXB", "short_desc": "Load-Acquire Exclusive Byte", "full_desc": "Load-Acquire Exclusive Byte loads a byte from memory, zero-extends it to form a 32-bit word, writes it to a register and:", "syntax": ["LDAEXB{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "LDAEXB{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    AArch32.SetExclusiveMonitors(address, 1);\n    R[t] = ZeroExtend(MemO[address, 1], 32);"}, {"mnemonic": "VFNMS", "short_desc": "Vector Fused Negate Multiply Subtract", "full_desc": "Vector Fused Negate Multiply Subtract multiplies together two floating-point register values, adds the negation of the floating-point value in the destination register to the product, and writes the result back to the destination register. The instruction does not round the result of the multiply before the addition.", "syntax": ["VFNMS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VFNMS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VFNMS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VFNMS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VFNMS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VFNMS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\nif size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nop1_neg = (op == '1');\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\n    case esize of\n        when 16\n            op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;\n            S[d] = Zeros(16) : FPMulAdd(FPNeg(S[d]<15:0>), op16, S[m]<15:0>, FPSCR);\n        when 32\n            op32 = if op1_neg then FPNeg(S[n]) else S[n];\n            S[d] = FPMulAdd(FPNeg(S[d]), op32, S[m], FPSCR);\n        when 64\n            op64 = if op1_neg then FPNeg(D[n]) else D[n];\n            D[d] = FPMulAdd(FPNeg(D[d]), op64, D[m], FPSCR);"}, {"mnemonic": "VQSHRUN (zero)", "short_desc": "Vector Saturating Shift Right, Narrow", "syntax": ["VQSHRUN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; Unsigned result", "VQSHRUN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; Unsigned result"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."]}, {"mnemonic": "VRSUBHN", "short_desc": "Vector Rounding Subtract and Narrow, returning High Half", "full_desc": "Vector Rounding Subtract and Narrow, returning High Half subtracts the elements of one quadword vector from the corresponding elements of another quadword vector, takes the most significant half of each result, and places the final results in a doubleword vector. The results are rounded. For truncated results, see .", "syntax": ["VRSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>\t; A1", "VRSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    round_const = 1 << (esize-1);\n    for e = 0 to elements-1\n        result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize] + round_const;\n        Elem[D[d],e,esize] = result<2*esize-1:esize>;"}, {"mnemonic": "ASR (immediate)", "short_desc": "Arithmetic Shift Right (immediate)", "full_desc": "Arithmetic Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in copies of its sign bit, and writes the result to the destination register.", "syntax": ["ASR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value", "ASR<c>{<q>} {<Rd>,} <Rm>, #<imm>\t; T2", "ASR<c>.W {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value", "ASR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see .", "<Rd>\nFor encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.", "<imm>\nFor encoding A1 and T2: is the shift amount, in the range 1 to 32, encoded in the \"imm5\" field as <imm> modulo 32.", "<imm>\nFor encoding T3: is the shift amount, in the range 1 to 32, encoded in the \"imm3:imm2\" field as <imm> modulo 32."]}, {"mnemonic": "SHA1P", "short_desc": "SHA1 hash update (parity)", "full_desc": "SHA1 hash update (parity).", "syntax": ["SHA1P.32 <Qd>, <Qn>, <Qm>\t; A1", "SHA1P.32 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA1Ext() then UNDEFINED;\nif Q != '1' then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    X = Q[d>>1];\n    Y = Q[n>>1]<31:0>; // Note: 32 bits wide\n    W = Q[m>>1];\n    for e = 0 to 3\n        t = SHAparity(X<63:32>, X<95:64>, X<127:96>);\n        Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n        X<63:32> = ROL(X<63:32>, 30);\n        <Y, X> = ROL(Y:X, 32);\n    Q[d>>1] = X;"}, {"mnemonic": "VLD1 (single element to one lane)", "short_desc": "Load single 1-element structure to one lane of one register", "full_desc": "Load single 1-element structure to one lane of one register loads one element from memory into one element of a register. Elements of the register that are not loaded are unchanged. For details of the addressing mode see .", "syntax": ["VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2 and A3: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the single 64-bit name of the SIMD&FP register holding the element.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nWhen  == 8,  must be omitted, otherwise it is the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then SEE \"VLD1 (single element to all lanes)\";\nif index_align<0> != '0' then UNDEFINED;\nebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;\nd = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    Elem[D[d],index] = MemU[address,ebytes];\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + ebytes;"}, {"mnemonic": "VORR (register)", "short_desc": "Vector bitwise OR (register)", "full_desc": "Vector bitwise OR (register) performs a bitwise OR operation between two registers, and places the result in the destination register. The operand and result registers can be quadword or doubleword. They must all be the same size.", "syntax": ["VORR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VORR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VORR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VORR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        D[d+r] = D[n+r] OR D[m+r];"}, {"mnemonic": "VCEQ (register)", "short_desc": "Vector Compare Equal", "full_desc": "Vector Compare Equal takes each element in a vector, and compares it with the corresponding element of a second vector. If they are equal, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VCEQ{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCEQ{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '11' then UNDEFINED;\nint_operation = TRUE;  esize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];\n            if int_operation then\n                test_passed = (op1 == op2);\n            else\n                test_passed = FPCompareEQ(op1, op2, StandardFPSCRValue());\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "VMINNM", "short_desc": "Floating-point Minimum Number", "full_desc": "This instruction determines the floating point minimum number.", "syntax": ["VMINNM{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMINNM{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMINNM{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VMINNM{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VMINNM{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VMINNM{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMINNM{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMINNM{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VMINNM{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VMINNM{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nmaximum = (op == '0');\nadvsimd = TRUE;\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\nif advsimd then             // Advanced SIMD instruction\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[n+r], e, esize]; op2 = Elem[D[m+r], e, esize];\n            if maximum then\n                Elem[D[d+r], e, esize] = FPMaxNum(op1, op2, StandardFPSCRValue());\n            else\n                Elem[D[d+r], e, esize] = FPMinNum(op1, op2, StandardFPSCRValue());\nelse                        // VFP instruction\n    case esize of\n        when 16\n            if maximum then\n                S[d] = Zeros(16) : FPMaxNum(S[n]<15:0>, S[m]<15:0>, FPSCR);\n            else\n                S[d] = Zeros(16) : FPMinNum(S[n]<15:0>, S[m]<15:0>, FPSCR);\n        when 32\n            if maximum then\n                S[d] = FPMaxNum(S[n], S[m], FPSCR);\n            else\n                S[d] = FPMinNum(S[n], S[m], FPSCR);\n        when 64\n            if maximum then\n                D[d] = FPMaxNum(D[n], D[m], FPSCR);\n            else\n                D[d] = FPMinNum(D[n], D[m], FPSCR);"}, {"mnemonic": "DSB", "short_desc": "Data Synchronization Barrier", "full_desc": "Data Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see .", "syntax": ["DSB{<c>}{<q>} {<option>}\t; A1", "DSB{<c>}{<q>} {<option>}\t; T1"], "symbols": ["<c>\nFor encoding A1: see . Must be  or omitted.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<option>\nSpecifies an optional limitation on the barrier operation. Values are:"], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    case option of\n        when '0001'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Reads;\n        when '0010'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Writes;\n        when '0011'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_All;\n        when '0101'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Reads;\n        when '0110'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Writes;\n        when '0111'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_All;\n        when '1001'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Reads;\n        when '1010'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Writes;\n        when '1011'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_All;\n        when '1101'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Reads;\n        when '1110'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Writes;\n        otherwise\n            if       option == '0000' then SEE \"SSBB\";\n            elsif    option == '0100' then SEE \"PSSBB\";\n            else     domain = MBReqDomain_FullSystem;      types = MBReqTypes_All;\n\n    if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then\n        if HCR.BSU == '11' then\n            domain = MBReqDomain_FullSystem;\n        if HCR.BSU == '10' && domain != MBReqDomain_FullSystem then\n            domain = MBReqDomain_OuterShareable;\n        if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then\n            domain = MBReqDomain_InnerShareable;\n\n    DataSynchronizationBarrier(domain, types);"}, {"mnemonic": "LDREXH", "short_desc": "Load Register Exclusive Halfword", "full_desc": "Load Register Exclusive Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it to form a 32-bit word, writes it to a register and:", "syntax": ["LDREXH{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "LDREXH{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    AArch32.SetExclusiveMonitors(address,2);\n    R[t] = ZeroExtend(MemA[address,2], 32);"}, {"mnemonic": "VLD3 (single 3-element structure to one lane)", "short_desc": "Load single 3-element structure to one lane of three registers", "full_desc": "Load single 3-element structure to one lane of three registers loads one 3-element structure from memory into corresponding elements of three registers. Elements of the registers that are not loaded are unchanged. For details of the addressing mode see .", "syntax": ["VLD3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2 and A3: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the three SIMD&FP registers holding the element.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then SEE \"VLD3 (single 3-element structure to all lanes)\";\nif index_align<0> != '0' then UNDEFINED;\nebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d3 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];\n    Elem[D[d], index] = MemU[address,ebytes];\n    Elem[D[d2],index] = MemU[address+ebytes,ebytes];\n    Elem[D[d3],index] = MemU[address+2*ebytes,ebytes];\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 3*ebytes;"}, {"mnemonic": "RRXS", "short_desc": "Rotate Right with Extend, setting flags", "full_desc": "Rotate Right with Extend, setting flags provides the value of the contents of a register shifted right by one place, with the Carry flag shifted into bit[31].", "syntax": ["RRXS{<c>}{<q>} {<Rd>,} <Rm>\t; MOVS, rotate right with extend", "RRXS{<c>}{<q>} {<Rd>,} <Rm>\t; MOVS, rotate right with extend"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction performs an exception return, that restores  from SPSR_<current_mode>.", "<Rd>\nFor encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T3: is the general-purpose source register, encoded in the \"Rm\" field."]}, {"mnemonic": "VSHRN (zero)", "short_desc": "Vector Shift Right Narrow", "syntax": ["VSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; A1", "VSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."]}, {"mnemonic": "VNMLS", "short_desc": "Vector Negate Multiply Subtract", "full_desc": "Vector Negate Multiply Subtract multiplies together two floating-point register values, adds the negation of the floating-point value in the destination register to the product, and writes the result back to the destination register.", "syntax": ["VNMLS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VNMLS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VNMLS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VNMLS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VNMLS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VNMLS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\nif size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nvtype = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL};\n\nif ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    case esize of\n        when 16\n            product16 = FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);\n            case vtype of\n                when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), FPNeg(product16), FPSCR);\n                when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), product16, FPSCR);\n                when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);\n        when 32\n            product32 = FPMul(S[n], S[m], FPSCR);\n            case vtype of\n                when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);\n                when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);\n                when VFPNegMul_VNMUL  S[d] = FPNeg(product32);\n        when 64\n            product64 = FPMul(D[n], D[m], FPSCR);\n            case vtype of\n                when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);\n                when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);\n                when VFPNegMul_VNMUL  D[d] = FPNeg(product64);"}, {"mnemonic": "UQADD16", "short_desc": "Unsigned Saturating Add 16", "full_desc": "Unsigned Saturating Add 16 performs two unsigned 16-bit integer additions, saturates the results to the 16-bit unsigned integer range 0 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["UQADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UQADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);\n    sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);\n    R[d]<15:0>  = UnsignedSat(sum1, 16);\n    R[d]<31:16> = UnsignedSat(sum2, 16);"}, {"mnemonic": "TBB, TBH", "short_desc": "Table Branch Byte or Halfword", "full_desc": "Table Branch Byte or Halfword causes a PC-relative forward branch using a table of single byte or halfword offsets. A base register provides a pointer to the table, and a second register supplies an index into the table. The branch length is twice the value returned from the table.", "syntax": ["TBB{<c>}{<q>} [<Rn>, <Rm>]\t; Byte", "TBH{<c>}{<q>} [<Rn>, <Rm>, LSL #1]\t; Halfword"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register holding the address of the table of branch lengths, encoded in the \"Rn\" field. The PC can be used. If it is, the table immediately follows this instruction.", "<Rm>\nFor the byte variant: is the general-purpose index register, encoded in the \"Rm\" field. This register contains an integer pointing to a single byte in the table. The offset in the table is the value of the index.", "<Rm>\nFor the halfword variant: is the general-purpose index register, encoded in the \"Rm\" field. This register contains an integer pointing to a halfword in the table. The offset in the table is twice the value of the index."], "decode": "n = UInt(Rn);  m = UInt(Rm);  is_tbh = (H == '1');\nif m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13\nif InITBlock() && !LastInITBlock() then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if is_tbh then\n        halfwords = UInt(MemU[R[n]+LSL(R[m],1), 2]);\n    else\n        halfwords = UInt(MemU[R[n]+R[m], 1]);\n    BranchWritePC(PC + 2*halfwords, BranchType_INDIR);"}, {"mnemonic": "POP (single register)", "short_desc": "Pop Single Register from Stack", "syntax": ["POP{<c>}{<q>} <single_register_list>\t; Post-indexed", "POP{<c>}{<q>} <single_register_list>\t; Post-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<single_register_list>\nIs the general-purpose register  to be loaded surrounded by { and }.", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used. If the PC is used, the instruction branches to the address (data) loaded to the PC. This is an interworking branch, see .", "<Rt>\nFor encoding T4: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, provided the instruction is either outside an IT block or the last instruction of an IT block. If the PC is used, the instruction branches to the address (data) loaded to the PC. This is an interworking branch, see ."]}, {"mnemonic": "SADD16", "short_desc": "Signed Add 16", "full_desc": "Signed Add 16 performs two 16-bit signed integer additions, and writes the results to the destination register. It sets .GE according to the results of the additions.", "syntax": ["SADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);\n    sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);\n    R[d]<15:0>  = sum1<15:0>;\n    R[d]<31:16> = sum2<15:0>;\n    PSTATE.GE<1:0> = if sum1 >= 0 then '11' else '00';\n    PSTATE.GE<3:2> = if sum2 >= 0 then '11' else '00';"}, {"mnemonic": "VMULL (by scalar)", "short_desc": "Vector Multiply Long (by scalar)", "full_desc": "Vector Multiply Long multiplies each element in a vector by a scalar, and places the results in a second vector. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["VMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]\t; A1", "VMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm<2:0>\" field when  is S16 or U16, otherwise the \"Vm\" field.", "<index>\nIs the element index in the range 0 to 3, encoded in the \"M:Vm<3>\" field when  is S16 or U16, otherwise in range 0 to 1, encoded in the \"M\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif size == '00' || Vd<0> == '1' then UNDEFINED;\nunsigned = (U == '1');  long_destination = TRUE;  floating_point = FALSE;\nd = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;\nif size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);\nif size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);\n            if floating_point then\n                Elem[D[d+r],e,esize] = FPMul(op1, op2, StandardFPSCRValue());\n            else\n                if long_destination then\n                    Elem[Q[d>>1],e,2*esize] = (op1val*op2val)<2*esize-1:0>;\n                else\n                    Elem[D[d+r],e,esize] = (op1val*op2val)<esize-1:0>;"}, {"mnemonic": "VFMSL (by scalar)", "short_desc": "Vector Floating-point Multiply-Subtract Long from accumulator (by scalar)", "full_desc": "Vector Floating-point Multiply-Subtract Long from accumulator (by scalar). This instruction multiplies the negated vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.", "syntax": ["VFMSL{<q>}.F16 <Dd>, <Sn>, <Sm>[<index>]\t; 64-bit SIMD vector", "VFMSL{<q>}.F16 <Qd>, <Dn>, <Dm>[<index>]\t; 128-bit SIMD vector", "VFMSL{<q>}.F16 <Dd>, <Sn>, <Sm>[<index>]\t; 64-bit SIMD vector", "VFMSL{<q>}.F16 <Qd>, <Dn>, <Dm>[<index>]\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm<2:0>\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm<2:0>:M\" field.", "<index>\nFor the 64-bit SIMD vector variant: is the element index in the range 0 to 1, encoded in the \"Vm<3>\" field.", "<index>\nFor the 128-bit SIMD vector variant: is the element index in the range 0 to 3, encoded in the \"M:Vm<3>\" field."], "decode": "if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;\nif Q == '1' && Vd<0> == '1' then UNDEFINED;\n\ninteger d = UInt(D:Vd);\ninteger n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);\ninteger m = if Q == '1' then UInt(Vm<2:0>) else UInt(Vm<2:0>:M);\n\ninteger index = if Q == '1' then UInt(M:Vm<3>) else UInt(Vm<3>);\ninteger esize = 32;\ninteger regs = if Q=='1' then 2 else 1;\ninteger datasize = if Q=='1' then 64 else 32;\nboolean sub_op = S=='1';", "operation": "CheckAdvSIMDEnabled();\nbits(datasize) operand1 ;\nbits(datasize) operand2 ;\nbits(64) operand3;\nbits(64) result;\nbits(esize DIV 2) element1;\nbits(esize DIV 2) element2;\n\nif Q=='0' then\n    operand1 = S[n]<datasize-1:0>;\n    operand2 = S[m]<datasize-1:0>;\nelse\n    operand1 = D[n]<datasize-1:0>;\n    operand2 = D[m]<datasize-1:0>;\nelement2 = Elem[operand2, index, esize DIV 2];\nfor r = 0 to regs-1\n    operand3 = D[d+r];\n    for e = 0 to 1\n        element1 = Elem[operand1, 2*r+e, esize DIV 2];\n        if sub_op then element1 = FPNeg(element1);\n        Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());\n    D[d+r] = result;"}, {"mnemonic": "VQMOVN, VQMOVUN", "short_desc": "Vector Saturating Move and Narrow", "full_desc": "Vector Saturating Move and Narrow copies each element of the operand vector to the corresponding element of the destination vector.", "syntax": ["VQMOVN{<c>}{<q>}.<dt> <Dd>, <Qm>\t; Signed result", "VQMOVUN{<c>}{<q>}.<dt> <Dd>, <Qm>\t; Unsigned result", "VQMOVN{<c>}{<q>}.<dt> <Dd>, <Qm>\t; Signed result", "VQMOVUN{<c>}{<q>}.<dt> <Dd>, <Qm>\t; Unsigned result"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if op == '00' then SEE \"VMOVN\";\nif size == '11' || Vm<0> == '1' then UNDEFINED;\nsrc_unsigned = (op == '11');  dest_unsigned = (op<0> == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);\n        (Elem[D[d],e,esize], sat) = SatQ(operand, esize, dest_unsigned);\n        if sat then FPSCR.QC = '1';"}, {"mnemonic": "UQSAX", "short_desc": "Unsigned Saturating Subtract and Add with Exchange", "full_desc": "Unsigned Saturating Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one unsigned 16-bit integer subtraction and one unsigned 16-bit addition, saturates the results to the 16-bit unsigned integer range 0 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["UQSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UQSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum  = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);\n    diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);\n    R[d]<15:0>  = UnsignedSat(sum, 16);\n    R[d]<31:16> = UnsignedSat(diff, 16);"}, {"mnemonic": "SXTAH", "short_desc": "Signed Extend and Add Halfword", "full_desc": "Signed Extend and Add Halfword extracts a 16-bit value from a register, sign-extends it to 32 bits, adds the result to a value from another register, and writes the final result to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.", "syntax": ["SXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; A1", "SXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "if Rn == '1111' then SEE \"SXTH\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d] = R[n] + SignExtend(rotated<15:0>, 32);"}, {"mnemonic": "VSTM, VSTMDB, VSTMIA", "short_desc": "Store multiple SIMD&FP registers", "full_desc": "Store multiple SIMD&FP registers stores multiple registers from the Advanced SIMD and floating-point register file to consecutive memory locations using an address from a general-purpose register.", "syntax": ["VSTMDB{<c>}{<q>}{.<size>} <Rn>!, <dreglist>\t; Decrement Before", "VSTM{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>\t; Increment After", "VSTMIA{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>\t; Increment After", "VSTMDB{<c>}{<q>}{.<size>} <Rn>!, <sreglist>\t; Decrement Before", "VSTM{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>\t; Increment After", "VSTMIA{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>\t; Increment After", "VSTMDB{<c>}{<q>}{.<size>} <Rn>!, <dreglist>\t; Decrement Before", "VSTM{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>\t; Increment After", "VSTMIA{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>\t; Increment After", "VSTMDB{<c>}{<q>}{.<size>} <Rn>!, <sreglist>\t; Decrement Before", "VSTM{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>\t; Increment After", "VSTMIA{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>\t; Increment After"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<size>\nAn optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers being transferred.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. If writeback is not specified, the PC can be used. However, Arm deprecates use of the PC.", "!\nSpecifies base register writeback. Encoded in the \"W\" field as 1 if present, otherwise 0.", "<sreglist>\nIs the list of consecutively numbered 32-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"Vd:D\", and \"imm8\" is set to the number of registers in the list. The list must contain at least one register.", "<dreglist>\nIs the list of consecutively numbered 64-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"D:Vd\", and \"imm8\" is set to twice the number of registers in the list. The list must contain at least one register, and must not contain more than 16 registers."], "decode": "if P == '0' && U == '0' && W == '0' then SEE \"Related encodings\";\nif P == '1' && W == '0' then SEE \"VSTR\";\nif P == U && W == '1' then UNDEFINED;\n// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)\nsingle_regs = FALSE;  add = (U == '1');  wback = (W == '1');\nd = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);\nregs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see \"FSTMX\".\nif n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;\nif regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;\nif imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    address = if add then R[n] else R[n]-imm32;\n    for r = 0 to regs-1\n        if single_regs then\n            MemA[address,4] = S[d+r];  address = address+4;\n        else\n            // Store as two word-aligned words in the correct order for current endianness.\n            MemA[address,4] = if BigEndian() then D[d+r]<63:32> else D[d+r]<31:0>;\n            MemA[address+4,4] = if BigEndian() then D[d+r]<31:0> else D[d+r]<63:32>;\n            address = address+8;\n    if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;"}, {"mnemonic": "MSR (immediate)", "short_desc": "Move immediate value to Special register", "full_desc": "Move immediate value to Special register moves selected bits of an immediate value to the corresponding bits in the , , or _<current_mode>.", "syntax": ["MSR{<c>}{<q>} <spec_reg>, #<imm>\t; A1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<spec_reg>\nIs one of:", "<imm>\nIs an immediate value. See  for the range of values."], "decode": "if mask == '0000' && R == '0' then SEE \"Related encodings\";\nimm32 = A32ExpandImm(imm12);  write_spsr = (R == '1');\nif mask == '0000' then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if write_spsr then\n        if PSTATE.M IN {M32_User,M32_System} then\n            UNPREDICTABLE;\n        else\n            SPSRWriteByInstr(imm32, mask);\n    else\n        // Attempts to change to an illegal mode will invoke the Illegal Execution state mechanism\n        CPSRWriteByInstr(imm32, mask);"}, {"mnemonic": "VREV64", "short_desc": "Vector Reverse in doublewords", "full_desc": "Vector Reverse in doublewords reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector, and places the result in the corresponding destination vector.", "syntax": ["VREV64{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VREV64{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VREV64{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VREV64{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if UInt(op)+UInt(size) >= 3 then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\n\nesize = 8 << UInt(size);\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\ninteger containers = 64 DIV container_size;\ninteger elements_per_container = container_size DIV esize;\n\nd = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n\n    bits(64) result;\n    integer element;\n    integer rev_element;\n    for r = 0 to regs-1\n        element = 0;\n        for c = 0 to containers-1\n            rev_element = element + elements_per_container - 1;\n            for e = 0 to elements_per_container-1\n                Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];\n                element = element + 1;\n                rev_element = rev_element - 1;\n        D[d+r] = result;"}, {"mnemonic": "VFMA", "short_desc": "Vector Fused Multiply Accumulate", "full_desc": "Vector Fused Multiply Accumulate multiplies corresponding elements of two vectors, and accumulates the results into the elements of the destination vector. The instruction does not round the result of the multiply before the accumulation.", "syntax": ["VFMA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VFMA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VFMA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VFMA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VFMA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VFMA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VFMA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VFMA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VFMA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VFMA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nadvsimd = TRUE; op1_neg = (op == '1');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);\nregs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if advsimd then // Advanced SIMD instruction\n        for r = 0 to regs-1\n            for e = 0 to elements-1\n                bits(esize) op1 = Elem[D[n+r],e,esize];\n                if op1_neg then op1 = FPNeg(op1);\n                Elem[D[d+r],e,esize] = FPMulAdd(Elem[D[d+r],e,esize],\n                                       op1, Elem[D[m+r],e,esize], StandardFPSCRValue());\n\n    else // VFP instruction\n        case esize of\n            when 16\n                op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;\n                S[d] = Zeros(16) : FPMulAdd(S[d]<15:0>, op16, S[m]<15:0>, FPSCR);\n            when 32\n                op32 = if op1_neg then FPNeg(S[n]) else S[n];\n                S[d] = FPMulAdd(S[d], op32, S[m], FPSCR);\n            when 64\n                op64 = if op1_neg then FPNeg(D[n]) else D[n];\n                D[d] = FPMulAdd(D[d], op64, D[m], FPSCR);"}, {"mnemonic": "VCVTT (BFloat16)", "short_desc": "Converts from a single-precision value to a BFloat16 value in the top half of a single-precision register.", "full_desc": "Converts the single-precision value in a single-precision register to BFloat16 format and writes the result in the top half of a single-precision register, preserving the bottom 16 bits of the register.", "syntax": ["VCVTT{<c>}{<q>}.BF16.F32 <Sd>, <Sm>\t; A1", "VCVTT{<c>}{<q>}.BF16.F32 <Sd>, <Sm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if !HaveAArch32BF16Ext() then UNDEFINED;\ninteger d = UInt(Vd:D);\ninteger m = UInt(Vm:M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    CheckVFPEnabled(TRUE);\n\n    S[d]<31:16> = FPConvertBF(S[m], FPSCR);"}, {"mnemonic": "STRBT", "short_desc": "Store Register Byte Unprivileged", "full_desc": "Store Register Byte Unprivileged stores a byte from a register to memory. For information about memory accesses see .", "syntax": ["STRBT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}\t; A1", "STRBT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}\t; A2", "STRBT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, but this is deprecated.", "<Rt>\nFor encoding A2 and T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\nThe shift to apply to the value read from . If absent, no shift is applied. Otherwise, see .", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 and encoded in the \"imm8\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');\nregister_form = FALSE;  imm32 = ZeroExtend(imm12, 32);\nif t == 15 || n == 15 || n == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode\n    EncodingSpecificOperations();\n    offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if postindex then R[n] else offset_addr;\n    MemU_unpriv[address,1] = R[t]<7:0>;\n    if postindex then R[n] = offset_addr;"}, {"mnemonic": "WFI", "short_desc": "Wait For Interrupt", "full_desc": "Wait For Interrupt is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. For more information, see .", "syntax": ["WFI{<c>}{<q>}\t; A1", "WFI{<c>}{<q>}\t; T1", "WFI{<c>}.W\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if !InterruptPending() then\n        if PSTATE.EL == EL0 then\n            // Check for traps described by the OS which may be EL1 or EL2.\n            AArch32.CheckForWFxTrap(EL1, FALSE);\n        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then\n            // Check for traps described by the Hypervisor.\n            AArch32.CheckForWFxTrap(EL2, FALSE);\n        if HaveEL(EL3) && PSTATE.M != M32_Monitor then\n            // Check for traps described by the Secure Monitor.\n            AArch32.CheckForWFxTrap(EL3, FALSE);\n        WaitForInterrupt();"}, {"mnemonic": "ORR, ORRS (register)", "short_desc": "Bitwise OR (register)", "full_desc": "Bitwise OR (register) performs a bitwise (inclusive) OR of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ORR, rotate right with extend", "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ORR, shift or rotate by value", "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ORRS, rotate right with extend", "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ORRS, shift or rotate by value", "ORR<c>{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "ORRS{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ORR, rotate right with extend", "ORR<c>.W {<Rd>,} <Rn>, <Rm>\t; ORR, shift or rotate by value", "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ORR, shift or rotate by value", "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ORRS, rotate right with extend", "ORRS.W {<Rd>,} <Rn>, <Rm>\t; ORRS, shift or rotate by value", "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ORRS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdn>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] OR shifted;\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "LDRB (register)", "short_desc": "Load Register Byte (register)", "full_desc": "Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. The offset register value can optionally be shifted.  For information about memory accesses see .", "syntax": ["LDRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]\t; Offset", "LDRB{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}\t; Post-indexed", "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!\t; Pre-indexed", "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]\t; T1", "LDRB{<c>}.W <Rt>, [<Rn>, {+}<Rm>]\t; T2", "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant.", "<Rn>\nFor encoding T1 and T2: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\nThe shift to apply to the value read from . If absent, no shift is applied. Otherwise, see .", "<imm>\nIf present, the size of the left shift to apply to the value from , in the range 1-3.  is encoded in imm2. If absent, no shift is specified and imm2 is encoded as ."], "decode": "if P == '0' && W == '1' then SEE \"LDRBT\";\nt = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);\nif t == 15 || m == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if index then offset_addr else R[n];\n    R[t] = ZeroExtend(MemU[address,1],32);\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "VPADD (floating-point)", "short_desc": "Vector Pairwise Add (floating-point)", "full_desc": "Vector Pairwise Add (floating-point) adds adjacent pairs of elements of two vectors, and places the results in the destination vector.", "syntax": ["VPADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; A1", "VPADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    bits(64) dest;\n    h = elements DIV 2;\n\n    for e = 0 to h-1\n        Elem[dest,e,esize]   = FPAdd(Elem[D[n],2*e,esize], Elem[D[n],2*e+1,esize], StandardFPSCRValue());\n        Elem[dest,e+h,esize] = FPAdd(Elem[D[m],2*e,esize], Elem[D[m],2*e+1,esize], StandardFPSCRValue());\n\n    D[d] = dest;"}, {"mnemonic": "VPUSH", "short_desc": "Push SIMD&FP registers to Stack", "syntax": ["VPUSH{<c>}{<q>}{.<size>} <dreglist>\t; Decrement Before", "VPUSH{<c>}{<q>}{.<size>} <sreglist>\t; Decrement Before", "VPUSH{<c>}{<q>}{.<size>} <dreglist>\t; Decrement Before", "VPUSH{<c>}{<q>}{.<size>} <sreglist>\t; Decrement Before"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<size>\nAn optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers being transferred.", "<sreglist>\nIs the list of consecutively numbered 32-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"Vd:D\", and \"imm8\" is set to the number of registers in the list. The list must contain at least one register.", "<dreglist>\nIs the list of consecutively numbered 64-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"D:Vd\", and \"imm8\" is set to twice the number of registers in the list. The list must contain at least one register, and must not contain more than 16 registers."]}, {"mnemonic": "VHSUB", "short_desc": "Vector Halving Subtract", "full_desc": "Vector Halving Subtract subtracts the elements of the second operand from the corresponding elements of the first operand, shifts each result right one bit, and places the final results in the destination vector. The results of the halving operations are truncated. There is no rounding version.", "syntax": ["VHSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VHSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VHSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VHSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '11' then UNDEFINED;\nadd = (op == '0');  unsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Int(Elem[D[n+r],e,esize], unsigned);\n            op2 = Int(Elem[D[m+r],e,esize], unsigned);\n            result = if add then op1+op2 else op1-op2;\n            Elem[D[d+r],e,esize] = result<esize:1>;"}, {"mnemonic": "LDA", "short_desc": "Load-Acquire Word", "full_desc": "Load-Acquire Word loads a word from memory and writes it to a register. The instruction also has memory ordering semantics as described in", "syntax": ["LDA{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "LDA{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt); n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    R[t] = MemO[address, 4];"}, {"mnemonic": "SEV", "short_desc": "Send Event", "full_desc": "Send Event is a hint instruction. It causes an event to be signaled to all PEs in the multiprocessor system. For more information, see .", "syntax": ["SEV{<c>}{<q>}\t; A1", "SEV{<c>}{<q>}\t; T1", "SEV{<c>}.W\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    SendEvent();"}, {"mnemonic": "USAD8", "short_desc": "Unsigned Sum of Absolute Differences", "full_desc": "Unsigned Sum of Absolute Differences performs four unsigned 8-bit subtractions, and adds the absolute values of the differences together.", "syntax": ["USAD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "USAD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    absdiff1 = Abs(UInt(R[n]<7:0>)   - UInt(R[m]<7:0>));\n    absdiff2 = Abs(UInt(R[n]<15:8>)  - UInt(R[m]<15:8>));\n    absdiff3 = Abs(UInt(R[n]<23:16>) - UInt(R[m]<23:16>));\n    absdiff4 = Abs(UInt(R[n]<31:24>) - UInt(R[m]<31:24>));\n    result = absdiff1 + absdiff2 + absdiff3 + absdiff4;\n    R[d] = result<31:0>;"}, {"mnemonic": "MCR", "short_desc": "Move to System register from general-purpose register or execute a System instruction", "full_desc": "Move to System register from general-purpose register or execute a System instruction. This instruction copies the value of a general-purpose register to a System register, or executes a System instruction.", "syntax": ["MCR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}\t; A1", "MCR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<coproc>\n", "<opc1>\nIs the opc1 parameter within the System register encoding space, in the range 0 to7, encoded in the \"opc1\" field.", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<CRn>\nIs the CRn parameter within the System register encoding space, in the range c0 to c15, encoded in the \"CRn\" field.", "<CRm>\nIs the CRm parameter within the System register encoding space, in the range c0 to c15, encoded in the \"CRm\" field.", "<opc2>\nIs the opc2 parameter within the System register encoding space, in the range 0 to7, encoded in the \"opc2\" field."], "decode": "t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;\nif t == 15  then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    AArch32.SysRegWrite(cp, ThisInstr(), R[t]);"}, {"mnemonic": "MVN, MVNS (register-shifted register)", "short_desc": "Bitwise NOT (register-shifted register)", "full_desc": "Bitwise NOT (register-shifted register) writes the bitwise inverse of a register-shifted register value to the destination register. It can optionally update the condition flags based on the result.", "syntax": ["MVNS{<c>}{<q>} <Rd>, <Rm>, <shift> <Rs>\t; Flag setting", "MVN{<c>}{<q>} <Rd>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = NOT(shifted);\n    R[d] = result;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result);\n        PSTATE.C = carry;\n        // PSTATE.V unchanged"}, {"mnemonic": "SHSUB8", "short_desc": "Signed Halving Subtract 8", "full_desc": "Signed Halving Subtract 8 performs four signed 8-bit integer subtractions, halves the results, and writes the results to the destination register.", "syntax": ["SHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);\n    diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);\n    diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);\n    diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);\n    R[d]<7:0>   = diff1<8:1>;\n    R[d]<15:8>  = diff2<8:1>;\n    R[d]<23:16> = diff3<8:1>;\n    R[d]<31:24> = diff4<8:1>;"}, {"mnemonic": "UBFX", "short_desc": "Unsigned Bit Field Extract", "full_desc": "Unsigned Bit Field Extract extracts any number of adjacent bits at any position from a register, zero-extends them to 32 bits, and writes the result to the destination register.", "syntax": ["UBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>\t; A1", "UBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field.", "<lsb>\nFor encoding A1: is the bit number of the least significant bit in the field, in the range 0 to 31, encoded in the \"lsb\" field.", "<lsb>\nFor encoding T1: is the bit number of the least significant bit in the field, in the range 0 to 31, encoded in the \"imm3:imm2\" field.", "<width>\nIs the width of the field, in the range 1 to 32-<lsb>, encoded in the \"widthm1\" field as <width>-1."], "decode": "d = UInt(Rd);  n = UInt(Rn);\nlsbit = UInt(lsb);  widthminus1 = UInt(widthm1);\nif d == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    msbit = lsbit + widthminus1;\n    if msbit <= 31 then\n        R[d] = ZeroExtend(R[n]<msbit:lsbit>, 32);\n    else\n        UNPREDICTABLE;"}, {"mnemonic": "SHSUB16", "short_desc": "Signed Halving Subtract 16", "full_desc": "Signed Halving Subtract 16 performs two signed 16-bit integer subtractions, halves the results, and writes the results to the destination register.", "syntax": ["SHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);\n    diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);\n    R[d]<15:0>  = diff1<16:1>;\n    R[d]<31:16> = diff2<16:1>;"}, {"mnemonic": "TEQ (register-shifted register)", "short_desc": "Test Equivalence (register-shifted register)", "full_desc": "Test Equivalence (register-shifted register) performs a bitwise exclusive OR operation on a register value and a register-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["TEQ{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>\t; A1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<type>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nshift_t = DecodeRegShift(stype);\nif n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] EOR shifted;\n    PSTATE.N = result<31>;\n    PSTATE.Z = IsZeroBit(result);\n    PSTATE.C = carry;\n    // PSTATE.V unchanged"}, {"mnemonic": "UADD8", "short_desc": "Unsigned Add 8", "full_desc": "Unsigned Add 8 performs four unsigned 8-bit integer additions, and writes the results to the destination register. It sets .GE according to the results of the additions.", "syntax": ["UADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);\n    sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);\n    sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);\n    sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);\n    R[d]<7:0>   = sum1<7:0>;\n    R[d]<15:8>  = sum2<7:0>;\n    R[d]<23:16> = sum3<7:0>;\n    R[d]<31:24> = sum4<7:0>;\n    PSTATE.GE<0>  = if sum1 >= 0x100 then '1' else '0';\n    PSTATE.GE<1>  = if sum2 >= 0x100 then '1' else '0';\n    PSTATE.GE<2>  = if sum3 >= 0x100 then '1' else '0';\n    PSTATE.GE<3>  = if sum4 >= 0x100 then '1' else '0';"}, {"mnemonic": "SMUAD, SMUADX", "short_desc": "Signed Dual Multiply Add", "full_desc": "Signed Dual Multiply Add performs two signed 16 x 16-bit multiplications. It adds the products together, and writes the result to the destination register.", "syntax": ["SMUAD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMUAD", "SMUADX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMUADX", "SMUAD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMUAD", "SMUADX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMUADX"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand2 = if m_swap then ROR(R[m],16) else R[m];\n    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);\n    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);\n    result = product1 + product2;\n    R[d] = result<31:0>;\n    if result != SInt(result<31:0>) then  // Signed overflow\n        PSTATE.Q = '1';"}, {"mnemonic": "MUL, MULS", "short_desc": "Multiply", "full_desc": "Multiply multiplies two register values. The least significant 32 bits of the result are written to the destination register. These 32 bits do not depend on whether the source register values are considered to be signed values or unsigned values.", "syntax": ["MULS{<c>}{<q>} <Rd>, <Rn>{, <Rm>}\t; Flag setting", "MUL{<c>}{<q>} <Rd>, <Rn>{, <Rm>}\t; Not flag setting", "MUL<c>{<q>} <Rdm>, <Rn>{, <Rdm>}\t; T1", "MULS{<q>} <Rdm>, <Rn>{, <Rdm>}\t; T1", "MUL<c>.W <Rd>, <Rn>{, <Rm>}\t; T2", "MUL{<c>}{<q>} <Rd>, <Rn>{, <Rm>}\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the second general-purpose source register holding the multiplier and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field. If omitted,  is used."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results\n    operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results\n    result = operand1 * operand2;\n    R[d] = result<31:0>;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result<31:0>);\n        // PSTATE.C, PSTATE.V unchanged"}, {"mnemonic": "VNMLA", "short_desc": "Vector Negate Multiply Accumulate", "full_desc": "Vector Negate Multiply Accumulate multiplies together two floating-point register values, adds the negation of the floating-point value in the destination register to the negation of the product, and writes the result back to the destination register.", "syntax": ["VNMLA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VNMLA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VNMLA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VNMLA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VNMLA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VNMLA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\nif size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nvtype = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL};\n\nif ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    case esize of\n        when 16\n            product16 = FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);\n            case vtype of\n                when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), FPNeg(product16), FPSCR);\n                when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), product16, FPSCR);\n                when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);\n        when 32\n            product32 = FPMul(S[n], S[m], FPSCR);\n            case vtype of\n                when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);\n                when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);\n                when VFPNegMul_VNMUL  S[d] = FPNeg(product32);\n        when 64\n            product64 = FPMul(D[n], D[m], FPSCR);\n            case vtype of\n                when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);\n                when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);\n                when VFPNegMul_VNMUL  D[d] = FPNeg(product64);"}, {"mnemonic": "CMP (register)", "short_desc": "Compare (register)", "full_desc": "Compare (register) subtracts an optionally-shifted register value from a register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMP{<c>}{<q>} <Rn>, <Rm>, RRX\t; Rotate right with extend", "CMP{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}\t; Shift or rotate by value", "CMP{<c>}{<q>} <Rn>, <Rm>\t; T1", "CMP{<c>}{<q>} <Rn>, <Rm>\t; T2", "CMP{<c>}{<q>} <Rn>, <Rm>, RRX\t; Rotate right with extend", "CMP{<c>}.W <Rn>, <Rm>\t; Shift or rotate by value", "CMP{<c>}{<q>} <Rn>, <Rm>, <shift> #<amount>\t; Shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1 and T3: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nFor encoding T2: is the first general-purpose source register, encoded in the \"N:Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1, T2 and T3: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T3: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "n = UInt(Rn);  m = UInt(Rm);\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');\n    PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "BKPT", "short_desc": "Breakpoint", "full_desc": "Breakpoint causes a Breakpoint Instruction exception.", "syntax": ["BKPT{<q>} {#}<imm>\t; A1", "BKPT{<q>} {#}<imm>\t; T1"], "symbols": ["<q>\nSee . An  instruction must be unconditional.", "<imm>\nFor encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm12:imm4\" field. This value:", "<imm>\nFor encoding T1: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field. This value:"], "decode": "imm16 = imm12:imm4;\nif cond != '1110' then UNPREDICTABLE;  // BKPT must be encoded with AL condition", "operation": "EncodingSpecificOperations();\nAArch32.SoftwareBreakpoint(imm16);"}, {"mnemonic": "SHA1SU1", "short_desc": "SHA1 schedule update 1", "full_desc": "SHA1 schedule update 1.", "syntax": ["SHA1SU1.32 <Qd>, <Qm>\t; A1", "SHA1SU1.32 <Qd>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA1Ext() then UNDEFINED;\nif size != '10' then UNDEFINED;\nif Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    X = Q[d>>1]; Y = Q[m>>1];\n    T = X EOR LSR(Y, 32);\n    W0 = ROL(T<31:0>, 1);\n    W1 = ROL(T<63:32>, 1);\n    W2 = ROL(T<95:64>, 1);\n    W3 = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);\n    Q[d>>1] = W3:W2:W1:W0;"}, {"mnemonic": "STREXD", "short_desc": "Store Register Exclusive Doubleword", "full_desc": "Store Register Exclusive Doubleword derives an address from a base register value, stores a 64-bit doubleword from two registers to the derived address if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.", "syntax": ["STREXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]\t; A1", "STREXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the destination general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rd\" field. The value returned is:", "<Rt>\nFor encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.  must be even-numbered and not R14.", "<Rt>\nFor encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nFor encoding A1: is the second general-purpose register to be transferred.  must be .", "<Rt2>\nFor encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);\nif d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;\nif d == n || d == t || d == t2 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.\n    value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];\n    if AArch32.ExclusiveMonitorsPass(address,8) then\n        MemA[address,8] = value;  R[d] = ZeroExtend('0');\n    else\n        R[d] = ZeroExtend('1');"}, {"mnemonic": "VSHRN", "short_desc": "Vector Shift Right Narrow", "full_desc": "Vector Shift Right Narrow takes each element in a vector, right shifts them by an immediate value, and places the truncated results in the destination vector. For rounded results, see .", "syntax": ["VSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>\t; A1", "VSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<imm>\nIs an immediate value, in the range 1 to /2, encoded in the \"imm6\" field as /2 - ."], "decode": "if imm6 == '000xxx' then SEE \"Related encodings\";\nif Vm<0> == '1' then UNDEFINED;\ncase imm6 of\n    when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);\n    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);\n    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);\nd = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        result = LSR(Elem[Qin[m>>1],e,2*esize], shift_amount);\n        Elem[D[d],e,esize] = result<esize-1:0>;"}, {"mnemonic": "VTRN", "short_desc": "Vector Transpose", "full_desc": "Vector Transpose treats the elements of its operand vectors as elements of 2 x 2 matrices, and transposes the matrices.", "syntax": ["VTRN{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VTRN{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VTRN{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VTRN{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    h = elements DIV 2;\n\n    for r = 0 to regs-1\n        if d == m then\n            D[d+r] = bits(64) UNKNOWN;\n        else\n            for e = 0 to h-1\n                Elem[D[d+r],2*e+1,esize] = Elem[Din[m+r],2*e,esize];\n                Elem[D[m+r],2*e,esize] = Elem[Din[d+r],2*e+1,esize];"}, {"mnemonic": "VFMS", "short_desc": "Vector Fused Multiply Subtract", "full_desc": "Vector Fused Multiply Subtract negates the elements of one vector and multiplies them with the corresponding elements of another vector, adds the products to the corresponding elements of the destination vector, and places the results in the destination vector. The instruction does not round the result of the multiply before the addition.", "syntax": ["VFMS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VFMS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VFMS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VFMS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VFMS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VFMS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VFMS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VFMS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VFMS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VFMS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nadvsimd = TRUE; op1_neg = (op == '1');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);\nregs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if advsimd then // Advanced SIMD instruction\n        for r = 0 to regs-1\n            for e = 0 to elements-1\n                bits(esize) op1 = Elem[D[n+r],e,esize];\n                if op1_neg then op1 = FPNeg(op1);\n                Elem[D[d+r],e,esize] = FPMulAdd(Elem[D[d+r],e,esize],\n                                       op1, Elem[D[m+r],e,esize], StandardFPSCRValue());\n\n    else // VFP instruction\n        case esize of\n            when 16\n                op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;\n                S[d] = Zeros(16) : FPMulAdd(S[d]<15:0>, op16, S[m]<15:0>, FPSCR);\n            when 32\n                op32 = if op1_neg then FPNeg(S[n]) else S[n];\n                S[d] = FPMulAdd(S[d], op32, S[m], FPSCR);\n            when 64\n                op64 = if op1_neg then FPNeg(D[n]) else D[n];\n                D[d] = FPMulAdd(D[d], op64, D[m], FPSCR);"}, {"mnemonic": "VACGE", "short_desc": "Vector Absolute Compare Greater Than or Equal", "full_desc": "Vector Absolute Compare Greater Than or Equal takes the absolute value of each element in a vector, and compares it with the absolute value of the corresponding element of a second vector. If the first is greater than or equal to the second, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VACGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VACGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VACGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VACGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nor_equal = (op == '0');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = FPAbs(Elem[D[n+r],e,esize]);  op2 = FPAbs(Elem[D[m+r],e,esize]);\n            if or_equal then\n                test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());\n            else\n                test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "MSR (Banked register)", "short_desc": "Move general-purpose register to Banked or Special register", "full_desc": "Move to Banked or Special register from general-purpose register moves the value of a general-purpose register to the Banked general-purpose register or  of the specified mode, or to .", "syntax": ["MSR{<c>}{<q>} <banked_reg>, <Rn>\t; A1", "MSR{<c>}{<q>} <banked_reg>, <Rn>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<banked_reg>\n", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field."], "decode": "n = UInt(Rn);  write_spsr = (R == '1');\nif n == 15 then UNPREDICTABLE;\nSYSm = M:M1;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if PSTATE.EL == EL0 then\n        UNPREDICTABLE;\n    else\n        mode = PSTATE.M;\n        if write_spsr then\n            SPSRaccessValid(SYSm, mode);             // Check for UNPREDICTABLE cases\n            case SYSm of\n                when '01110'  SPSR_fiq = R[n];\n                when '10000'  SPSR_irq = R[n];\n                when '10010'  SPSR_svc = R[n];\n                when '10100'  SPSR_abt = R[n];\n                when '10110'  SPSR_und = R[n];\n                when '11100'\n                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();\n                    SPSR_mon = R[n];\n                when '11110'  SPSR_hyp = R[n];\n        else\n            BankedRegisterAccessValid(SYSm, mode);  // Check for UNPREDICTABLE cases\n            case SYSm of\n                when '00xxx'                       // Access the User mode registers\n                    m = UInt(SYSm<2:0>) + 8;\n                    Rmode[m,M32_User] = R[n];\n                when '01xxx'                       // Access the FIQ mode registers\n                    m = UInt(SYSm<2:0>) + 8;\n                    Rmode[m,M32_FIQ] = R[n];\n                when '1000x'                       // Access the IRQ mode registers\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    Rmode[m,M32_IRQ] = R[n];\n                when '1001x'                       // Access the Supervisor mode registers\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    Rmode[m,M32_Svc] = R[n];\n                when '1010x'                       // Access the Abort mode registers\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    Rmode[m,M32_Abort] = R[n];\n                when '1011x'                       // Access the Undefined mode registers\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    Rmode[m,M32_Undef] = R[n];\n                when '1110x'                       // Access Monitor registers\n                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();\n                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP\n                    Rmode[m,M32_Monitor] = R[n];\n                when '11110'                       // Access ELR_hyp register\n                    ELR_hyp = R[n];\n                when '11111'                       // Access SP_hyp register\n                    Rmode[13,M32_Hyp] = R[n];"}, {"mnemonic": "QADD", "short_desc": "Saturating Add", "full_desc": "Saturating Add adds two register values, saturates the result to the 32-bit signed integer range -2 to (2 - 1), and writes the result to the destination register. If saturation occurs, it sets .Q to 1.", "syntax": ["QADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>\t; A1", "QADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rn>\nIs the second general-purpose source register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (R[d], sat) = SignedSatQ(SInt(R[m]) + SInt(R[n]), 32);\n    if sat then\n        PSTATE.Q = '1';"}, {"mnemonic": "VACLE", "short_desc": "Vector Absolute Compare Less Than or Equal", "syntax": ["VACLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VACLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VACLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VACLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field."]}, {"mnemonic": "TST (register)", "short_desc": "Test (register)", "full_desc": "Test (register) performs a bitwise AND operation on a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["TST{<c>}{<q>} <Rn>, <Rm>, RRX\t; Rotate right with extend", "TST{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}\t; Shift or rotate by value", "TST{<c>}{<q>} <Rn>, <Rm>\t; T1", "TST{<c>}{<q>} <Rn>, <Rm>, RRX\t; Rotate right with extend", "TST{<c>}.W <Rn>, <Rm>\t; Shift or rotate by value", "TST{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}\t; Shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1 and T2: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "n = UInt(Rn);  m = UInt(Rm);\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] AND shifted;\n    PSTATE.N = result<31>;\n    PSTATE.Z = IsZeroBit(result);\n    PSTATE.C = carry;\n    // PSTATE.V unchanged"}, {"mnemonic": "SHA1SU0", "short_desc": "SHA1 schedule update 0", "full_desc": "SHA1 schedule update 0.", "syntax": ["SHA1SU0.32 <Qd>, <Qn>, <Qm>\t; A1", "SHA1SU0.32 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA1Ext() then UNDEFINED;\nif Q != '1' then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    op1 = Q[d>>1]; op2 = Q[n>>1]; op3 = Q[m>>1];\n    op2 = op2<63:0> : op1<127:64>;\n    Q[d>>1] = op1 EOR op2 EOR op3;"}, {"mnemonic": "UDF", "short_desc": "Permanently Undefined", "full_desc": "Permanently Undefined generates an Undefined Instruction exception.", "syntax": ["UDF{<c>}{<q>} {#}<imm>\t; A1", "UDF{<c>}{<q>} {#}<imm>\t; T1", "UDF{<c>}.W {#}<imm>\t; T2", "UDF{<c>}{<q>} {#}<imm>\t; T2"], "symbols": ["<c>\nFor encoding A1: see .  must be  or omitted.", "<c>\nFor encoding T1 and T2: see . Arm deprecates using any  value other than .", "<q>\nSee .", "<imm>\nFor encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm12:imm4\" field. The PE ignores the value of this constant.", "<imm>\nFor encoding T1: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field. The PE ignores the value of this constant.", "<imm>\nFor encoding T2: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm4:imm12\" field. The PE ignores the value of this constant."], "decode": "imm32 = ZeroExtend(imm12:imm4, 32);\n// imm32 is for assembly and disassembly only, and is ignored by hardware.", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    UNDEFINED;"}, {"mnemonic": "BFC", "short_desc": "Bit Field Clear", "full_desc": "Bit Field Clear clears any number of adjacent bits at any position in a register, without affecting the other bits in the register.", "syntax": ["BFC{<c>}{<q>} <Rd>, #<lsb>, #<width>\t; A1", "BFC{<c>}{<q>} <Rd>, #<lsb>, #<width>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>\nFor encoding A1: is the least significant bit to be cleared, in the range 0 to 31, encoded in the \"lsb\" field.", "<lsb>\nFor encoding T1: is the least significant bit that is to be cleared, in the range 0 to 31, encoded in the \"imm3:imm2\" field.", "<width>\nIs the number of bits to be cleared, in the range 1 to 32-<lsb>, encoded in the \"msb\" field as <lsb>+<width>-1."], "decode": "d = UInt(Rd);  msbit = UInt(msb);  lsbit = UInt(lsb);\nif d == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if msbit >= lsbit then\n        R[d]<msbit:lsbit> = Replicate('0', msbit-lsbit+1);\n        // Other bits of R[d] are unchanged\n    else\n        UNPREDICTABLE;"}, {"mnemonic": "LDAEXD", "short_desc": "Load-Acquire Exclusive Doubleword", "full_desc": "Load-Acquire Exclusive Doubleword loads a doubleword from memory, writes it to two registers and:", "syntax": ["LDAEXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]\t; A1", "LDAEXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.  must be even-numbered and not R14.", "<Rt>\nFor encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nFor encoding A1: is the second general-purpose register to be transferred.  must be .", "<Rt2>\nFor encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt);  t2 = t + 1;  n = UInt(Rn);\nif Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    AArch32.SetExclusiveMonitors(address, 8);\n    value = MemO[address, 8];\n    // Extract words from 64-bit loaded value such that R[t] is\n    // loaded from address and R[t2] from address+4.\n    R[t]  = if BigEndian() then value<63:32> else value<31:0>;\n    R[t2] = if BigEndian() then value<31:0>  else value<63:32>;"}, {"mnemonic": "STRB (immediate)", "short_desc": "Store Register Byte (immediate)", "full_desc": "Store Register Byte (immediate) calculates an address from a base register value and an immediate offset, and stores a byte from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about memory accesses see .", "syntax": ["STRB{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "STRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "STRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1", "STRB{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]\t; T2", "STRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T2", "STRB{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]\t; Offset", "STRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "STRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant, but this is deprecated.", "<Rn>\nFor encoding T1, T2 and T3: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is an optional 5-bit unsigned immediate byte offset, in the range 0 to 31, defaulting to 0 and encoded in the \"imm5\" field.", "<imm>\nFor encoding T2: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T3: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field."], "decode": "if P == '0' && W == '1' then SEE \"STRBT\";\nt = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        MemU[address,1] = R[t]<7:0>;\n        if wback then R[n] = offset_addr;\nelse\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        MemU[address,1] = R[t]<7:0>;\n        if wback then R[n] = offset_addr;"}, {"mnemonic": "VLD1 (single element to all lanes)", "short_desc": "Load single 1-element structure and replicate to all lanes of one register", "full_desc": "Load single 1-element structure and replicate to all lanes of one register loads one element from memory into every element of one or two vectors. For details of the addressing mode see .", "syntax": ["VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}],<Rm>\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nWhen  == 8,  must be omitted, otherwise it is the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' || (size == '00' && a == '1') then UNDEFINED;\nebytes = 1 << UInt(size);  regs = if T == '0' then 1 else 2;\nalignment = if a == '0' then 1 else ebytes;\nd = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d+regs > 32 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    bits(64) replicated_element = Replicate(MemU[address,ebytes]);\n    for r = 0 to regs-1\n        D[d+r] = replicated_element;\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + ebytes;"}, {"mnemonic": "VST1 (single element from one lane)", "short_desc": "Store single element from one lane of one register", "full_desc": "Store single element from one lane of one register stores one element to memory from one element of a register. For details of the addressing mode see .", "syntax": ["VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2 and A3: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the single 64-bit name of the SIMD&FP register holding the element.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nWhen  == 8,  must be omitted, otherwise it is the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then UNDEFINED;\nif index_align<0> != '0' then UNDEFINED;\nebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;\nd = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = TRUE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    MemU[address,ebytes] = Elem[D[d],index];\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + ebytes;"}, {"mnemonic": "VRINTA (Advanced SIMD)", "short_desc": "Vector Round floating-point to integer towards Nearest with Ties to Away", "full_desc": "Vector Round floating-point to integer towards Nearest with Ties to Away rounds a vector of floating-point values to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTA{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTA{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VRINTA{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTA{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if op<2> != op<0> then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\n// Rounding encoded differently from other VCVT and VRINT instructions\nrounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        op1 = Elem[D[m+r],e,esize];\n        result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);\n        Elem[D[d+r],e,esize] = result;"}, {"mnemonic": "VUSDOT (by element)", "short_desc": "Dot Product index form with unsigned and signed integers (by element)", "full_desc": "Dot Product index form with unsigned and signed integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["VUSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VUSDOT{<q>}.S8 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector", "VUSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VUSDOT{<q>}.S8 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm\" field.", "<index>\nIs the element index in the range 0 to 1, encoded in the \"M\" field."], "decode": "if !HaveAArch32Int8MatMulExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;\nboolean op1_unsigned = (U == '0');\nboolean op2_unsigned = (U == '1');\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(Vm);\ninteger i = UInt(M);\ninteger regs = if Q == '1' then 2 else 1;", "operation": "CheckAdvSIMDEnabled();\nbits(64) operand1;\nbits(64) operand2;\nbits(64) result;\n\noperand2 = Din[m];\nfor r = 0 to regs-1\n    operand1 = Din[n+r];\n    result = Din[d+r];\n    for e = 0 to 1\n        bits(32) res = Elem[result, e, 32];\n        for b = 0 to 3\n            element1 = Int(Elem[operand1, 4 * e + b, 8], op1_unsigned);\n            element2 = Int(Elem[operand2, 4 * i + b, 8], op2_unsigned);\n            res = res + element1 * element2;\n        Elem[result, e, 32] = res;\n    D[d+r] = result;"}, {"mnemonic": "SHSAX", "short_desc": "Signed Halving Subtract and Add with Exchange", "full_desc": "Signed Halving Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one signed 16-bit integer subtraction and one signed 16-bit addition, halves the results, and writes the results to the destination register.", "syntax": ["SHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum  = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);\n    diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);\n    R[d]<15:0>  = sum<16:1>;\n    R[d]<31:16> = diff<16:1>;"}, {"mnemonic": "RSB, RSBS (register)", "short_desc": "Reverse Subtract (register)", "full_desc": "Reverse Subtract (register) subtracts a register value from an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; RSB, rotate right with extend", "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; RSB, shift or rotate by value", "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; RSBS, rotate right with extend", "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; RSBS, shift or rotate by value", "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; RSB, rotate right with extend", "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; RSB, shift or rotate by value", "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; RSBS, rotate right with extend", "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; RSBS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VCVTM (Advanced SIMD)", "short_desc": "Vector Convert floating-point to integer with Round towards -Infinity", "full_desc": "Vector Convert floating-point to integer with Round towards -Infinity converts each element in a vector from floating-point to integer using the Round towards -Infinity rounding mode, and places the results in a second vector.", "syntax": ["VCVTM{<q>}.<dt>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVTM{<q>}.<dt>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector", "VCVTM{<q>}.<dt>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVTM{<q>}.<dt>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<dt2>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\nrounding = FPDecodeRM(RM);  unsigned = (op == '1');\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nbits(esize) result;\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,\n                                         StandardFPSCRValue(), rounding);"}, {"mnemonic": "STRT", "short_desc": "Store Register Unprivileged", "full_desc": "Store Register Unprivileged stores a word from a register to memory. For information about memory accesses see .", "syntax": ["STRT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}\t; A1", "STRT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}\t; A2", "STRT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1 and A2: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, but this is deprecated.", "<Rt>\nFor encoding T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\nThe shift to apply to the value read from . If absent, no shift is applied. Otherwise, see .", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 and encoded in the \"imm8\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');\nregister_form = FALSE;  imm32 = ZeroExtend(imm12, 32);\nif n == 15 || n == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode\n    EncodingSpecificOperations();\n    offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if postindex then R[n] else offset_addr;\n    if t == 15 then  // Only possible for encodings A1 and A2\n        data = PCStoreValue();\n    else\n        data = R[t];\n    MemU_unpriv[address,4] = data;\n    if postindex then R[n] = offset_addr;"}, {"mnemonic": "VST3 (single 3-element structure from one lane)", "short_desc": "Store single 3-element structure from one lane of three registers", "full_desc": "Store single 3-element structure from one lane of three registers stores one 3-element structure to memory from corresponding elements of three registers. For details of the addressing mode see .", "syntax": ["VST3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2 and A3: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the three SIMD&FP registers holding the element.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then UNDEFINED;\nif index_align<0> != '0' then UNDEFINED;\nebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d3 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];\n    MemU[address,         ebytes] = Elem[D[d], index];\n    MemU[address+ebytes,  ebytes] = Elem[D[d2],index];\n    MemU[address+2*ebytes,ebytes] = Elem[D[d3],index];\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 3*ebytes;"}, {"mnemonic": "VLD3 (single 3-element structure to all lanes)", "short_desc": "Load single 3-element structure and replicate to all lanes of three registers", "full_desc": "Load single 3-element structure and replicate to all lanes of three registers loads one 3-element structure from memory into all lanes of three registers. For details of the addressing mode see .", "syntax": ["VLD3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]\t; Offset", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!\t; Post-indexed", "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of three SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' || a == '1' then UNDEFINED;\nebytes = 1 << UInt(size);\ninc = if T == '0' then 1 else 2;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d3 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];\n    D[d] = Replicate(MemU[address,ebytes]);\n    D[d2] = Replicate(MemU[address+ebytes,ebytes]);\n    D[d3] = Replicate(MemU[address+2*ebytes,ebytes]);\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 3*ebytes;"}, {"mnemonic": "QSUB8", "short_desc": "Saturating Subtract 8", "full_desc": "Saturating Subtract 8 performs four 8-bit integer subtractions, saturates the results to the 8-bit signed integer range -2 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["QSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "QSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);\n    diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);\n    diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);\n    diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);\n    R[d]<7:0>   = SignedSat(diff1, 8);\n    R[d]<15:8>  = SignedSat(diff2, 8);\n    R[d]<23:16> = SignedSat(diff3, 8);\n    R[d]<31:24> = SignedSat(diff4, 8);"}, {"mnemonic": "VRINTA (floating-point)", "short_desc": "Round floating-point to integer to Nearest with Ties to Away", "full_desc": "Round floating-point to integer to Nearest with Ties to Away rounds a floating-point value to an integral floating-point value of the same size using the Round to Nearest with Ties to Away rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTA{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTA{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTA{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VRINTA{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VRINTA{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VRINTA{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nrounding = FPDecodeRM(RM);  exact = FALSE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\ncase esize of\n    when 16\n        S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);\n    when 32\n        S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);\n    when 64\n        D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);"}, {"mnemonic": "SHA1C", "short_desc": "SHA1 hash update (choose)", "full_desc": "SHA1 hash update (choose).", "syntax": ["SHA1C.32 <Qd>, <Qn>, <Qm>\t; A1", "SHA1C.32 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA1Ext() then UNDEFINED;\nif Q != '1' then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    X = Q[d>>1];\n    Y = Q[n>>1]<31:0>; // Note: 32 bits wide\n    W = Q[m>>1];\n    for e = 0 to 3\n        t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);\n        Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n        X<63:32> = ROL(X<63:32>, 30);\n        <Y, X> = ROL(Y:X, 32);\n    Q[d>>1] = X;"}, {"mnemonic": "EOR, EORS (register-shifted register)", "short_desc": "Bitwise Exclusive OR (register-shifted register)", "full_desc": "Bitwise Exclusive OR (register-shifted register) performs a bitwise Exclusive OR of a register value and a register-shifted register value. It writes the result to the destination register, and can optionally update the condition flags based on the result.", "syntax": ["EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] EOR shifted;\n    R[d] = result;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result);\n        PSTATE.C = carry;\n        // PSTATE.V unchanged"}, {"mnemonic": "LDRH (immediate)", "short_desc": "Load Register Halfword (immediate)", "full_desc": "Load Register Halfword (immediate) calculates an address from a base register value and an immediate offset, loads a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing.  For information about memory accesses see .", "syntax": ["LDRH{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "LDRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1", "LDRH{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]\t; T2", "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T2", "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]\t; Offset", "LDRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1, T2 and T3: is the general-purpose base register, encoded in the \"Rn\" field. For PC use see .", "<Rn>\nFor encoding T1: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is the optional positive unsigned immediate byte offset, a multiple of 2, in the range 0 to 62, defaulting to 0 and encoded in the \"imm5\" field as <imm>/2.", "<imm>\nFor encoding T2: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T3: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field."], "decode": "if Rn == '1111' then SEE \"LDRH (literal)\";\nif P == '0' && W == '1' then SEE \"LDRHT\";\nt = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 || (wback && n == t) then UNPREDICTABLE;", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        data = MemU[address,2];\n        if wback then R[n] = offset_addr;\n        R[t] = ZeroExtend(data, 32);\nelse\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n        address = if index then offset_addr else R[n];\n        data = MemU[address,2];\n        if wback then R[n] = offset_addr;\n        R[t] = ZeroExtend(data, 32);"}, {"mnemonic": "VMLSL (by scalar)", "short_desc": "Vector Multiply Subtract Long (by scalar)", "full_desc": "Vector Multiply Subtract Long multiplies elements of a vector by a scalar, and subtracts the products from corresponding elements of the destination vector. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["VMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>\t; A1", "VMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm[x]>\nIs the 64-bit name of the second SIMD&FP source register holding the scalar. If  is  or ,  is restricted to D0-D7.  is encoded in \"Vm<2:0>\", and  is encoded in \"M:Vm<3>\". If  is  or ,  is restricted to D0-D15.  is encoded in \"Vm\", and  is encoded in \"M\"."], "decode": "if size == '11' then SEE \"Related encodings\";\nif size == '00' || Vd<0> == '1' then UNDEFINED;\nunsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;\nd = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;\nif size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);\nif size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);\n            if floating_point then\n                fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));\n                Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());\n            else\n                addend = if add then op1val*op2val else -op1val*op2val;\n                if long_destination then\n                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;\n                else\n                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;"}, {"mnemonic": "VQNEG", "short_desc": "Vector Saturating Negate", "full_desc": "Vector Saturating Negate negates each element in a vector, and places the results in the destination vector.", "syntax": ["VQNEG{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VQNEG{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VQNEG{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VQNEG{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            result = -SInt(Elem[D[m+r],e,esize]);\n            (Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);\n            if sat then FPSCR.QC = '1';"}, {"mnemonic": "VEXT (multibyte elements)", "short_desc": "Vector Extract", "syntax": ["VEXT{<c>}{<q>}.<size> {<Dd>,} <Dn>, <Dm>, #<imm>\t; 64-bit SIMD vector", "VEXT{<c>}{<q>}.<size> {<Qd>,} <Qn>, <Qm>, #<imm>\t; 128-bit SIMD vector", "VEXT{<c>}{<q>}.<size> {<Dd>,} <Dn>, <Dm>, #<imm>\t; 64-bit SIMD vector", "VEXT{<c>}{<q>}.<size> {<Qd>,} <Qn>, <Qm>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\nFor the 64-bit SIMD vector variant: is the size of the operation, and can be one of 16 or 32.", "<size>\nFor the 128-bit SIMD vector variant: is the size of the operation, and can be one of 16, 32 or 64.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nFor the 64-bit SIMD vector variant: is the location of the extracted result in the concatenation of the operands, as a number of bytes from the least significant end, in the range 0 to (128/)-1.", "<imm>\nFor the 128-bit SIMD vector variant: is the location of the extracted result in the concatenation of the operands, as a number of bytes from the least significant end, in the range 0 to (64/)-1."]}, {"mnemonic": "QASX", "short_desc": "Saturating Add and Subtract with Exchange", "full_desc": "Saturating Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one 16-bit integer addition and one 16-bit subtraction, saturates the results to the 16-bit signed integer range -2 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["QASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "QASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);\n    sum  = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);\n    R[d]<15:0>  = SignedSat(diff, 16);\n    R[d]<31:16> = SignedSat(sum, 16);"}, {"mnemonic": "PUSH", "short_desc": "Push Multiple Registers to Stack", "full_desc": "Push Multiple Registers to Stack stores multiple general-purpose registers to the stack, storing to consecutive memory locations ending just below the address in SP, and updates SP to point to the start of the stored data.", "syntax": ["PUSH{<c>}{<q>} <registers>\t; T1", "STMDB{<c>}{<q>} SP!, <registers>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<registers>\nIs a list of one or more registers to be stored, separated by commas and surrounded by { and }."], "decode": "registers = '0':M:'000000':register_list;  UnalignedAllowed = FALSE;\nif BitCount(registers) < 1 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = SP - 4*BitCount(registers);\n    for i = 0 to 14\n        if registers<i> == '1' then\n            if i == 13 && i != LowestSetBit(registers) then  // Only possible for encoding A1\n                MemA[address,4] = bits(32) UNKNOWN;\n            else\n                if UnalignedAllowed then\n                    MemU[address,4] = R[i];\n                else\n                    MemA[address,4] = R[i];\n            address = address + 4;\n    if registers<15> == '1' then  // Only possible for encoding A1 or A2\n        if UnalignedAllowed then\n            MemU[address,4] = PCStoreValue();\n        else\n            MemA[address,4] = PCStoreValue();\n    SP = SP - 4*BitCount(registers);"}, {"mnemonic": "SUB, SUBS (SP minus immediate)", "short_desc": "Subtract from SP (immediate)", "full_desc": "Subtract from SP (immediate) subtracts an immediate value from the SP value, and writes the result to the destination register.", "syntax": ["SUB{<c>}{<q>} {<Rd>,} SP, #<const>\t; SUB", "SUBS{<c>}{<q>} {<Rd>,} SP, #<const>\t; SUBS", "SUB{<c>}{<q>} {SP,} SP, #<imm7>\t; T1", "SUB{<c>}.W {<Rd>,} SP, #<const>\t; SUB", "SUB{<c>}{<q>} {<Rd>,} SP, #<const>\t; SUB", "SUBS{<c>}{<q>} {<Rd>,} SP, #<const>\t; SUBS", "SUB{<c>}{<q>} {<Rd>,} SP, #<imm12>\t; T3", "SUBW{<c>}{<q>} {<Rd>,} SP, #<imm12>\t; T3"], "symbols": ["<c>\nSee .", "<q>\nSee .", "SP,\nIs the stack pointer.", "<imm7>\nIs the unsigned immediate, a multiple of 4, in the range 0 to 508, encoded in the \"imm7\" field as <imm7>/4.", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the SP. If the PC is used:", "<Rd>\nFor encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the SP.", "<imm12>\nIs a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T2: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result, nzcv) = AddWithCarry(SP, NOT(imm32), '1');\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VMUL (integer and polynomial)", "short_desc": "Vector Multiply (integer and polynomial)", "full_desc": "Vector Multiply multiplies corresponding elements in two vectors.", "syntax": ["VMUL{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMUL{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VMUL{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMUL{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' || (op == '1' && size != '00') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nunsigned = FALSE;  // \"Don't care\" value: TRUE produces same functionality\npolynomial = (op == '1');  long_destination = FALSE;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);\n            op2 = Elem[Din[m+r],e,esize];  op2val = Int(op2, unsigned);\n            if polynomial then\n                product = PolynomialMult(op1,op2);\n            else\n                product = (op1val*op2val)<2*esize-1:0>;\n            if long_destination then\n                Elem[Q[d>>1],e,2*esize] = product;\n            else\n                Elem[D[d+r],e,esize] = product<esize-1:0>;"}, {"mnemonic": "USUB16", "short_desc": "Unsigned Subtract 16", "full_desc": "Unsigned Subtract 16 performs two 16-bit unsigned integer subtractions, and writes the results to the destination register. It sets .GE according to the results of the subtractions.", "syntax": ["USUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "USUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);\n    diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);\n    R[d]<15:0>  = diff1<15:0>;\n    R[d]<31:16> = diff2<15:0>;\n    PSTATE.GE<1:0> = if diff1 >= 0 then '11' else '00';\n    PSTATE.GE<3:2> = if diff2 >= 0 then '11' else '00';"}, {"mnemonic": "POP", "short_desc": "Pop Multiple Registers from Stack", "full_desc": "Pop Multiple Registers from Stack loads multiple general-purpose registers from the stack, loading from consecutive memory locations starting at the address in SP, and updates SP to point just above the loaded data.", "syntax": ["POP{<c>}{<q>} <registers>\t; T1", "LDM{<c>}{<q>} SP!, <registers>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<registers>\nIs a list of one or more registers to be loaded, separated by commas and surrounded by { and }."], "decode": "registers = P:'0000000':register_list;   UnalignedAllowed = FALSE;\nif BitCount(registers) < 1 then UNPREDICTABLE;\nif registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = SP;\n    for i = 0 to 14\n        if registers<i> == '1' then\n            R[i] = if UnalignedAllowed then MemU[address,4] else MemA[address,4];\n            address = address + 4;\n    if registers<15> == '1' then\n        if UnalignedAllowed then\n            if address<1:0> == '00' then\n                LoadWritePC(MemU[address,4]);\n            else\n                UNPREDICTABLE;\n        else\n            LoadWritePC(MemA[address,4]);\n    if registers<13> == '0' then SP = SP + 4*BitCount(registers);\n    if registers<13> == '1' then SP = bits(32) UNKNOWN;"}, {"mnemonic": "UDIV", "short_desc": "Unsigned Divide", "full_desc": "Unsigned Divide divides a 32-bit unsigned integer register value by a 32-bit unsigned integer register value, and writes the result to the destination register. The condition flags are not affected.", "syntax": ["UDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the dividend, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the divisor, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);\nif d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if UInt(R[m]) == 0 then\n        result = 0;\n    else\n        result = RoundTowardsZero(Real(UInt(R[n])) / Real(UInt(R[m])));\n    R[d] = result<31:0>;"}, {"mnemonic": "VSWP", "short_desc": "Vector Swap", "full_desc": "Vector Swap exchanges the contents of two vectors. The vectors can be either doubleword or quadword. There is no distinction between data types.", "syntax": ["VSWP{<c>}{<q>}{.<dt>} <Dd>, <Dm>\t; 64-bit SIMD vector", "VSWP{<c>}{<q>}{.<dt>} <Qd>, <Qm>\t; 128-bit SIMD vector", "VSWP{<c>}{<q>}{.<dt>} <Dd>, <Dm>\t; 64-bit SIMD vector", "VSWP{<c>}{<q>}{.<dt>} <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size != '00' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        if d == m then\n            D[d+r] = bits(64) UNKNOWN;\n        else\n            D[d+r] = Din[m+r];\n            D[m+r] = Din[d+r];"}, {"mnemonic": "LDRBT", "short_desc": "Load Register Byte Unprivileged", "full_desc": "Load Register Byte Unprivileged loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRBT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}\t; A1", "LDRBT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}\t; A2", "LDRBT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, but this is deprecated.", "<Rt>\nFor encoding A2 and T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\nThe shift to apply to the value read from . If absent, no shift is applied. Otherwise, see .", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 and encoded in the \"imm8\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');\nregister_form = FALSE;  imm32 = ZeroExtend(imm12, 32);\nif t == 15 || n == 15 || n == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode\n    EncodingSpecificOperations();\n    offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if postindex then R[n] else offset_addr;\n    R[t] = ZeroExtend(MemU_unpriv[address,1],32);\n    if postindex then R[n] = offset_addr;"}, {"mnemonic": "POP (multiple registers)", "short_desc": "Pop Multiple Registers from Stack", "syntax": ["POP{<c>}{<q>} <registers>\t; A1", "POP{<c>}.W <registers>\t; T2", "POP{<c>}{<q>} <registers>\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<registers>\nFor encoding A1: is a list of two or more registers to be loaded, separated by commas and surrounded by { and }. The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register from the highest memory address. See also .", "<registers>\nFor encoding T2: is a list of two or more registers to be loaded, separated by commas and surrounded by { and }. The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register from the highest memory address. See also ."]}, {"mnemonic": "VHADD", "short_desc": "Vector Halving Add", "full_desc": "Vector Halving Add adds corresponding elements in two vectors of integers, shifts each result right one bit, and places the final results in the destination vector. The results of the halving operations are truncated. For rounded results, see ).", "syntax": ["VHADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VHADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VHADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VHADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '11' then UNDEFINED;\nadd = (op == '0');  unsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Int(Elem[D[n+r],e,esize], unsigned);\n            op2 = Int(Elem[D[m+r],e,esize], unsigned);\n            result = if add then op1+op2 else op1-op2;\n            Elem[D[d+r],e,esize] = result<esize:1>;"}, {"mnemonic": "VFNMA", "short_desc": "Vector Fused Negate Multiply Accumulate", "full_desc": "Vector Fused Negate Multiply Accumulate negates one floating-point register value and multiplies it by another floating-point register value, adds the negation of the floating-point value in the destination register to the product, and writes the result back to the destination register. The instruction does not round the result of the multiply before the addition.", "syntax": ["VFNMA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VFNMA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VFNMA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VFNMA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VFNMA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VFNMA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\nif size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nop1_neg = (op == '1');\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\n    case esize of\n        when 16\n            op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;\n            S[d] = Zeros(16) : FPMulAdd(FPNeg(S[d]<15:0>), op16, S[m]<15:0>, FPSCR);\n        when 32\n            op32 = if op1_neg then FPNeg(S[n]) else S[n];\n            S[d] = FPMulAdd(FPNeg(S[d]), op32, S[m], FPSCR);\n        when 64\n            op64 = if op1_neg then FPNeg(D[n]) else D[n];\n            D[d] = FPMulAdd(FPNeg(D[d]), op64, D[m], FPSCR);"}, {"mnemonic": "VCMPE", "short_desc": "Vector Compare, raising Invalid Operation on NaN", "full_desc": "Vector Compare, raising Invalid Operation on NaN compares two floating-point registers, or one floating-point register and zero. It writes the result to the  flags. These are normally transferred to the .{N, Z, C, V} Condition flags by a subsequent  instruction.", "syntax": ["VCMPE{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCMPE{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCMPE{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VCMPE{<c>}{<q>}.F16 <Sd>, #0.0\t; Half-precision scalar", "VCMPE{<c>}{<q>}.F32 <Sd>, #0.0\t; Single-precision scalar", "VCMPE{<c>}{<q>}.F64 <Dd>, #0.0\t; Double-precision scalar", "VCMPE{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCMPE{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCMPE{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VCMPE{<c>}{<q>}.F16 <Sd>, #0.0\t; Half-precision scalar", "VCMPE{<c>}{<q>}.F32 <Sd>, #0.0\t; Single-precision scalar", "VCMPE{<c>}{<q>}.F64 <Dd>, #0.0\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nquiet_nan_exc = (E == '1');  with_zero = FALSE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    bits(4) nzcv;\n    case esize of\n        when 16\n            bits(16) op16 = if with_zero then FPZero('0') else S[m]<15:0>;\n            nzcv = FPCompare(S[d]<15:0>, op16, quiet_nan_exc, FPSCR);\n        when 32\n            bits(32) op32 = if with_zero then FPZero('0') else S[m];\n            nzcv = FPCompare(S[d], op32, quiet_nan_exc, FPSCR);\n        when 64\n            bits(64) op64 = if with_zero then FPZero('0') else D[m];\n            nzcv = FPCompare(D[d], op64, quiet_nan_exc, FPSCR);\n\n    FPSCR.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VUZP", "short_desc": "Vector Unzip", "full_desc": "Vector Unzip de-interleaves the elements of two vectors.", "syntax": ["VUZP{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VUZP{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VUZP{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VUZP{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' || (Q == '0' && size == '10') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nquadword_operation = (Q == '1');  esize = 8 << UInt(size);\nd = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    if quadword_operation then\n        if d == m then\n            Q[d>>1] = bits(128) UNKNOWN;  Q[m>>1] = bits(128) UNKNOWN;\n        else\n            zipped_q = Q[m>>1]:Q[d>>1];\n            for e = 0 to (128 DIV esize) - 1\n                Elem[Q[d>>1],e,esize] = Elem[zipped_q,2*e,esize];\n                Elem[Q[m>>1],e,esize] = Elem[zipped_q,2*e+1,esize];\n    else\n        if d == m then\n            D[d] = bits(64) UNKNOWN;  D[m] = bits(64) UNKNOWN;\n        else\n            zipped_d = D[m]:D[d];\n            for e = 0 to (64 DIV esize) - 1\n                Elem[D[d],e,esize] = Elem[zipped_d,2*e,esize];\n                Elem[D[m],e,esize] = Elem[zipped_d,2*e+1,esize];"}, {"mnemonic": "IT", "short_desc": "If-Then", "full_desc": "If-Then makes up to four following instructions (the IT block) conditional. The conditions for the instructions in the IT block are the same as, or the inverse of, the condition the  instruction specifies for the first instruction in the block.", "syntax": ["IT{<x>{<y>{<z>}}}{<q>} <cond>\t; T1"], "symbols": ["<x>\nThe condition for the second instruction in the IT block. If omitted, the \"mask\" field is set to . If present it is encoded in the \"mask[3]\" field:", "<y>\nThe condition for the third instruction in the IT block. If omitted and  is present, the \"mask[2:0]\" field is set to . If  is present it is encoded in the \"mask[2]\" field:", "<z>\nThe condition for the fourth instruction in the IT block. If omitted and  is present, the \"mask[1:0]\" field is set to . If  is present, the \"mask[0]\" field is set to 1, and it is encoded in the \"mask[1]\" field:", "<q>\nSee .", "<cond>\nThe condition for the first instruction in the IT block, encoded in the \"firstcond\" field. See  for the range of conditions available, and the encodings."], "decode": "if mask == '0000' then SEE \"Related encodings\";\nif firstcond == '1111' || (firstcond == '1110' && BitCount(mask) != 1) then UNPREDICTABLE;\nif InITBlock() then UNPREDICTABLE;", "operation": "EncodingSpecificOperations();\nAArch32.CheckITEnabled(mask);\nPSTATE.IT<7:0> = firstcond:mask;\nShouldAdvanceIT = FALSE;"}, {"mnemonic": "SMLAD, SMLADX", "short_desc": "Signed Multiply Accumulate Dual", "full_desc": "Signed Multiply Accumulate Dual performs two signed 16 x 16-bit multiplications. It adds the products to a 32-bit accumulate operand.", "syntax": ["SMLAD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLAD", "SMLADX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLADX", "SMLAD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLAD", "SMLADX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLADX"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<Ra>\nIs the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "if Ra == '1111' then SEE \"SMUAD\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);\nm_swap = (M == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand2 = if m_swap then ROR(R[m],16) else R[m];\n    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);\n    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);\n    result = product1 + product2 + SInt(R[a]);\n    R[d] = result<31:0>;\n    if result != SInt(result<31:0>) then  // Signed overflow\n        PSTATE.Q = '1';"}, {"mnemonic": "LDAB", "short_desc": "Load-Acquire Byte", "full_desc": "Load-Acquire Byte loads a byte from memory, zero-extends it to form a 32-bit word and writes it to a register. The instruction also has memory ordering semantics as described in .", "syntax": ["LDAB{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "LDAB{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt); n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    R[t] = ZeroExtend(MemO[address, 1], 32);"}, {"mnemonic": "LDRD (register)", "short_desc": "Load Register Dual (register)", "full_desc": "Load Register Dual (register) calculates an address from a base register value and a register offset, loads two words from memory, and writes them to two registers. It can use offset, post-indexed, or pre-indexed addressing. For information about memory accesses see .", "syntax": ["LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]\t; Offset", "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], {+/-}<Rm>\t; Post-indexed", "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the first general-purpose register to be transferred, encoded in the \"Rt\" field. This register must be even-numbered and not R14.", "<Rt2>\nIs the second general-purpose register to be transferred. This register must be .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant.", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field."], "decode": "if Rt<0> == '1' then UNPREDICTABLE;\nt = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif P == '0' && W == '1' then UNPREDICTABLE;\nif t2 == 15 || m == 15 || m == t || m == t2 then UNPREDICTABLE;\nif wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);\n    address = if index then offset_addr else R[n];\n    if address == Align(address, 8) then\n        data = MemA[address,8];\n        if BigEndian() then\n            R[t] = data<63:32>;\n            R[t2] = data<31:0>;\n        else\n            R[t] = data<31:0>;\n            R[t2] = data<63:32>;\n    else\n        R[t] = MemA[address,4];\n        R[t2] = MemA[address+4,4];\n\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "VEXT (byte elements)", "short_desc": "Vector Extract", "full_desc": "Vector Extract extracts elements from the bottom end of the second operand vector and the top end of the first, concatenates them and places the result in the destination vector.", "syntax": ["VEXT{<c>}{<q>}.8 {<Dd>,} <Dn>, <Dm>, #<imm>\t; 64-bit SIMD vector", "VEXT{<c>}{<q>}.8 {<Qd>,} <Qn>, <Qm>, #<imm>\t; 128-bit SIMD vector", "VEXT{<c>}{<q>}.8 {<Dd>,} <Dn>, <Dm>, #<imm>\t; 64-bit SIMD vector", "VEXT{<c>}{<q>}.8 {<Qd>,} <Qn>, <Qm>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nFor the 64-bit SIMD vector variant: is the location of the extracted result in the concatenation of the operands, as a number of bytes from the least significant end, in the range 0 to 7, encoded in the \"imm4\" field.", "<imm>\nFor the 128-bit SIMD vector variant: is the location of the extracted result in the concatenation of the operands, as a number of bytes from the least significant end, in the range 0 to 15, encoded in the \"imm4\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif Q == '0' && imm4<3> == '1' then UNDEFINED;\nquadword_operation = (Q == '1');  position = 8 * UInt(imm4);\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    if quadword_operation then\n        Q[d>>1] = (Q[m>>1]:Q[n>>1])<position+127:position>;\n    else\n        D[d] = (D[m]:D[n])<position+63:position>;"}, {"mnemonic": "VLD4 (single 4-element structure to all lanes)", "short_desc": "Load single 4-element structure and replicate to all lanes of four registers", "full_desc": "Load single 4-element structure and replicate to all lanes of four registers loads one 4-element structure from memory into all lanes of four registers. For details of the addressing mode see .", "syntax": ["VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}],<Rm>\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of four SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' && a == '0' then UNDEFINED;\nif size == '11' then\n    ebytes = 4;  alignment = 16;\nelse\n    ebytes = 1 << UInt(size);\n    if size == '10' then\n        alignment = if a == '0' then 1 else 8;\n    else\n        alignment = if a == '0' then 1 else 4*ebytes;\ninc = if T == '0' then 1 else 2;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d4 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    D[d] = Replicate(MemU[address,ebytes]);\n    D[d2] = Replicate(MemU[address+ebytes,ebytes]);\n    D[d3] = Replicate(MemU[address+2*ebytes,ebytes]);\n    D[d4] = Replicate(MemU[address+3*ebytes,ebytes]);\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 4*ebytes;"}, {"mnemonic": "RSC, RSCS (register-shifted register)", "short_desc": "Reverse Subtract (register-shifted register)", "full_desc": "Reverse Subtract (register-shifted register) subtracts a register value and the value of NOT (Carry flag) from a register-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.", "syntax": ["RSCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "RSC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);\n    R[d] = result;\n    if setflags then\n        PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VST4 (single 4-element structure from one lane)", "short_desc": "Store single 4-element structure from one lane of four registers", "full_desc": "Store single 4-element structure from one lane of four registers stores one 4-element structure to memory from corresponding elements of four registers. For details of the addressing mode see .", "syntax": ["VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; ", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Reg-offset", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2 and A3: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the four SIMD&FP registers holding the element.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then UNDEFINED;\nif size != '00' then SEE \"Related encodings\";\nebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;\nalignment = if index_align<0> == '0' then 1 else 4;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d4 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = TRUE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    MemU[address,         ebytes] = Elem[D[d], index];\n    MemU[address+ebytes,  ebytes] = Elem[D[d2],index];\n    MemU[address+2*ebytes,ebytes] = Elem[D[d3],index];\n    MemU[address+3*ebytes,ebytes] = Elem[D[d4],index];\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 4*ebytes;"}, {"mnemonic": "VSUBW", "short_desc": "Vector Subtract Wide", "full_desc": "Vector Subtract Wide subtracts the elements of a doubleword vector from the corresponding elements of a quadword vector, and places the results in another quadword vector. Before subtracting, it sign-extends or zero-extends the elements of the doubleword operand.", "syntax": ["VSUBW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>\t; A1", "VSUBW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        if is_vsubw then\n            op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);\n        else\n            op1 = Int(Elem[Din[n],e,esize], unsigned);\n        result = op1 - Int(Elem[Din[m],e,esize], unsigned);\n        Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;"}, {"mnemonic": "B", "short_desc": "Branch", "full_desc": "Branch causes a branch to a target address.", "syntax": ["B{<c>}{<q>} <label>\t; A1", "B<c>{<q>} <label>\t; T1", "B{<c>}{<q>} <label>\t; T2", "B<c>.W <label>\t; T3", "B<c>{<q>} <label>\t; T3", "B{<c>}.W <label>\t; T4", "B{<c>}{<q>} <label>\t; T4"], "symbols": ["<c>\nFor encoding A1, T2 and T4: see .", "<c>\nFor encoding T1: see . Must not be  or omitted.", "<c>\nFor encoding T3: see .  must not be  or omitted.", "<q>\nSee .", "<label>\nFor encoding A1: the label of the instruction that is to be branched to. The assembler calculates the required value of the offset from the PC value of the  instruction to this label, then selects an encoding that sets  to that offset.", "<label>\nFor encoding T1: the label of the instruction that is to be branched to. The assembler calculates the required value of the offset from the PC value of the  instruction to this label, then selects an encoding that sets  to that offset. Permitted offsets are even numbers in the range \u2013256 to 254.", "<label>\nFor encoding T2: the label of the instruction that is to be branched to. The assembler calculates the required value of the offset from the PC value of the  instruction to this label, then selects an encoding that sets  to that offset. Permitted offsets are even numbers in the range \u20132048 to 2046.", "<label>\nFor encoding T3: the label of the instruction that is to be branched to. The assembler calculates the required value of the offset from the PC value of the  instruction to this label, then selects an encoding that sets  to that offset.", "<label>\nFor encoding T4: the label of the instruction that is to be branched to. The assembler calculates the required value of the offset from the PC value of the  instruction to this label, then selects an encoding that sets  to that offset."], "decode": "imm32 = SignExtend(imm24:'00', 32);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    BranchWritePC(PC + imm32, BranchType_DIR);"}, {"mnemonic": "SMUSD, SMUSDX", "short_desc": "Signed Multiply Subtract Dual", "full_desc": "Signed Multiply Subtract Dual performs two signed 16 x 16-bit multiplications. It subtracts one of the products from the other, and writes the result to the destination register.", "syntax": ["SMUSD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMUSD", "SMUSDX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMUSDX", "SMUSD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMUSD", "SMUSDX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMUSDX"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand2 = if m_swap then ROR(R[m],16) else R[m];\n    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);\n    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);\n    result = product1 - product2;\n    R[d] = result<31:0>;\n    // Signed overflow cannot occur"}, {"mnemonic": "VSUB (floating-point)", "short_desc": "Vector Subtract (floating-point)", "full_desc": "Vector Subtract (floating-point) subtracts the elements of one vector from the corresponding elements of another vector, and places the results in the destination vector.", "syntax": ["VSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VSUB{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VSUB{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VSUB{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar", "VSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VSUB{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>\t; Half-precision scalar", "VSUB{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>\t; Single-precision scalar", "VSUB{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nadvsimd = TRUE;\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if advsimd then  // Advanced SIMD instruction\n        for r = 0 to regs-1\n            for e = 0 to elements-1\n                Elem[D[d+r],e,esize] = FPSub(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());\n    else             // VFP instruction\n        case esize of\n            when 16\n                S[d] = Zeros(16) : FPSub(S[n]<15:0>, S[m]<15:0>, FPSCR);\n            when 32\n                S[d] = FPSub(S[n], S[m], FPSCR);\n            when 64\n                D[d] = FPSub(D[n], D[m], FPSCR);"}, {"mnemonic": "ADD, ADDS (SP plus immediate)", "short_desc": "Add to SP (immediate)", "full_desc": "Add to SP (immediate) adds an immediate value to the SP value, and writes the result to the destination register.", "syntax": ["ADD{<c>}{<q>} {<Rd>,} SP, #<const>\t; ADD", "ADDS{<c>}{<q>} {<Rd>,} SP, #<const>\t; ADDS", "ADD{<c>}{<q>} <Rd>, SP, #<imm8>\t; T1", "ADD{<c>}{<q>} {SP,} SP, #<imm7>\t; T2", "ADD{<c>}.W {<Rd>,} SP, #<const>\t; ADD", "ADD{<c>}{<q>} {<Rd>,} SP, #<const>\t; ADD", "ADDS{<c>}{<q>} {<Rd>,} SP, #<const>\t; ADDS", "ADD{<c>}{<q>} {<Rd>,} SP, #<imm12>\t; T4", "ADDW{<c>}{<q>} {<Rd>,} SP, #<imm12>\t; T4"], "symbols": ["<c>\nSee .", "<q>\nSee .", "SP,\nIs the stack pointer.", "<imm7>\nIs the unsigned immediate, a multiple of 4, in the range 0 to 508, encoded in the \"imm7\" field as <imm7>/4.", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the SP. Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rd>\nFor encoding T3 and T4: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the SP.", "<imm8>\nIs an unsigned immediate, a multiple of 4, in the range 0 to 1020, encoded in the \"imm8\" field as <imm8>/4.", "<imm12>\nIs a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T3: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result, nzcv) = AddWithCarry(SP, imm32, '0');\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "SBFX", "short_desc": "Signed Bit Field Extract", "full_desc": "Signed Bit Field Extract extracts any number of adjacent bits at any position from a register, sign-extends them to 32 bits, and writes the result to the destination register.", "syntax": ["SBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>\t; A1", "SBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field.", "<lsb>\nFor encoding A1: is the bit number of the least significant bit in the field, in the range 0 to 31, encoded in the \"lsb\" field.", "<lsb>\nFor encoding T1: is the bit number of the least significant bit in the field, in the range 0 to 31, encoded in the \"imm3:imm2\" field.", "<width>\nIs the width of the field, in the range 1 to 32-<lsb>, encoded in the \"widthm1\" field as <width>-1."], "decode": "d = UInt(Rd);  n = UInt(Rn);\nlsbit = UInt(lsb);  widthminus1 = UInt(widthm1);\nif d == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    msbit = lsbit + widthminus1;\n    if msbit <= 31 then\n        R[d] = SignExtend(R[n]<msbit:lsbit>, 32);\n    else\n        UNPREDICTABLE;"}, {"mnemonic": "STM (User registers)", "short_desc": "Store Multiple (User registers)", "full_desc": "In an EL1 mode other than System mode, Store Multiple (User registers) stores multiple User mode registers to consecutive memory locations using an address from a base register. The PE reads the base register value normally, using the current mode to determine the correct Banked version of the register. This instruction cannot writeback to the base register.", "syntax": ["STM{<amode>}{<c>}{<q>} <Rn>, <registers>^\t; A1"], "symbols": ["<amode>\nis one of:", "<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<registers>\nIs a list of one or more registers, separated by commas and surrounded by { and }. It specifies the set of registers to be stored by the  instruction. The registers are stored with the lowest-numbered register to the lowest memory address, through to the highest-numbered register to the highest memory address. See also ."], "decode": "n = UInt(Rn);  registers = register_list;  increment = (U == '1');  wordhigher = (P == U);\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if PSTATE.EL == EL2 then\n        UNDEFINED;\n    elsif PSTATE.M IN {M32_User,M32_System} then\n        UNPREDICTABLE;\n    else\n        length = 4*BitCount(registers);\n        address = if increment then R[n] else R[n]-length;\n        if wordhigher then address = address+4;\n        for i = 0 to 14\n            if registers<i> == '1' then  // Store User mode register\n                MemA[address,4] = Rmode[i, M32_User];\n                address = address + 4;\n        if registers<15> == '1' then\n            MemA[address,4] = PCStoreValue();"}, {"mnemonic": "VCVT (between floating-point and integer, Advanced SIMD)", "short_desc": "Vector Convert between floating-point and integer", "full_desc": "Vector Convert between floating-point and integer converts each element in a vector from floating-point to integer, or from integer to floating-point, and places the results in a second vector.", "syntax": ["VCVT{<c>}{<q>}.<dt1>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVT{<c>}{<q>}.<dt1>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector", "VCVT{<c>}{<q>}.<dt1>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVT{<c>}{<q>}.<dt1>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt1>\n", "<dt2>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\nto_integer = (op<1> == '1');  unsigned = (op<0> == '1');\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    bits(esize) result;\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[m+r],e,esize];\n            if to_integer then\n                result = FPToFixed(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_ZERO);\n            else\n                result = FixedToFP(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_TIEEVEN);\n            Elem[D[d+r],e,esize] = result;"}, {"mnemonic": "VLD2 (single 2-element structure to one lane)", "short_desc": "Load single 2-element structure to one lane of two registers", "full_desc": "Load single 2-element structure to one lane of two registers loads one 2-element structure from memory into corresponding elements of two registers. Elements of the registers that are not loaded are unchanged. For details of the addressing mode see .", "syntax": ["VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2 and A3: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the two SIMD&FP registers holding the element.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then SEE \"VLD2 (single 2-element structure to all lanes)\";\nebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;\nalignment = if index_align<0> == '0' then 1 else 2;\nd = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d2 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    Elem[D[d], index] = MemU[address,ebytes];\n    Elem[D[d2],index] = MemU[address+ebytes,ebytes];\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 2*ebytes;"}, {"mnemonic": "VFMAL (by scalar)", "short_desc": "Vector Floating-point Multiply-Add Long to accumulator (by scalar)", "full_desc": "Vector Floating-point Multiply-Add Long to accumulator (by scalar). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation.", "syntax": ["VFMAL{<q>}.F16 <Dd>, <Sn>, <Sm>[<index>]\t; 64-bit SIMD vector", "VFMAL{<q>}.F16 <Qd>, <Dn>, <Dm>[<index>]\t; 128-bit SIMD vector", "VFMAL{<q>}.F16 <Dd>, <Sn>, <Sm>[<index>]\t; 64-bit SIMD vector", "VFMAL{<q>}.F16 <Qd>, <Dn>, <Dm>[<index>]\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm<2:0>\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm<2:0>:M\" field.", "<index>\nFor the 64-bit SIMD vector variant: is the element index in the range 0 to 1, encoded in the \"Vm<3>\" field.", "<index>\nFor the 128-bit SIMD vector variant: is the element index in the range 0 to 3, encoded in the \"M:Vm<3>\" field."], "decode": "if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;\nif Q == '1' && Vd<0> == '1' then UNDEFINED;\n\ninteger d = UInt(D:Vd);\ninteger n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);\ninteger m = if Q == '1' then UInt(Vm<2:0>) else UInt(Vm<2:0>:M);\n\ninteger index = if Q == '1' then UInt(M:Vm<3>) else UInt(Vm<3>);\ninteger esize = 32;\ninteger regs = if Q=='1' then 2 else 1;\ninteger datasize = if Q=='1' then 64 else 32;\nboolean sub_op = S=='1';", "operation": "CheckAdvSIMDEnabled();\nbits(datasize) operand1 ;\nbits(datasize) operand2 ;\nbits(64) operand3;\nbits(64) result;\nbits(esize DIV 2) element1;\nbits(esize DIV 2) element2;\n\nif Q=='0' then\n    operand1 = S[n]<datasize-1:0>;\n    operand2 = S[m]<datasize-1:0>;\nelse\n    operand1 = D[n]<datasize-1:0>;\n    operand2 = D[m]<datasize-1:0>;\nelement2 = Elem[operand2, index, esize DIV 2];\nfor r = 0 to regs-1\n    operand3 = D[d+r];\n    for e = 0 to 1\n        element1 = Elem[operand1, 2*r+e, esize DIV 2];\n        if sub_op then element1 = FPNeg(element1);\n        Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());\n    D[d+r] = result;"}, {"mnemonic": "LDRSH (register)", "short_desc": "Load Register Signed Halfword (register)", "full_desc": "Load Register Signed Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. The offset register value can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see .", "syntax": ["LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]\t; Offset", "LDRSH{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>\t; Post-indexed", "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!\t; Pre-indexed", "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]\t; T1", "LDRSH{<c>}.W <Rt>, [<Rn>, {+}<Rm>]\t; T2", "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant.", "<Rn>\nFor encoding T1 and T2: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<imm>\nIf present, the size of the left shift to apply to the value from , in the range 1-3.  is encoded in imm2. If absent, no shift is specified and imm2 is encoded as ."], "decode": "if P == '0' && W == '1' then SEE \"LDRSHT\";\nt = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\n(shift_t, shift_n) = (SRType_LSL, 0);\nif t == 15 || m == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if index then offset_addr else R[n];\n    data = MemU[address,2];\n    if wback then R[n] = offset_addr;\n    R[t] = SignExtend(data, 32);"}, {"mnemonic": "SBC, SBCS (immediate)", "short_desc": "Subtract with Carry (immediate)", "full_desc": "Subtract with Carry (immediate) subtracts an immediate value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register.", "syntax": ["SBC{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; SBC", "SBCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; SBCS", "SBC{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; SBC", "SBCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; SBCS"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (result, nzcv) = AddWithCarry(R[n], NOT(imm32), PSTATE.C);\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "SUB, SUBS (register)", "short_desc": "Subtract (register)", "full_desc": "Subtract (register) subtracts an optionally-shifted register value from a register value, and writes the result to the destination register.", "syntax": ["SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; SUB, rotate right with extend", "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; SUB, shift or rotate by value", "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; SUBS, rotate right with extend", "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; SUBS, shift or rotate by value", "SUB<c>{<q>} <Rd>, <Rn>, <Rm>\t; T1", "SUBS{<q>} {<Rd>,} <Rn>, <Rm>\t; T1", "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; SUB, rotate right with extend", "SUB<c>.W {<Rd>,} <Rn>, <Rm>\t; SUB, shift or rotate by value", "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; SUB, shift or rotate by value", "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; SUBS, rotate right with extend", "SUBS.W {<Rd>,} <Rn>, <Rm>\t; SUBS, shift or rotate by value", "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; SUBS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1 and T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated. If the SP is used, see .", "<Rn>\nFor encoding T1: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rn>\nFor encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field. If the SP is used, see .", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "if Rn == '1101' then SEE \"SUB (SP minus register)\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "SMMLS, SMMLSR", "short_desc": "Signed Most Significant Word Multiply Subtract", "full_desc": "Signed Most Significant Word Multiply Subtract multiplies two signed 32-bit values, subtracts the result from a 32-bit accumulate value that is shifted left by 32 bits, and extracts the most significant 32 bits of the result of that subtraction.", "syntax": ["SMMLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMMLS", "SMMLSR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMMLSR", "SMMLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMMLS", "SMMLSR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMMLSR"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');\nif d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = (SInt(R[a]) << 32) - SInt(R[n]) * SInt(R[m]);\n    if round then result = result + 0x80000000;\n    R[d] = result<63:32>;"}, {"mnemonic": "UHADD16", "short_desc": "Unsigned Halving Add 16", "full_desc": "Unsigned Halving Add 16 performs two unsigned 16-bit integer additions, halves the results, and writes the results to the destination register.", "syntax": ["UHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);\n    sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);\n    R[d]<15:0>  = sum1<16:1>;\n    R[d]<31:16> = sum2<16:1>;"}, {"mnemonic": "VSHL (register)", "short_desc": "Vector Shift Left (register)", "full_desc": "Vector Shift Left (register) takes each element in a vector, shifts them by a value from the least significant byte of the corresponding element of a second vector, and places the results in the destination vector. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift.", "syntax": ["VSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>\t; 64-bit SIMD vector", "VSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>\t; 128-bit SIMD vector", "VSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>\t; 64-bit SIMD vector", "VSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            shift = SInt(Elem[D[n+r],e,esize]<7:0>);\n            result = Int(Elem[D[m+r],e,esize], unsigned) << shift;\n            Elem[D[d+r],e,esize] = result<esize-1:0>;"}, {"mnemonic": "PKHBT, PKHTB", "short_desc": "Pack Halfword", "full_desc": "Pack Halfword combines one halfword of its first operand with the other halfword of its shifted second operand.", "syntax": ["PKHBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, LSL #<imm>}\t; PKHBT", "PKHTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ASR #<imm>}\t; PKHTB", "PKHBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, LSL #<imm>}\t; PKHBT", "PKHTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ASR #<imm>}\t; PKHTB"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<imm>\nFor encoding A1: the shift to apply to the value read from , encoded in the \"imm5\" field.", "<imm>\nFor encoding T1: the shift to apply to the value read from , encoded in the \"imm3:imm2\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  tbform = (tb == '1');\n(shift_t, shift_n) = DecodeImmShift(tb:'0', imm5);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand2 = Shift(R[m], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored\n    R[d]<15:0>  = if tbform then operand2<15:0> else R[n]<15:0>;\n    R[d]<31:16> = if tbform then R[n]<31:16>    else operand2<31:16>;"}, {"mnemonic": "CMN (register)", "short_desc": "Compare Negative (register)", "full_desc": "Compare Negative (register) adds a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN{<c>}{<q>} <Rn>, <Rm>, RRX\t; Rotate right with extend", "CMN{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}\t; Shift or rotate by value", "CMN{<c>}{<q>} <Rn>, <Rm>\t; T1", "CMN{<c>}{<q>} <Rn>, <Rm>, RRX\t; Rotate right with extend", "CMN{<c>}.W <Rn>, <Rm>\t; Shift or rotate by value", "CMN{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}\t; Shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1 and T2: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "n = UInt(Rn);  m = UInt(Rm);\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], shifted, '0');\n    PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VSHLL", "short_desc": "Vector Shift Left Long", "full_desc": "Vector Shift Left Long takes each element in a doubleword vector, left shifts them by an immediate value, and places the results in a quadword vector.", "syntax": ["VSHLL{<c>}{<q>}.<type><size> <Qd>, <Dm>, #<imm>\t; A1", "VSHLL{<c>}{<q>}.<type><size> <Qd>, <Dm>, #<imm>\t; A2", "VSHLL{<c>}{<q>}.<type><size> <Qd>, <Dm>, #<imm>\t; T1", "VSHLL{<c>}{<q>}.<type><size> <Qd>, <Dm>, #<imm>\t; T2"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<type>\nThe data type for the elements of the operand. It must be one of:", "<size>\nThe data size for the elements of the operand. The following table shows the permitted values and their encodings:", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nThe immediate value.  must lie in the range 1 to , and:"], "decode": "if imm6 == '000xxx' then SEE \"Related encodings\";\nif Vd<0> == '1' then UNDEFINED;\ncase imm6 of\n    when '001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;\n    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;\n    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;\nif shift_amount == 0 then SEE \"VMOVL\";\nunsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        result = Int(Elem[Din[m],e,esize], unsigned) << shift_amount;\n        Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;"}, {"mnemonic": "BLX (register)", "short_desc": "Branch with Link and Exchange (register)", "full_desc": "Branch with Link and Exchange (register) calls a subroutine at an address specified in the register, and if necessary changes to the instruction set indicated by bit[0] of the register value. If the value in bit[0] is 0, the instruction set after the branch will be A32. If the value in bit[0] is 1, the instruction set after the branch will be T32.", "syntax": ["BLX{<c>}{<q>} <Rm>\t; A1", "BLX{<c>}{<q>} <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rm>\nIs the general-purpose register holding the address to be branched to, encoded in the \"Rm\" field."], "decode": "m = UInt(Rm);\nif m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    target = R[m];\n    if CurrentInstrSet() == InstrSet_A32 then\n        next_instr_addr = PC - 4;\n        LR = next_instr_addr;\n    else\n        next_instr_addr = PC - 2;\n        LR = next_instr_addr<31:1> : '1';\n    BXWritePC(target, BranchType_INDCALL);"}, {"mnemonic": "REV", "short_desc": "Byte-Reverse Word", "full_desc": "Byte-Reverse Word reverses the byte order in a 32-bit register.", "syntax": ["REV{<c>}{<q>} <Rd>, <Rm>\t; A1", "REV{<c>}{<q>} <Rd>, <Rm>\t; T1", "REV{<c>}.W <Rd>, <Rm>\t; T2", "REV{<c>}{<q>} <Rd>, <Rm>\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1 and T1: is the general-purpose source register, encoded in the \"Rm\" field.", "<Rm>\nFor encoding T2: is the general-purpose source register, encoded in the \"Rm\" field. It must be encoded with an identical value in the \"Rn\" field."], "decode": "d = UInt(Rd);  m = UInt(Rm);\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    bits(32) result;\n    result<31:24> = R[m]<7:0>;\n    result<23:16> = R[m]<15:8>;\n    result<15:8>  = R[m]<23:16>;\n    result<7:0>   = R[m]<31:24>;\n    R[d] = result;"}, {"mnemonic": "VCVTB (BFloat16)", "short_desc": "Converts from a single-precision value to a BFloat16 value in the bottom half of a single-precision register", "full_desc": "Converts the single-precision value in a single-precision register to BFloat16 format and writes the result into the bottom half of a single precision register, preserving the top 16 bits of the destination register.", "syntax": ["VCVTB{<c>}{<q>}.BF16.F32 <Sd>, <Sm>\t; A1", "VCVTB{<c>}{<q>}.BF16.F32 <Sd>, <Sm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if !HaveAArch32BF16Ext() then UNDEFINED;\ninteger d = UInt(Vd:D);\ninteger m = UInt(Vm:M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    CheckVFPEnabled(TRUE);\n\n    S[d]<15:0> = FPConvertBF(S[m], FPSCR);"}, {"mnemonic": "SXTAB16", "short_desc": "Signed Extend and Add Byte 16", "full_desc": "Signed Extend and Add Byte 16 extracts two 8-bit values from a register, sign-extends them to 16 bits each, adds the results to two 16-bit values from another register, and writes the final results to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit values.", "syntax": ["SXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; A1", "SXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "if Rn == '1111' then SEE \"SXTB16\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d]<15:0>  = R[n]<15:0> + SignExtend(rotated<7:0>, 16);\n    R[d]<31:16> = R[n]<31:16> + SignExtend(rotated<23:16>, 16);"}, {"mnemonic": "VMIN (integer)", "short_desc": "Vector Minimum (integer)", "full_desc": "Vector Minimum compares corresponding elements in two vectors, and copies the smaller of each pair into the corresponding element in the destination vector.", "syntax": ["VMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMIN{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMIN{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '11' then UNDEFINED;\nmaximum = (op == '0');  unsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Int(Elem[D[n+r],e,esize], unsigned);\n            op2 = Int(Elem[D[m+r],e,esize], unsigned);\n            result = if maximum then Max(op1,op2) else Min(op1,op2);\n            Elem[D[d+r],e,esize] = result<esize-1:0>;"}, {"mnemonic": "LDM (exception return)", "short_desc": "Load Multiple (exception return)", "full_desc": "Load Multiple (exception return) loads multiple registers from consecutive memory locations using an address from a base register. The  of the current mode is copied to the . An address adjusted by the size of the data loaded can optionally be written back to the base register.", "syntax": ["LDM{<amode>}{<c>}{<q>} <Rn>{!}, <registers_with_pc>^\t; A1"], "symbols": ["<amode>\nis one of:", "<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "<registers_with_pc>\nIs a list of one or more registers, separated by commas and surrounded by { and }. It specifies the set of registers to be loaded. The registers are loaded with the lowest-numbered register from the lowest memory address, through to the highest-numbered register from the highest memory address. The PC must be specified in the register list, and the instruction causes a branch to the address (data) loaded into the PC. See also ."], "decode": "n = UInt(Rn);  registers = register_list;\nwback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);\nif n == 15 then UNPREDICTABLE;\nif wback && registers<n> == '1' then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if PSTATE.EL == EL2 then\n        UNDEFINED;\n    elsif PSTATE.M IN {M32_User,M32_System} then\n        UNPREDICTABLE;                        // UNDEFINED or NOP\n    else\n        length = 4*BitCount(registers) + 4;\n        address = if increment then R[n] else R[n]-length;\n        if wordhigher then address = address+4;\n\n        for i = 0 to 14\n            if registers<i> == '1' then\n                R[i] = MemA[address,4];  address = address + 4;\n        new_pc_value = MemA[address,4];\n\n        if wback && registers<n> == '0' then R[n] = if increment then R[n]+length else R[n]-length;\n        if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;\n\n        AArch32.ExceptionReturn(new_pc_value, SPSR[]);"}, {"mnemonic": "VAND (register)", "short_desc": "Vector Bitwise AND (register)", "full_desc": "Vector Bitwise AND (register) performs a bitwise AND operation between two registers, and places the result in the destination register.", "syntax": ["VAND{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VAND{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VAND{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VAND{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        D[d+r] = D[n+r] AND D[m+r];"}, {"mnemonic": "SETEND", "short_desc": "Set Endianness", "full_desc": "Set Endianness writes a new value to .E.", "syntax": ["SETEND{<q>} <endian_specifier>\t; A1", "SETEND{<q>} <endian_specifier>\t; T1"], "symbols": ["<q>\nSee .", "<endian_specifier>\n"], "decode": "set_bigend = (E == '1');", "operation": "EncodingSpecificOperations();\nAArch32.CheckSETENDEnabled();\nPSTATE.E = if set_bigend then '1' else '0';"}, {"mnemonic": "MOV, MOVS (immediate)", "short_desc": "Move (immediate)", "full_desc": "Move (immediate) writes an immediate value to the destination register.", "syntax": ["MOV{<c>}{<q>} <Rd>, #<const>\t; MOV", "MOVS{<c>}{<q>} <Rd>, #<const>\t; MOVS", "MOV{<c>}{<q>} <Rd>, #<imm16>\t; A2", "MOVW{<c>}{<q>} <Rd>, #<imm16>\t; A2", "MOV<c>{<q>} <Rd>, #<imm8>\t; T1", "MOVS{<q>} <Rd>, #<imm8>\t; T1", "MOV<c>.W <Rd>, #<const>\t; MOV", "MOV{<c>}{<q>} <Rd>, #<const>\t; MOV", "MOVS.W <Rd>, #<const>\t; MOVS", "MOVS{<c>}{<q>} <Rd>, #<const>\t; MOVS", "MOV{<c>}{<q>} <Rd>, #<imm16>\t; T3", "MOVW{<c>}{<q>} <Rd>, #<imm16>\t; T3"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding A2, T1, T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<imm8>\nIs a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.", "<imm16>\nFor encoding A2: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm4:imm12\" field.", "<imm16>\nFor encoding T3: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm4:i:imm3:imm8\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T2: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  setflags = (S == '1');  (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = imm32;\n    if d == 15 then          // Can only occur for encoding A1\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "VRSHL", "short_desc": "Vector Rounding Shift Left", "full_desc": "Vector Rounding Shift Left takes each element in a vector, shifts them by a value from the least significant byte of the corresponding element of a second vector, and places the results in the destination vector. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift. For a truncating shift, see .", "syntax": ["VRSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>\t; 64-bit SIMD vector", "VRSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>\t; 128-bit SIMD vector", "VRSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>\t; 64-bit SIMD vector", "VRSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            shift = SInt(Elem[D[n+r],e,esize]<7:0>);\n            round_const = 1 << (-shift-1); // 0 for left shift, 2^(n-1) for right shift\n            result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) << shift;\n            Elem[D[d+r],e,esize] = result<esize-1:0>;"}, {"mnemonic": "UQADD8", "short_desc": "Unsigned Saturating Add 8", "full_desc": "Unsigned Saturating Add 8 performs four unsigned 8-bit integer additions, saturates the results to the 8-bit unsigned integer range 0 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["UQADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UQADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);\n    sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);\n    sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);\n    sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);\n    R[d]<7:0>   = UnsignedSat(sum1, 8);\n    R[d]<15:8>  = UnsignedSat(sum2, 8);\n    R[d]<23:16> = UnsignedSat(sum3, 8);\n    R[d]<31:24> = UnsignedSat(sum4, 8);"}, {"mnemonic": "VRADDHN", "short_desc": "Vector Rounding Add and Narrow, returning High Half", "full_desc": "Vector Rounding Add and Narrow, returning High Half adds corresponding elements in two quadword vectors, and places the most significant half of each result in a doubleword vector. The results are rounded.  For truncated results, see .", "syntax": ["VRADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>\t; A1", "VRADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    round_const = 1 << (esize-1);\n    for e = 0 to elements-1\n        result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize] + round_const;\n        Elem[D[d],e,esize] = result<2*esize-1:esize>;"}, {"mnemonic": "LDMDA, LDMFA", "short_desc": "Load Multiple Decrement After (Full Ascending)", "full_desc": "Load Multiple Decrement After (Full Ascending) loads multiple registers from consecutive memory locations using an address from a base register. The consecutive memory locations end at this address, and the address just below the lowest of those locations can optionally be written back to the base register.", "syntax": ["LDMDA{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "LDMFA{<c>}{<q>} <Rn>{!}, <registers>\t; A1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "<registers>\nIs a list of one or more registers to be loaded, separated by commas and surrounded by { and }."], "decode": "n = UInt(Rn);  registers = register_list;  wback = (W == '1');\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;\nif wback && registers<n> == '1' then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n] - 4*BitCount(registers) + 4;\n    for i = 0 to 14\n        if registers<i> == '1' then\n            R[i] = MemA[address,4];  address = address + 4;\n    if registers<15> == '1' then\n        LoadWritePC(MemA[address,4]);\n    if wback && registers<n> == '0' then R[n] = R[n] - 4*BitCount(registers);\n    if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;"}, {"mnemonic": "BIC, BICS (immediate)", "short_desc": "Bitwise Bit Clear (immediate)", "full_desc": "Bitwise Bit Clear (immediate) performs a bitwise AND of a register value and the complement of an immediate value, and writes the result to the destination register.", "syntax": ["BIC{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; BIC", "BICS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; BICS", "BIC{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; BIC", "BICS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; BICS"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');\n(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = R[n] AND NOT(imm32);\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "PLD, PLDW (immediate)", "short_desc": "Preload Data (immediate)", "full_desc": "Preload Data (immediate) signals the memory system that data memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into the data cache.", "syntax": ["PLD{<c>}{<q>} [<Rn> {, #{+/-}<imm>}]\t; Preload read", "PLDW{<c>}{<q>} [<Rn> {, #{+/-}<imm>}]\t; Preload write", "PLD{<c>}{<q>} [<Rn> {, #{+}<imm>}]\t; Preload read", "PLDW{<c>}{<q>} [<Rn> {, #{+}<imm>}]\t; Preload write", "PLD{<c>}{<q>} [<Rn> {, #-<imm>}]\t; Preload read", "PLDW{<c>}{<q>} [<Rn> {, #-<imm>}]\t; Preload write"], "symbols": ["<c>\nFor encoding A1: see . Must be  or omitted.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. If the PC is used, see .", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T2: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field."], "decode": "if Rn == '1111' then SEE \"PLD (literal)\";\nn = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');  is_pldw = (R == '0');", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = if add then (R[n] + imm32) else (R[n] - imm32);\n    if is_pldw then\n        Hint_PreloadDataForWrite(address);\n    else\n        Hint_PreloadData(address);"}, {"mnemonic": "VPMIN (integer)", "short_desc": "Vector Pairwise Minimum (integer)", "full_desc": "Vector Pairwise Minimum compares adjacent pairs of elements in two doubleword vectors, and copies the smaller of each pair into the corresponding element in the destination doubleword vector.", "syntax": ["VPMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; A1", "VPMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nmaximum = (op == '0');  unsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    bits(64) dest;\n    h = elements DIV 2;\n\n    for e = 0 to h-1\n        op1 = Int(Elem[D[n],2*e,esize], unsigned);\n        op2 = Int(Elem[D[n],2*e+1,esize], unsigned);\n        result = if maximum then Max(op1,op2) else Min(op1,op2);\n        Elem[dest,e,esize] = result<esize-1:0>;\n        op1 = Int(Elem[D[m],2*e,esize], unsigned);\n        op2 = Int(Elem[D[m],2*e+1,esize], unsigned);\n        result = if maximum then Max(op1,op2) else Min(op1,op2);\n        Elem[dest,e+h,esize] = result<esize-1:0>;\n\n    D[d] = dest;"}, {"mnemonic": "LSLS (register)", "short_desc": "Logical Shift Left, setting flags (register)", "syntax": ["LSLS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Flag setting", "LSLS{<q>} {<Rdm>,} <Rdm>, <Rs>\t; Logical shift left", "LSLS.W {<Rd>,} <Rm>, <Rs>\t; Flag setting", "LSLS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>\t; Flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdm>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the first general-purpose source register, encoded in the \"Rm\" field.", "<Rs>\nIs the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."]}, {"mnemonic": "EOR, EORS (immediate)", "short_desc": "Bitwise Exclusive OR (immediate)", "full_desc": "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register value and an immediate value, and writes the result to the destination register.", "syntax": ["EOR{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; EOR", "EORS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; EORS", "EOR{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; EOR", "EORS{<c>}{<q>} {<Rd>,} <Rn>, #<const>\t; EORS"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.", "<const>\nFor encoding A1: an immediate value. See  for the range of values.", "<const>\nFor encoding T1: an immediate value. See  for the range of values."], "decode": "d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');\n(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = R[n] EOR imm32;\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "UQSUB16", "short_desc": "Unsigned Saturating Subtract 16", "full_desc": "Unsigned Saturating Subtract 16 performs two unsigned 16-bit integer subtractions, saturates the results to the 16-bit unsigned integer range 0 <= x <= 2 - 1, and writes the results to the destination register.", "syntax": ["UQSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UQSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);\n    diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);\n    R[d]<15:0>  = UnsignedSat(diff1, 16);\n    R[d]<31:16> = UnsignedSat(diff2, 16);"}, {"mnemonic": "SMULBB, SMULBT, SMULTB, SMULTT", "short_desc": "Signed Multiply (halfwords)", "full_desc": "Signed Multiply (halfwords) multiplies two signed 16-bit quantities, taken from either the bottom or the top half of their respective source registers. The other halves of these source registers are ignored. The 32-bit product is written to the destination register. No overflow is possible during this instruction.", "syntax": ["SMULBB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULBB", "SMULBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULBT", "SMULTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULTB", "SMULTT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULTT", "SMULBB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULBB", "SMULBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULBT", "SMULTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULTB", "SMULTT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULTT"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand in the bottom or top half (selected by ), encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier in the bottom or top half (selected by ), encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nn_high = (N == '1');  m_high = (M == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;\n    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;\n    result = SInt(operand1) * SInt(operand2);\n    R[d] = result<31:0>;\n    // Signed overflow cannot occur"}, {"mnemonic": "STMIB, STMFA", "short_desc": "Store Multiple Increment Before (Full Ascending)", "full_desc": "Store Multiple Increment Before (Full Ascending) stores multiple registers to consecutive memory locations using an address from a base register. The consecutive memory locations start just above this address, and the address of the last of those locations can optionally be written back to the base register.", "syntax": ["STMIB{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "STMFA{<c>}{<q>} <Rn>{!}, <registers>\t; A1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "<registers>\nIs a list of one or more registers to be stored, separated by commas and surrounded by { and }."], "decode": "n = UInt(Rn);  registers = register_list;  wback = (W == '1');\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n] + 4;\n    for i = 0 to 14\n        if registers<i> == '1' then\n            if i == n && wback && i != LowestSetBit(registers) then\n                MemA[address,4] = bits(32) UNKNOWN;\n            else\n                MemA[address,4] = R[i];\n            address = address + 4;\n    if registers<15> == '1' then\n        MemA[address,4] = PCStoreValue();\n    if wback then R[n] = R[n] + 4*BitCount(registers);"}, {"mnemonic": "VQSHL (register)", "short_desc": "Vector Saturating Shift Left (register)", "full_desc": "Vector Saturating Shift Left (register) takes each element in a vector, shifts them by a value from the least significant byte of the corresponding element of a second vector, and places the results in the destination vector. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift.", "syntax": ["VQSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>\t; 64-bit SIMD vector", "VQSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>\t; 128-bit SIMD vector", "VQSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>\t; 64-bit SIMD vector", "VQSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            shift = SInt(Elem[D[n+r],e,esize]<7:0>);\n            operand = Int(Elem[D[m+r],e,esize], unsigned);\n            (result,sat) = SatQ(operand << shift, esize, unsigned);\n            Elem[D[d+r],e,esize] = result;\n            if sat then FPSCR.QC = '1';"}, {"mnemonic": "STR (register)", "short_desc": "Store Register (register)", "full_desc": "Store Register (register) calculates an address from a base register value and an offset register value, stores a word from a register to memory. The offset register value can optionally be shifted. For information about memory accesses see .", "syntax": ["STR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]\t; Offset", "STR{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}\t; Post-indexed", "STR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!\t; Pre-indexed", "STR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]\t; T1", "STR{<c>}.W <Rt>, [<Rn>, {+}<Rm>]\t; T2", "STR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, but this is deprecated.", "<Rt>\nFor encoding T1 and T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant, but this is deprecated.", "<Rn>\nFor encoding T1 and T2: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\nThe shift to apply to the value read from . If absent, no shift is applied. Otherwise, see .", "<imm>\nIf present, the size of the left shift to apply to the value from , in the range 1-3.  is encoded in imm2. If absent, no shift is specified and imm2 is encoded as ."], "decode": "if P == '0' && W == '1' then SEE \"STRT\";\nt = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);\nif m == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if index then offset_addr else R[n];\n    if t == 15 then  // Only possible for encoding A1\n        data = PCStoreValue();\n    else\n        data = R[t];\n    MemU[address,4] = data;\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "STLEXB", "short_desc": "Store-Release Exclusive Byte", "full_desc": "Store-Release Exclusive Byte stores a byte from a register to memory if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.", "syntax": ["STLEXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; A1", "STLEXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the destination general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rd\" field. The value returned is:", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);\nif d == 15 || t == 15 || n == 15 then UNPREDICTABLE;\nif d == n || d == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    if AArch32.ExclusiveMonitorsPass(address,1) then\n        MemO[address, 1] = R[t]<7:0>;\n        R[d] = ZeroExtend('0');\n    else\n        R[d] = ZeroExtend('1');"}, {"mnemonic": "STLB", "short_desc": "Store-Release Byte", "full_desc": "Store-Release Byte stores a byte from a register to memory.  The instruction also has memory ordering semantics as described in .", "syntax": ["STLB{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "STLB{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt); n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    MemO[address, 1] = R[t]<7:0>;"}, {"mnemonic": "SHA256H", "short_desc": "SHA256 hash update part 1", "full_desc": "SHA256 hash update part 1.", "syntax": ["SHA256H.32 <Qd>, <Qn>, <Qm>\t; A1", "SHA256H.32 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA256Ext() then UNDEFINED;\nif Q != '1' then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    X = Q[d>>1]; Y = Q[n>>1]; W = Q[m>>1]; part1 = TRUE;\n    Q[d>>1] = SHA256hash(X, Y, W, part1);"}, {"mnemonic": "VCVTM (floating-point)", "short_desc": "Convert floating-point to integer with Round towards -Infinity", "full_desc": "Convert floating-point to integer with Round towards -Infinity converts a value in a register from floating-point to a 32-bit integer using the Round towards -Infinity rounding mode, and places the result in a second register.", "syntax": ["VCVTM{<q>}.<dt>.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTM{<q>}.<dt>.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTM{<q>}.<dt>.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVTM{<q>}.<dt>.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTM{<q>}.<dt>.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTM{<q>}.<dt>.F64 <Sd>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<dt>\n", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nrounding = FPDecodeRM(RM);  unsigned = (op == '0');\nd = UInt(Vd:D);\ncase size of\n    when '01' esize = 16; m = UInt(Vm:M);\n    when '10' esize = 32; m = UInt(Vm:M);\n    when '11' esize = 64; m = UInt(M:Vm);", "operation": "EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\ncase esize of\n    when 16\n        S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);\n    when 32\n        S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);\n    when 64\n        S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);"}, {"mnemonic": "CMN (register-shifted register)", "short_desc": "Compare Negative (register-shifted register)", "full_desc": "Compare Negative (register-shifted register) adds a register value and a register-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["CMN{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>\t; A1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<type>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nshift_t = DecodeRegShift(stype);\nif n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], shifted, '0');\n    PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VST4 (single 4-element structure from one lane)", "short_desc": "Store single 4-element structure from one lane of four registers", "full_desc": "Store single 4-element structure from one lane of four registers stores one 4-element structure to memory from corresponding elements of four registers. For details of the addressing mode see .", "syntax": ["VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; A3"], "symbols": ["<c>\nSee . This encoding must be unconditional.", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the four SIMD&FP registers holding the element.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment."], "decode": "if size == '11' then UNDEFINED;\nif size != '10' then SEE \"Related encodings\";\nif index_align<1:0> == '11' then UNDEFINED;\nebytes = 4;  index = UInt(index_align<3>);\ninc = if index_align<2> == '0' then 1 else 2;\nalignment = if index_align<1:0> == '00' then 1 else 4 << UInt(index_align<1:0>);\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d4 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = TRUE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    MemU[address,         ebytes] = Elem[D[d], index];\n    MemU[address+ebytes,  ebytes] = Elem[D[d2],index];\n    MemU[address+2*ebytes,ebytes] = Elem[D[d3],index];\n    MemU[address+3*ebytes,ebytes] = Elem[D[d4],index];\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 4*ebytes;"}, {"mnemonic": "SSUB16", "short_desc": "Signed Subtract 16", "full_desc": "Signed Subtract 16 performs two 16-bit signed integer subtractions, and writes the results to the destination register. It sets .GE according to the results of the subtractions.", "syntax": ["SSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);\n    diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);\n    R[d]<15:0>  = diff1<15:0>;\n    R[d]<31:16> = diff2<15:0>;\n    PSTATE.GE<1:0> = if diff1 >= 0 then '11' else '00';\n    PSTATE.GE<3:2> = if diff2 >= 0 then '11' else '00';"}, {"mnemonic": "VCMP", "short_desc": "Vector Compare", "full_desc": "Vector Compare compares two floating-point registers, or one floating-point register and zero. It writes the result to the  flags. These are normally transferred to the .{N, Z, C, V} Condition flags by a subsequent  instruction.", "syntax": ["VCMP{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCMP{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCMP{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VCMP{<c>}{<q>}.F16 <Sd>, #0.0\t; Half-precision scalar", "VCMP{<c>}{<q>}.F32 <Sd>, #0.0\t; Single-precision scalar", "VCMP{<c>}{<q>}.F64 <Dd>, #0.0\t; Double-precision scalar", "VCMP{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCMP{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCMP{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VCMP{<c>}{<q>}.F16 <Sd>, #0.0\t; Half-precision scalar", "VCMP{<c>}{<q>}.F32 <Sd>, #0.0\t; Single-precision scalar", "VCMP{<c>}{<q>}.F64 <Dd>, #0.0\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nquiet_nan_exc = (E == '1');  with_zero = FALSE;\ncase size of\n    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);\n    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    bits(4) nzcv;\n    case esize of\n        when 16\n            bits(16) op16 = if with_zero then FPZero('0') else S[m]<15:0>;\n            nzcv = FPCompare(S[d]<15:0>, op16, quiet_nan_exc, FPSCR);\n        when 32\n            bits(32) op32 = if with_zero then FPZero('0') else S[m];\n            nzcv = FPCompare(S[d], op32, quiet_nan_exc, FPSCR);\n        when 64\n            bits(64) op64 = if with_zero then FPZero('0') else D[m];\n            nzcv = FPCompare(D[d], op64, quiet_nan_exc, FPSCR);\n\n    FPSCR.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VAND (immediate)", "short_desc": "Vector Bitwise AND (immediate)", "syntax": ["VAND{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VAND{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VAND{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VAND{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VAND{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VAND{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VAND{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VAND{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<imm>\nIs a constant of the specified type that is replicated to fill the destination register. For details of the range of constants available and the encoding of , see ."]}, {"mnemonic": "VRECPS", "short_desc": "Vector Reciprocal Step", "full_desc": "Vector Reciprocal Step multiplies the elements of one vector by the corresponding elements of another vector, subtracts each of the products from 2.0, and places the results into the elements of the destination vector.", "syntax": ["VRECPS{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VRECPS{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VRECPS{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VRECPS{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = FPRecipStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);"}, {"mnemonic": "VCGT (register)", "short_desc": "Vector Compare Greater Than", "full_desc": "Vector Compare Greater Than takes each element in a vector, and compares it with the corresponding element of a second vector. If the first is greater than the second, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VCGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VCGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif size == '11' then UNDEFINED;\nvtype = if U == '1' then VCGTtype_unsigned else VCGTtype_signed;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "enumeration VCGTtype {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp};\n\nif ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];\n            case vtype of\n                when VCGTtype_signed    test_passed = (SInt(op1) > SInt(op2));\n                when VCGTtype_unsigned  test_passed = (UInt(op1) > UInt(op2));\n                when VCGTtype_fp        test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "VMOV (between general-purpose register and half-precision)", "short_desc": "Copy 16 bits of a general-purpose register to or from a 32-bit SIMD&FP register", "full_desc": "Copy 16 bits of a general-purpose register to or from a 32-bit SIMD&FP register.  This instruction transfers the value held in the bottom 16 bits of a 32-bit SIMD&FP register to the bottom 16 bits of a general-purpose register, or the value held in the bottom 16 bits of a general-purpose register to the bottom 16 bits of a 32-bit SIMD&FP register.", "syntax": ["VMOV{<c>}{<q>}.F16 <Sn>, <Rt>\t; From general-purpose register", "VMOV{<c>}{<q>}.F16 <Rt>, <Sn>\t; To general-purpose register", "VMOV{<c>}{<q>}.F16 <Sn>, <Rt>\t; From general-purpose register", "VMOV{<c>}{<q>}.F16 <Rt>, <Sn>\t; To general-purpose register"], "symbols": ["<Rt>\nIs the general-purpose register that  will be transferred to or from, encoded in the \"Rt\" field.", "<Sn>\nIs the 32-bit name of the SIMD&FP register to be transferred, encoded in the \"Vn:N\" field.", "<c>\nSee .", "<q>\nSee ."], "decode": "if !HaveFP16Ext() then UNDEFINED;\nif cond != '1110' then UNPREDICTABLE;\nto_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);\nif t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    if to_arm_register then\n        R[t] = Zeros(16) : S[n]<15:0>;\n    else\n        S[n] = Zeros(16) : R[t]<15:0>;"}, {"mnemonic": "SSUB8", "short_desc": "Signed Subtract 8", "full_desc": "Signed Subtract 8 performs four 8-bit signed integer subtractions, and writes the results to the destination register. It sets .GE according to the results of the subtractions.", "syntax": ["SSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);\n    diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);\n    diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);\n    diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);\n    R[d]<7:0>   = diff1<7:0>;\n    R[d]<15:8>  = diff2<7:0>;\n    R[d]<23:16> = diff3<7:0>;\n    R[d]<31:24> = diff4<7:0>;\n    PSTATE.GE<0>  = if diff1 >= 0 then '1' else '0';\n    PSTATE.GE<1>  = if diff2 >= 0 then '1' else '0';\n    PSTATE.GE<2>  = if diff3 >= 0 then '1' else '0';\n    PSTATE.GE<3>  = if diff4 >= 0 then '1' else '0';"}, {"mnemonic": "VMOV (register, SIMD)", "short_desc": "Copy between SIMD registers", "syntax": ["VMOV{<c>}{<q>}{.<dt>} <Dd>, <Dm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}{.<dt>} <Qd>, <Qm>\t; 128-bit SIMD vector", "VMOV{<c>}{<q>}{.<dt>} <Dd>, <Dm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}{.<dt>} <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type.  must not be , but it is otherwise ignored.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"N:Vn\" and \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"N:Vn\" and \"M:Vm\" field."]}, {"mnemonic": "NOP", "short_desc": "No Operation", "full_desc": "No Operation does nothing. This instruction can be used for instruction alignment purposes.", "syntax": ["NOP{<c>}{<q>}\t; A1", "NOP{<c>}{<q>}\t; T1", "NOP{<c>}.W\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    // Do nothing"}, {"mnemonic": "AND, ANDS (register)", "short_desc": "Bitwise AND (register)", "full_desc": "Bitwise AND (register) performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; AND, rotate right with extend", "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; AND, shift or rotate by value", "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ANDS, rotate right with extend", "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ANDS, shift or rotate by value", "AND<c>{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "ANDS{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; AND, rotate right with extend", "AND<c>.W {<Rd>,} <Rn>, <Rm>\t; AND, shift or rotate by value", "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; AND, shift or rotate by value", "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ANDS, rotate right with extend", "ANDS.W {<Rd>,} <Rn>, <Rm>\t; ANDS, shift or rotate by value", "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ANDS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdn>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] AND shifted;\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "VMOV (immediate)", "short_desc": "Copy immediate value to a SIMD&FP register", "full_desc": "Copy immediate value to a SIMD&FP register places an immediate constant into every element of the destination register.", "syntax": ["VMOV{<c>}{<q>}.I32 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}.I32 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMOV{<c>}{<q>}.F16 <Sd>, #<imm>\t; Half-precision scalar", "VMOV{<c>}{<q>}.F32 <Sd>, #<imm>\t; Single-precision scalar", "VMOV{<c>}{<q>}.F64 <Dd>, #<imm>\t; Double-precision scalar", "VMOV{<c>}{<q>}.I16 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}.I16 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMOV{<c>}{<q>}.<dt> <Dd>, #<imm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}.<dt> <Qd>, #<imm>\t; 128-bit SIMD vector", "VMOV{<c>}{<q>}.I64 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}.I64 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMOV{<c>}{<q>}.I32 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}.I32 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMOV{<c>}{<q>}.F16 <Sd>, #<imm>\t; Half-precision scalar", "VMOV{<c>}{<q>}.F32 <Sd>, #<imm>\t; Single-precision scalar", "VMOV{<c>}{<q>}.F64 <Dd>, #<imm>\t; Double-precision scalar", "VMOV{<c>}{<q>}.I16 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}.I16 <Qd>, #<imm>\t; 128-bit SIMD vector", "VMOV{<c>}{<q>}.<dt> <Dd>, #<imm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}.<dt> <Qd>, #<imm>\t; 128-bit SIMD vector", "VMOV{<c>}{<q>}.I64 <Dd>, #<imm>\t; 64-bit SIMD vector", "VMOV{<c>}{<q>}.I64 <Qd>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1, A3, A4 and A5: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1, T2, T3, T4 and T5: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<imm>\nFor encoding A1, A3, A4, A5, T1, T3, T4 and T5: is a constant of the specified type that is replicated to fill the destination register. For details of the range of constants available and the encoding of , see .", "<imm>\nFor encoding A2 and T2: is a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded in \"imm4H:imm4L\". For details of the range of constants available and the encoding of , see ."], "decode": "if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE \"VORR (immediate)\";\nif op == '1' && cmode != '1110' then SEE \"Related encodings\";\nif Q == '1' && Vd<0> == '1' then UNDEFINED;\nsingle_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);\nd = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if single_register then\n        S[d] = imm32;\n    else\n        for r = 0 to regs-1\n            D[d+r] = imm64;"}, {"mnemonic": "UASX", "short_desc": "Unsigned Add and Subtract with Exchange", "full_desc": "Unsigned Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one unsigned 16-bit integer addition and one unsigned 16-bit subtraction, and writes the results to the destination register. It sets .GE according to the results.", "syntax": ["UASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);\n    sum  = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);\n    R[d]<15:0>  = diff<15:0>;\n    R[d]<31:16> = sum<15:0>;\n    PSTATE.GE<1:0> = if diff >= 0 then '11' else '00';\n    PSTATE.GE<3:2> = if sum  >= 0x10000 then '11' else '00';"}, {"mnemonic": "USAT", "short_desc": "Unsigned Saturate", "full_desc": "Unsigned Saturate saturates an optionally-shifted signed value to a selected unsigned range.", "syntax": ["USAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>\t; Arithmetic shift right", "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}\t; Logical shift left", "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>\t; Arithmetic shift right", "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}\t; Logical shift left"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<imm>\nIs the bit position for saturation, in the range 0 to 31, encoded in the \"sat_imm\" field.", "<Rn>\nIs the general-purpose source register, encoded in the \"Rn\" field.", "<amount>\nFor encoding A1: is the optional shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm5\" field.", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 32 encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T1: is the optional shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm3:imm2\" field.", "<amount>\nFor encoding T1: is the shift amount, in the range 1 to 31 encoded in the \"imm3:imm2\" field as <amount>."], "decode": "d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);\n(shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);\nif d == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand = Shift(R[n], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored\n    (result, sat) = UnsignedSatQ(SInt(operand), saturate_to);\n    R[d] = ZeroExtend(result, 32);\n    if sat then\n        PSTATE.Q = '1';"}, {"mnemonic": "ESB", "short_desc": "Error Synchronization Barrier", "full_desc": "Error Synchronization Barrier is an error synchronization event that might also update DISR and VDISR. This instruction can be used at all Exception levels and in Debug state.", "syntax": ["ESB{<c>}{<q>}\t; A1", "ESB{<c>}.W\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee ."], "decode": "if !HaveRASExt() then EndOfInstruction();  // Instruction executes as NOP\nif cond != '1110' then UNPREDICTABLE;      // ESB must be encoded with AL condition", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n\n    SynchronizeErrors();\n    AArch32.ESBOperation();\n    if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch32.vESBOperation();\n    TakeUnmaskedSErrorInterrupts();"}, {"mnemonic": "STRHT", "short_desc": "Store Register Halfword Unprivileged", "full_desc": "Store Register Halfword Unprivileged stores a halfword from a register to memory. For information about memory accesses see .", "syntax": ["STRHT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}\t; A1", "STRHT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>\t; A2", "STRHT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 and encoded in the \"imm8\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');\nregister_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);\nif t == 15 || n == 15 || n == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode\n    EncodingSpecificOperations();\n    offset = if register_form then R[m] else imm32;\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if postindex then R[n] else offset_addr;\n    MemU_unpriv[address,2] = R[t]<15:0>;\n    if postindex then R[n] = offset_addr;"}, {"mnemonic": "VRECPE", "short_desc": "Vector Reciprocal Estimate", "full_desc": "Vector Reciprocal Estimate finds an approximate reciprocal of each element in the operand vector, and places the results in the destination vector.", "syntax": ["VRECPE{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRECPE{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VRECPE{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRECPE{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\nfloating_point = (F == '1');\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if floating_point then\n                Elem[D[d+r],e,esize] = FPRecipEstimate(Elem[D[m+r],e,esize], StandardFPSCRValue());\n            else\n                Elem[D[d+r],e,esize] = UnsignedRecipEstimate(Elem[D[m+r],e,esize]);"}, {"mnemonic": "VABD (floating-point)", "short_desc": "Vector Absolute Difference (floating-point)", "full_desc": "Vector Absolute Difference (floating-point) subtracts the elements of one vector from the corresponding elements of another vector, and places the absolute values of the results in the elements of the destination vector.", "syntax": ["VABD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VABD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VABD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VABD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];\n            Elem[D[d+r],e,esize] = FPAbs(FPSub(op1,op2,StandardFPSCRValue()));"}, {"mnemonic": "VQRSHRUN (zero)", "short_desc": "Vector Saturating Rounding Shift Right, Narrow", "syntax": ["VQRSHRUN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; Unsigned result", "VQRSHRUN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; Unsigned result"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."]}, {"mnemonic": "VORN (immediate)", "short_desc": "Vector Bitwise OR NOT (immediate)", "syntax": ["VORN{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VORN{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VORN{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VORN{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VORN{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VORN{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VORN{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VORN{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<imm>\nIs a constant of the specified type that is replicated to fill the destination register. For details of the range of constants available and the encoding of , see ."]}, {"mnemonic": "LDC (immediate)", "short_desc": "Load data to System register (immediate)", "full_desc": "Load data to System register (immediate) calculates an address from a base register value and an immediate offset, loads a word from memory, and writes it to the  System register. It can use offset, post-indexed, pre-indexed, or unindexed addressing. For information about memory accesses see .", "syntax": ["LDC{<c>}{<q>} p14, c5, [<Rn>{, #{+/-}<imm>}]\t; Offset", "LDC{<c>}{<q>} p14, c5, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDC{<c>}{<q>} p14, c5, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "LDC{<c>}{<q>} p14, c5, [<Rn>], <option>\t; Unindexed", "LDC{<c>}{<q>} p14, c5, [<Rn>{, #{+/-}<imm>}]\t; Offset", "LDC{<c>}{<q>} p14, c5, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDC{<c>}{<q>} p14, c5, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "LDC{<c>}{<q>} p14, c5, [<Rn>], <option>\t; Unindexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. If the PC is used, see .", "<option>\nIs an 8-bit immediate, in the range 0 to 255 enclosed in { }, encoded in the \"imm8\" field. The value of this field is ignored when executing this instruction.", "+/-\n", "<imm>\nIs the immediate offset used for forming the address, a multiple of 4 in the range 0-1020, defaulting to 0 and encoded in the \"imm8\" field, as <imm>/4."], "decode": "if Rn == '1111' then SEE \"LDC (literal)\";\nif P == '0' && U == '0' && W == '0' then UNDEFINED;\nn = UInt(Rn);  cp = 14;\nimm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n    address = if index then offset_addr else R[n];\n\n    // System register write to DBGDTRTXint.\n    DBGDTR_EL0[] = MemA[address,4];\n\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "VBIC (immediate)", "short_desc": "Vector Bitwise Bit Clear (immediate)", "full_desc": "Vector Bitwise Bit Clear (immediate) performs a bitwise AND between a register value and the complement of an immediate value, and returns the result into the destination vector.", "syntax": ["VBIC{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VBIC{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VBIC{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VBIC{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VBIC{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VBIC{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector", "VBIC{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>\t; 64-bit SIMD vector", "VBIC{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1 and A2: see . This encoding must be unconditional.", "<c>\nFor encoding T1 and T2: see .", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<imm>\nIs a constant of the specified type that is replicated to fill the destination register. For details of the range of constants available and the encoding of , see ."], "decode": "if cmode<0> == '0' || cmode<3:2> == '11' then SEE \"Related encodings\";\nif Q == '1' && Vd<0> == '1' then UNDEFINED;\nimm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);\nd = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        D[d+r] = D[d+r] AND NOT(imm64);"}, {"mnemonic": "VQRSHRN (zero)", "short_desc": "Vector Saturating Rounding Shift Right, Narrow", "syntax": ["VQRSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; Signed result", "VQRSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; Signed result"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."]}, {"mnemonic": "HVC", "short_desc": "Hypervisor Call", "full_desc": "Hypervisor Call causes a Hypervisor Call exception. For more information see .  Non-secure software executing at EL1 can use this instruction to call the hypervisor to request a service.", "syntax": ["HVC{<q>} {#}<imm16>\t; A1", "HVC{<q>} {#}<imm16>\t; T1"], "symbols": ["<q>\nSee . An  instruction must be unconditional.", "<imm16>\nFor encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm12:imm4\" field. This value is for assembly and disassembly only. It is reported in the HSR but otherwise is ignored by hardware. An HVC handler might interpret imm16, for example to determine the required service.", "<imm16>\nFor encoding T1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm4:imm12\" field. This value is for assembly and disassembly only. It is reported in the HSR but otherwise is ignored by hardware. An HVC handler might interpret imm16, for example to determine the required service."], "decode": "if cond != '1110' then UNPREDICTABLE;\nimm16 = imm12:imm4;", "operation": "EncodingSpecificOperations();\nif !HaveEL(EL2) || PSTATE.EL == EL0 || (IsSecure() && !IsSecureEL2Enabled()) then\n    UNDEFINED;\n\nif HaveEL(EL3) then\n    if ELUsingAArch32(EL3) && SCR.HCE == '0' && PSTATE.EL == EL2 then\n        UNPREDICTABLE;\n    else\n        hvc_enable = SCR_GEN[].HCE;\nelse\n    hvc_enable = if ELUsingAArch32(EL2) then NOT(HCR.HCD) else NOT(HCR_EL2.HCD);\n\nif hvc_enable == '0' then\n    UNDEFINED;\nelse\n    AArch32.CallHypervisor(imm16);"}, {"mnemonic": "SMLSD, SMLSDX", "short_desc": "Signed Multiply Subtract Dual", "full_desc": "Signed Multiply Subtract Dual performs two signed 16 x 16-bit multiplications. It adds the difference of the products to a 32-bit accumulate operand.", "syntax": ["SMLSD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLSD", "SMLSDX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLSDX", "SMLSD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLSD", "SMLSDX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLSDX"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<Ra>\nIs the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "if Ra == '1111' then SEE \"SMUSD\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_swap = (M == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand2 = if m_swap then ROR(R[m],16) else R[m];\n    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);\n    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);\n    result = product1 - product2 + SInt(R[a]);\n    R[d] = result<31:0>;\n    if result != SInt(result<31:0>) then  // Signed overflow\n        PSTATE.Q = '1';"}, {"mnemonic": "VJCVT", "short_desc": "Javascript Convert to signed fixed-point, rounding toward Zero", "full_desc": "Javascript Convert to signed fixed-point, rounding toward Zero. This instruction converts the double-precision floating-point value in the SIMD&FP source register to a 32-bit signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. If the result is too large to be accommodated as a signed 32-bit integer, then the result is the integer modulo 2, as held in a 32-bit signed integer.", "syntax": ["VJCVT{<q>}.S32.F64 <Sd>, <Dm>\t; A1", "VJCVT{<q>}.S32.F64 <Sd>, <Dm>\t; T1"], "symbols": ["<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if !HaveFJCVTZSExt() then UNDEFINED;\nif cond != '1110' then UNPREDICTABLE;\nd = UInt(Vd:D);  m = UInt(M:Vm);", "operation": "EncodingSpecificOperations();\nCheckVFPEnabled(TRUE);\nbits(64) fltval = D[m];\nbits(32) intval;\nbit      Z;\n(intval, Z) = FPToFixedJS(fltval, FPSCR, FALSE);\nFPSCR<31:28> = '0':Z:'00';\nS[d] = intval;"}, {"mnemonic": "LDRSB (literal)", "short_desc": "Load Register Signed Byte (literal)", "full_desc": "Load Register Signed Byte (literal) calculates an address from the PC value and an immediate offset, loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRSB{<c>}{<q>} <Rt>, <label>\t; A1", "LDRSB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; A1", "LDRSB{<c>}{<q>} <Rt>, <label>\t; T1", "LDRSB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<label>\nFor encoding A1: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Any value in the range -255 to 255 is permitted.", "<label>\nFor encoding T1: the label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Permitted values of the offset are -4095 to 4095.", "+/-\n", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "if P == '0' && W == '1' then SEE \"LDRSBT\";\nt = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);\nadd = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 || wback then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    base = Align(PC,4);\n    address = if add then (base + imm32) else (base - imm32);\n    R[t] = SignExtend(MemU[address,1], 32);"}, {"mnemonic": "SMULWB, SMULWT", "short_desc": "Signed Multiply (word by halfword)", "full_desc": "Signed Multiply (word by halfword) multiplies a signed 32-bit quantity and a signed 16-bit quantity. The signed 16-bit quantity is taken from either the bottom or the top half of its source register. The other half of the second source register is ignored. The top 32 bits of the 48-bit product are written to the destination register. The bottom 16 bits of the 48-bit product are ignored. No overflow is possible during this instruction.", "syntax": ["SMULWB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULWB", "SMULWT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULWT", "SMULWB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULWB", "SMULWT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; SMULWT"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier in the bottom or top half (selected by ), encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_high = (M == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;\n    product = SInt(R[n]) * SInt(operand2);\n    R[d] = product<47:16>;\n    // Signed overflow cannot occur"}, {"mnemonic": "SXTH", "short_desc": "Signed Extend Halfword", "full_desc": "Signed Extend Halfword extracts a 16-bit value from a register, sign-extends it to 32 bits, and writes the result to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.", "syntax": ["SXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; A1", "SXTH{<c>}{<q>} {<Rd>,} <Rm>\t; T1", "SXTH{<c>}.W {<Rd>,} <Rm>\t; T2", "SXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nIs the general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d] = SignExtend(rotated<15:0>, 32);"}, {"mnemonic": "UMLAL, UMLALS", "short_desc": "Unsigned Multiply Accumulate Long", "full_desc": "Unsigned Multiply Accumulate Long multiplies two unsigned 32-bit values to produce a 64-bit value, and accumulates this with a 64-bit value.", "syntax": ["UMLALS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; Flag setting", "UMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; Not flag setting", "UMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<RdLo>\nIs the general-purpose source register holding the lower 32 bits of the addend, and the destination register for the lower 32 bits of the result, encoded in the \"RdLo\" field.", "<RdHi>\nIs the general-purpose source register holding the upper 32 bits of the addend, and the destination register for the upper 32 bits of the result, encoded in the \"RdHi\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."], "decode": "dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\nif dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif dHi == dLo then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]:R[dLo]);\n    R[dHi] = result<63:32>;\n    R[dLo] = result<31:0>;\n    if setflags then\n        PSTATE.N = result<63>;\n        PSTATE.Z = IsZeroBit(result<63:0>);\n        // PSTATE.C, PSTATE.V unchanged"}, {"mnemonic": "MRRC", "short_desc": "Move to two general-purpose registers from System register", "full_desc": "Move to two general-purpose registers from System register. This instruction copies the value of a System register to two general-purpose registers.", "syntax": ["MRRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>\t; A1", "MRRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<coproc>\n", "<opc1>\nIs the opc1 parameter within the System register encoding space, in the range 0 to 15, encoded in the \"opc1\" field.", "<Rt>\nIs the first general-purpose register that is transferred into, encoded in the \"Rt\" field.", "<Rt2>\nIs the second general-purpose register that is transferred into, encoded in the \"Rt2\" field.", "<CRm>\nIs the CRm parameter within the System register encoding space, in the range c0 to c15, encoded in the \"CRm\" field."], "decode": "t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;\nif t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    value = AArch32.SysRegRead64(cp, ThisInstr());\n    R[t] = value<31:0>;\n    R[t2] = value<63:32>;"}, {"mnemonic": "LDMDB, LDMEA", "short_desc": "Load Multiple Decrement Before (Empty Ascending)", "full_desc": "Load Multiple Decrement Before (Empty Ascending) loads multiple registers from consecutive memory locations using an address from a base register. The consecutive memory locations end just below this address, and the address of the lowest of those locations can optionally be written back to the base register.", "syntax": ["LDMDB{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "LDMEA{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "LDMDB{<c>}{<q>} <Rn>{!}, <registers>\t; T1", "LDMEA{<c>}{<q>} <Rn>{!}, <registers>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "<registers>\nFor encoding A1: is a list of one or more registers to be loaded, separated by commas and surrounded by { and }.", "<registers>\nFor encoding T1: is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The registers in the list must be in the range R0-R12, encoded in the \"register_list\" field, and can optionally contain one of  the LR or the PC. If the LR is in the list, the \"M\" field is set to 1, otherwise it defaults to 0. If the PC is in the list, the \"P\" field is set to 1, otherwise it defaults to 0."], "decode": "n = UInt(Rn);  registers = register_list;  wback = (W == '1');\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;\nif wback && registers<n> == '1' then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n] - 4*BitCount(registers);\n    for i = 0 to 14\n        if registers<i> == '1' then\n            R[i] = MemA[address,4];  address = address + 4;\n    if registers<15> == '1' then\n        LoadWritePC(MemA[address,4]);\n    if wback && registers<n> == '0' then R[n] = R[n] - 4*BitCount(registers);\n    if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;"}, {"mnemonic": "SVC", "short_desc": "Supervisor Call", "full_desc": "Supervisor Call causes a Supervisor Call exception. For more information, see .", "syntax": ["SVC{<c>}{<q>} {#}<imm>\t; A1", "SVC{<c>}{<q>} {#}<imm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<imm>\nFor encoding A1: is a 24-bit unsigned immediate, in the range 0 to 16777215, encoded in the \"imm24\" field. This value is for assembly and disassembly only. SVC handlers in some systems interpret imm24 in software, for example to determine the required service.", "<imm>\nFor encoding T1: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field. This value is for assembly and disassembly only. SVC handlers in some systems interpret imm8 in software, for example to determine the required service."], "decode": "imm32 = ZeroExtend(imm24, 32);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    AArch32.CheckForSVCTrap(imm32<15:0>);\n    AArch32.CallSupervisor(imm32<15:0>);"}, {"mnemonic": "VRSRA", "short_desc": "Vector Rounding Shift Right and Accumulate", "full_desc": "Vector Rounding Shift Right and Accumulate takes each element in a vector, right shifts them by an immediate value, and accumulates the rounded results into the destination vector.For truncated results, see .", "syntax": ["VRSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VRSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector", "VRSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VRSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\n", "<size>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nIs an immediate value, in the range 1 to , encoded in the \"imm6\" field as  - ."], "decode": "if (L:imm6) == '0000xxx' then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\ncase L:imm6 of\n    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);\n    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);\n    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);\n    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);\nunsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    round_const = 1 << (shift_amount - 1);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;\n            Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;"}, {"mnemonic": "VQSHRN (zero)", "short_desc": "Vector Saturating Shift Right, Narrow", "syntax": ["VQSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; Signed result", "VQSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0\t; Signed result"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."]}, {"mnemonic": "VLD4 (single 4-element structure to one lane)", "short_desc": "Load single 4-element structure to one lane of four registers", "full_desc": "Load single 4-element structure to one lane of four registers loads one 4-element structure from memory into corresponding elements of four registers. Elements of the registers that are not loaded are unchanged. For details of the addressing mode see .", "syntax": ["VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2 and A3: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the four SIMD&FP registers holding the element.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then SEE \"VLD4 (single 4-element structure to all lanes)\";\nebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;\nalignment = if index_align<0> == '0' then 1 else 4;\nd = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d4 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    Elem[D[d], index] = MemU[address,ebytes];\n    Elem[D[d2],index] = MemU[address+ebytes,ebytes];\n    Elem[D[d3],index] = MemU[address+2*ebytes,ebytes];\n    Elem[D[d4],index] = MemU[address+3*ebytes,ebytes];\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 4*ebytes;"}, {"mnemonic": "VCLT (immediate #0)", "short_desc": "Vector Compare Less Than Zero", "full_desc": "Vector Compare Less Than Zero takes each element in a vector, and compares it with zero.  If it is less than zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VCLT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCLT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nfloating_point = (F == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if floating_point then\n                bits(esize) zero = FPZero('0');\n                test_passed = FPCompareGT(zero, Elem[D[m+r],e,esize], StandardFPSCRValue());\n            else\n                test_passed = (SInt(Elem[D[m+r],e,esize]) < 0);\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "UXTAB16", "short_desc": "Unsigned Extend and Add Byte 16", "full_desc": "Unsigned Extend and Add Byte 16 extracts two 8-bit values from a register, zero-extends them to 16 bits each, adds the results to two 16-bit values from another register, and writes the final results to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit values.", "syntax": ["UXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; A1", "UXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "if Rn == '1111' then SEE \"UXTB16\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d]<15:0>  = R[n]<15:0> + ZeroExtend(rotated<7:0>, 16);\n    R[d]<31:16> = R[n]<31:16> + ZeroExtend(rotated<23:16>, 16);"}, {"mnemonic": "PLD (literal)", "short_desc": "Preload Data (literal)", "full_desc": "Preload Data (literal) signals the memory system that data memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into the data cache.", "syntax": ["PLD{<c>}{<q>} <label>\t; A1", "PLD{<c>}{<q>} [PC, #{+/-}<imm>]\t; A1", "PLD{<c>}{<q>} <label>\t; T1", "PLD{<c>}{<q>} [PC, #{+/-}<imm>]\t; T1"], "symbols": ["<c>\nFor encoding A1: see . Must be  or omitted.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<label>\nThe label of the literal data item that is likely to be accessed in the near future. The assembler calculates the required value of the offset from the  value of the instruction to this label. The offset must be in the range \u20134095 to 4095.", "+/-\n", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the \"imm12\" field."], "decode": "imm32 = ZeroExtend(imm12, 32);  add = (U == '1');", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);\n    Hint_PreloadData(address);"}, {"mnemonic": "SMLAWB, SMLAWT", "short_desc": "Signed Multiply Accumulate (word by halfword)", "full_desc": "Signed Multiply Accumulate (word by halfword) performs a signed multiply accumulate operation. The multiply acts on a signed 32-bit quantity and a signed 16-bit quantity. The signed 16-bit quantity is taken from either the bottom or the top half of its source register. The other half of the second source register is ignored. The top 32 bits of the 48-bit product are added to a 32-bit accumulate value and the result is written to the destination register. The bottom 16 bits of the 48-bit product are ignored.", "syntax": ["SMLAWB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLAWB", "SMLAWT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLAWT", "SMLAWB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLAWB", "SMLAWT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLAWT"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier in the bottom or top half (selected by ), encoded in the \"Rm\" field.", "<Ra>\nIs the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_high = (M == '1');\nif d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;\n    result = SInt(R[n]) * SInt(operand2) + (SInt(R[a]) << 16);\n    R[d] = result<47:16>;\n    if (result >> 16) != SInt(R[d]) then  // Signed overflow\n        PSTATE.Q = '1';"}, {"mnemonic": "MVN, MVNS (register)", "short_desc": "Bitwise NOT (register)", "full_desc": "Bitwise NOT (register) writes the bitwise inverse of a register value to the destination register.", "syntax": ["MVN{<c>}{<q>} <Rd>, <Rm>, RRX\t; MVN, rotate right with extend", "MVN{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; MVN, shift or rotate by value", "MVNS{<c>}{<q>} <Rd>, <Rm>, RRX\t; MVNS, rotate right with extend", "MVNS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; MVNS, shift or rotate by value", "MVN<c>{<q>} <Rd>, <Rm>\t; T1", "MVNS{<q>} <Rd>, <Rm>\t; T1", "MVN{<c>}{<q>} <Rd>, <Rm>, RRX\t; MVN, rotate right with extend", "MVN<c>.W <Rd>, <Rm>\t; MVN, shift or rotate by value", "MVN{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; MVN, shift or rotate by value", "MVNS{<c>}{<q>} <Rd>, <Rm>, RRX\t; MVNS, rotate right with extend", "MVNS.W <Rd>, <Rm>\t; MVNS, shift or rotate by value", "MVNS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}\t; MVNS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T1 and T2: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = NOT(shifted);\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.N = result<31>;\n            PSTATE.Z = IsZeroBit(result);\n            PSTATE.C = carry;\n            // PSTATE.V unchanged"}, {"mnemonic": "SHADD16", "short_desc": "Signed Halving Add 16", "full_desc": "Signed Halving Add 16 performs two signed 16-bit integer additions, halves the results, and writes the results to the destination register.", "syntax": ["SHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);\n    sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);\n    R[d]<15:0>  = sum1<16:1>;\n    R[d]<31:16> = sum2<16:1>;"}, {"mnemonic": "VMLAL (by scalar)", "short_desc": "Vector Multiply Accumulate Long (by scalar)", "full_desc": "Vector Multiply Accumulate Long multiplies elements of a vector by a scalar, and adds the products to corresponding elements of the destination vector. The destination vector elements are twice as long as the elements that are multiplied.", "syntax": ["VMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>\t; A1", "VMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm[x]>\nIs the 64-bit name of the second SIMD&FP source register holding the scalar. If  is  or ,  is restricted to D0-D7.  is encoded in \"Vm<2:0>\", and  is encoded in \"M:Vm<3>\". If  is  or ,  is restricted to D0-D15.  is encoded in \"Vm\", and  is encoded in \"M\"."], "decode": "if size == '11' then SEE \"Related encodings\";\nif size == '00' || Vd<0> == '1' then UNDEFINED;\nunsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;\nd = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;\nif size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);\nif size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);\n            if floating_point then\n                fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));\n                Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());\n            else\n                addend = if add then op1val*op2val else -op1val*op2val;\n                if long_destination then\n                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;\n                else\n                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;"}, {"mnemonic": "VSMMLA", "short_desc": "Widening 8-bit signed integer matrix multiply-accumulate into 2x2 matrix", "full_desc": "The widening integer matrix multiply-accumulate instruction multiplies the 2x8 matrix of signed 8-bit integer values held in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator held in the destination vector. This is equivalent to performing an 8-way dot product per destination element.", "syntax": ["VSMMLA{<q>}.S8 <Qd>, <Qn>, <Qm>\t; A1", "VSMMLA{<q>}.S8 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP third source and destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveAArch32Int8MatMulExt() then UNDEFINED;\ncase B:U of\n    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;\n    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;\n    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;\n    when '11' UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(M:Vm);", "operation": "CheckAdvSIMDEnabled();\nbits(128) operand1 = Q[n>>1];\nbits(128) operand2 = Q[m>>1];\nbits(128) addend   = Q[d>>1];\n\nQ[d>>1] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);"}, {"mnemonic": "LDAEX", "short_desc": "Load-Acquire Exclusive Word", "full_desc": "Load-Acquire Exclusive Word loads a word from memory, writes it to a register and:", "syntax": ["LDAEX{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "LDAEX{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    AArch32.SetExclusiveMonitors(address, 4);\n    R[t] = MemO[address, 4];"}, {"mnemonic": "LDM (User registers)", "short_desc": "Load Multiple (User registers)", "full_desc": "In an EL1 mode other than System mode, Load Multiple (User registers) loads multiple User mode registers from consecutive memory locations using an address from a base register. The registers loaded cannot include the PC. The PE reads the base register value normally, using the current mode to determine the correct Banked version of the register. This instruction cannot writeback to the base register.", "syntax": ["LDM{<amode>}{<c>}{<q>} <Rn>, <registers_without_pc>^\t; A1"], "symbols": ["<amode>\nis one of:", "<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<registers_without_pc>\nIs a list of one or more registers, separated by commas and surrounded by { and }. It specifies the set of registers to be loaded by the  instruction. The registers are loaded with the lowest-numbered register from the lowest memory address, through to the highest-numbered register from the highest memory address. The PC must not be in the register list. See also ."], "decode": "n = UInt(Rn);  registers = register_list;  increment = (U == '1');  wordhigher = (P == U);\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if PSTATE.EL == EL2 then UNDEFINED;\n    elsif PSTATE.M IN {M32_User,M32_System} then UNPREDICTABLE;\n    else\n        length = 4*BitCount(registers);\n        address = if increment then R[n] else R[n]-length;\n        if wordhigher then address = address+4;\n        for i = 0 to 14\n            if registers<i> == '1' then  // Load User mode register\n                Rmode[i, M32_User] = MemA[address,4];  address = address + 4;"}, {"mnemonic": "VPOP", "short_desc": "Pop SIMD&FP registers from Stack", "syntax": ["VPOP{<c>}{<q>}{.<size>} <dreglist>\t; Increment After", "VPOP{<c>}{<q>}{.<size>} <sreglist>\t; Increment After", "VPOP{<c>}{<q>}{.<size>} <dreglist>\t; Increment After", "VPOP{<c>}{<q>}{.<size>} <sreglist>\t; Increment After"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<size>\nAn optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers being transferred.", "<sreglist>\nIs the list of consecutively numbered 32-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"Vd:D\", and \"imm8\" is set to the number of registers in the list. The list must contain at least one register.", "<dreglist>\nIs the list of consecutively numbered 64-bit SIMD&FP registers to be transferred. The first register in the list is encoded in \"D:Vd\", and \"imm8\" is set to twice the number of registers in the list. The list must contain at least one register, and must not contain more than 16 registers."]}, {"mnemonic": "ROR (immediate)", "short_desc": "Rotate Right (immediate)", "full_desc": "Rotate Right (immediate) provides the value of the contents of a register rotated by a constant value. The bits that are rotated off the right end are inserted into the vacated bit positions on the left.", "syntax": ["ROR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value", "ROR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>\t; MOV, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. Arm deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see .", "<Rd>\nFor encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T3: is the general-purpose source register, encoded in the \"Rm\" field.", "<imm>\nFor encoding A1: is the shift amount, in the range 1 to 31, encoded in the \"imm5\" field.", "<imm>\nFor encoding T3: is the shift amount, in the range 1 to 31, encoded in the \"imm3:imm2\" field."]}, {"mnemonic": "VSHR", "short_desc": "Vector Shift Right", "full_desc": "Vector Shift Right takes each element in a vector, right shifts them by an immediate value, and places the truncated results in the destination vector. For rounded results, see .", "syntax": ["VSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector", "VSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<type>\n", "<size>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nIs an immediate value, in the range 1 to , encoded in the \"imm6\" field as  - ."], "decode": "if (L:imm6) == '0000xxx' then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\ncase L:imm6 of\n    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);\n    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);\n    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);\n    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);\nunsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;\n            Elem[D[d+r],e,esize] = result<esize-1:0>;"}, {"mnemonic": "VST2 (single 2-element structure from one lane)", "short_desc": "Store single 2-element structure from one lane of two registers", "full_desc": "Store single 2-element structure from one lane of two registers stores one 2-element structure to memory from corresponding elements of two registers. For details of the addressing mode see .", "syntax": ["VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1, A2 and A3: see . This encoding must be unconditional.", "<c>\nFor encoding T1, T2 and T3: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of the two SIMD&FP registers holding the element.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then UNDEFINED;\nebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;\nalignment = if index_align<0> == '0' then 1 else 2;\nd = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d2 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = TRUE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    MemU[address,       ebytes] = Elem[D[d], index];\n    MemU[address+ebytes,ebytes] = Elem[D[d2],index];\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 2*ebytes;"}, {"mnemonic": "VSUDOT (by element)", "short_desc": "Dot Product index form with signed and unsigned integers (by element)", "full_desc": "Dot Product index form with signed and unsigned integers. This instruction performs the dot product of the four signed 8-bit integer values in each 32-bit element of the first source register with the four unsigned 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["VSUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VSUDOT{<q>}.U8 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector", "VSUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VSUDOT{<q>}.U8 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm\" field.", "<index>\nIs the element index in the range 0 to 1, encoded in the \"M\" field."], "decode": "if !HaveAArch32Int8MatMulExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;\nboolean op1_unsigned = (U == '0');\nboolean op2_unsigned = (U == '1');\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(Vm);\ninteger i = UInt(M);\ninteger regs = if Q == '1' then 2 else 1;", "operation": "CheckAdvSIMDEnabled();\nbits(64) operand1;\nbits(64) operand2;\nbits(64) result;\n\noperand2 = Din[m];\nfor r = 0 to regs-1\n    operand1 = Din[n+r];\n    result = Din[d+r];\n    for e = 0 to 1\n        bits(32) res = Elem[result, e, 32];\n        for b = 0 to 3\n            element1 = Int(Elem[operand1, 4 * e + b, 8], op1_unsigned);\n            element2 = Int(Elem[operand2, 4 * i + b, 8], op2_unsigned);\n            res = res + element1 * element2;\n        Elem[result, e, 32] = res;\n    D[d+r] = result;"}, {"mnemonic": "VUDOT (by element)", "short_desc": "Dot Product index form with unsigned integers.", "full_desc": "Dot Product index form with unsigned integers. This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.", "syntax": ["VUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VUDOT{<q>}.U8 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector", "VUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>[<index>]\t; 64-bit SIMD vector", "VUDOT{<q>}.U8 <Qd>, <Qn>, <Dm>[<index>]\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"Vm\" field.", "<index>\nIs the element index in the range 0 to 1, encoded in the \"M\" field."], "decode": "if !HaveDOTPExt() then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;\nboolean signed = (U=='0');\ninteger d = UInt(D:Vd);\ninteger n = UInt(N:Vn);\ninteger m = UInt(Vm<3:0>);\ninteger index = UInt(M);\ninteger esize = 32;\ninteger regs = if Q == '1' then 2 else 1;", "operation": "bits(64) operand1;\nbits(64) operand2 = D[m];\nbits(64) result;\nCheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    operand1 = D[n+r];\n    result = D[d+r];\n    integer element1, element2;\n    for e = 0 to 1\n        integer res = 0;\n        for i = 0 to 3\n            if signed then\n                element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n                element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n            else\n                element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);\n                element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n            res = res + element1 * element2;\n        Elem[result, e, esize] = Elem[result, e, esize] + res;\n    D[d+r] = result;"}, {"mnemonic": "VLD2 (single 2-element structure to all lanes)", "short_desc": "Load single 2-element structure and replicate to all lanes of two registers", "full_desc": "Load single 2-element structure and replicate to all lanes of two registers loads one 2-element structure from memory into all lanes of two registers. For details of the addressing mode see .", "syntax": ["VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}],<Rm>\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]\t; Offset", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!\t; Post-indexed", "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>\t; Post-indexed"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<list>\nIs a list containing the 64-bit names of two SIMD&FP registers.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "<align>\nIs the optional alignment.", "<Rm>\nIs the general-purpose index register containing an offset applied after the access, encoded in the \"Rm\" field."], "decode": "if size == '11' then UNDEFINED;\nebytes = 1 << UInt(size);\nalignment = if a == '0' then 1 else 2*ebytes;\ninc = if T == '0' then 1 else 2;\nd = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);\nwback = (m != 15);  register_index = (m != 15 && m != 13);\nif n == 15 || d2 > 31 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    address = R[n];  iswrite = FALSE;\n    - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);\n    D[d] = Replicate(MemU[address,ebytes]);\n    D[d2] = Replicate(MemU[address+ebytes,ebytes]);\n    if wback then\n        if register_index then\n            R[n] = R[n] + R[m];\n        else\n            R[n] = R[n] + 2*ebytes;"}, {"mnemonic": "VMLS (by scalar)", "short_desc": "Vector Multiply Subtract (by scalar)", "full_desc": "Vector Multiply Subtract multiplies elements of a vector by a scalar, and either subtracts the products from corresponding elements of the destination vector.", "syntax": ["VMLS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VMLS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>\t; 128-bit SIMD vector", "VMLS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>\t; 64-bit SIMD vector", "VMLS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP register holding the accumulate vector, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm[x]>\nIs the 64-bit name of the second SIMD&FP source register holding the scalar. If  is  or ,  is restricted to D0-D7.  is encoded in \"Vm<2:0>\", and  is encoded in \"M:Vm<3>\". If  is  or ,  is restricted to D0-D15.  is encoded in \"Vm\", and  is encoded in \"M\"."], "decode": "if size == '11' then SEE \"Related encodings\";\nif size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;\nunsigned = FALSE;  // \"Don't care\" value: TRUE produces same functionality\nadd = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;\nd = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;\nif size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);\nif size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);\n            if floating_point then\n                fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));\n                Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());\n            else\n                addend = if add then op1val*op2val else -op1val*op2val;\n                if long_destination then\n                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;\n                else\n                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;"}, {"mnemonic": "VREV16", "short_desc": "Vector Reverse in halfwords", "full_desc": "Vector Reverse in halfwords reverses the order of 8-bit elements in each halfword of the vector, and places the result in the corresponding destination vector.", "syntax": ["VREV16{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VREV16{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VREV16{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VREV16{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if UInt(op)+UInt(size) >= 3 then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\n\nesize = 8 << UInt(size);\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\ninteger containers = 64 DIV container_size;\ninteger elements_per_container = container_size DIV esize;\n\nd = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n\n    bits(64) result;\n    integer element;\n    integer rev_element;\n    for r = 0 to regs-1\n        element = 0;\n        for c = 0 to containers-1\n            rev_element = element + elements_per_container - 1;\n            for e = 0 to elements_per_container-1\n                Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];\n                element = element + 1;\n                rev_element = rev_element - 1;\n        D[d+r] = result;"}, {"mnemonic": "VCVT (between double-precision and single-precision)", "short_desc": "Convert between double-precision and single-precision", "full_desc": "Convert between double-precision and single-precision does one of the following:", "syntax": ["VCVT{<c>}{<q>}.F64.F32 <Dd>, <Sm>\t; Single-precision to double-precision", "VCVT{<c>}{<q>}.F32.F64 <Sd>, <Dm>\t; Double-precision to single-precision", "VCVT{<c>}{<q>}.F64.F32 <Dd>, <Sm>\t; Single-precision to double-precision", "VCVT{<c>}{<q>}.F32.F64 <Sd>, <Dm>\t; Double-precision to single-precision"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "double_to_single = (size == '11');\nd = if double_to_single then UInt(Vd:D) else UInt(D:Vd);\nm = if double_to_single then UInt(M:Vm) else UInt(Vm:M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    if double_to_single then\n        S[d] = FPConvert(D[m], FPSCR);\n    else\n        D[d] = FPConvert(S[m], FPSCR);"}, {"mnemonic": "VADDL", "short_desc": "Vector Add Long", "full_desc": "Vector Add Long adds corresponding elements in two doubleword vectors, and places the results in a quadword vector. Before adding, it sign-extends or zero-extends the elements of both operands.", "syntax": ["VADDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; A1", "VADDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then SEE \"Related encodings\";\nif Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;\nunsigned = (U == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        if is_vaddw then\n            op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);\n        else\n            op1 = Int(Elem[Din[n],e,esize], unsigned);\n        result = op1 + Int(Elem[Din[m],e,esize],unsigned);\n        Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;"}, {"mnemonic": "VMAX (floating-point)", "short_desc": "Vector Maximum (floating-point)", "full_desc": "Vector Maximum compares corresponding elements in two vectors, and copies the larger of each pair into the corresponding element in the destination vector.", "syntax": ["VMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMAX{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector", "VMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; 64-bit SIMD vector", "VMAX{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nmaximum = (op == '0');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];\n            if maximum then\n                Elem[D[d+r],e,esize] = FPMax(op1, op2, StandardFPSCRValue());\n            else\n                Elem[D[d+r],e,esize] = FPMin(op1, op2, StandardFPSCRValue());"}, {"mnemonic": "UXTAB", "short_desc": "Unsigned Extend and Add Byte", "full_desc": "Unsigned Extend and Add Byte extracts an 8-bit value from a register, zero-extends it to 32 bits, adds the result to the value in another register, and writes the final result to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.", "syntax": ["UXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; A1", "UXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<amount>\n"], "decode": "if Rn == '1111' then SEE \"UXTB\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    rotated = ROR(R[m], rotation);\n    R[d] = R[n] + ZeroExtend(rotated<7:0>, 32);"}, {"mnemonic": "LDC (literal)", "short_desc": "Load data to System register (literal)", "full_desc": "Load data to System register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to the  System register. For information about memory accesses see .", "syntax": ["LDC{<c>}{<q>} p14, c5, <label>\t; A1", "LDC{<c>}{<q>} p14, c5, [PC, #{+/-}<imm>]\t; A1", "LDC{<c>}{<q>} p14, c5, [PC], <option>\t; A1", "LDC{<c>}{<q>} p14, c5, <label>\t; T1", "LDC{<c>}{<q>} p14, c5, [PC, #{+/-}<imm>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<option>\nIs an 8-bit immediate, in the range 0 to 255 enclosed in { }, encoded in the \"imm8\" field. The value of this field is ignored when executing this instruction.", "<label>\nThe label of the literal data item that is to be loaded into . The assembler calculates the required value of the offset from the  value of the instruction to this label. Permitted values of the offset are multiples of 4 in the range -1020 to 1020.", "+/-\n", "<imm>\nIs the immediate offset used for forming the address, a multiple of 4 in the range 0-1020, defaulting to 0 and encoded in the \"imm8\" field, as <imm>/4."], "decode": "if P == '0' && U == '0' && W == '0' then UNDEFINED;\nindex = (P == '1');  add = (U == '1');  cp = 14;  imm32 = ZeroExtend(imm8:'00', 32);\nif W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset_addr = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);\n    address = if index then offset_addr else Align(PC,4);\n\n    // System register write to DBGDTRTXint.\n    DBGDTR_EL0[] = MemA[address,4];"}, {"mnemonic": "ORN, ORNS (register)", "short_desc": "Bitwise OR NOT (register)", "full_desc": "Bitwise OR NOT (register) performs a bitwise (inclusive) OR of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.", "syntax": ["ORN{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ORN, rotate right with extend", "ORN{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ORN, shift or rotate by value", "ORNS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ORNS, rotate right with extend", "ORNS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ORNS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nIs the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "if Rn == '1111' then SEE \"MVN (register)\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);\nif d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] OR NOT(shifted);\n    R[d] = result;\n    if setflags then\n        PSTATE.N = result<31>;\n        PSTATE.Z = IsZeroBit(result);\n        PSTATE.C = carry;\n        // PSTATE.V unchanged"}, {"mnemonic": "LDRT", "short_desc": "Load Register Unprivileged", "full_desc": "Load Register Unprivileged loads a word from memory, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}\t; A1", "LDRT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}\t; A2", "LDRT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, but this is deprecated.", "<Rt>\nFor encoding A2 and T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\nThe shift to apply to the value read from . If absent, no shift is applied. Otherwise, see .", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 if omitted, and encoded in the \"imm12\" field.", "<imm>\nFor encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 and encoded in the \"imm8\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');\nregister_form = FALSE;  imm32 = ZeroExtend(imm12, 32);\nif t == 15 || n == 15 || n == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode\n    EncodingSpecificOperations();\n    offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if postindex then R[n] else offset_addr;\n    data = MemU_unpriv[address,4];\n    if postindex then R[n] = offset_addr;\n    R[t] = data;"}, {"mnemonic": "ADC, ADCS (register-shifted register)", "short_desc": "Add with Carry (register-shifted register)", "full_desc": "Add with Carry (register-shifted register) adds a register value, the Carry flag value, and a register-shifted register value.  It writes the result to the destination register, and can optionally update the condition flags based on the result.", "syntax": ["ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);\n    R[d] = result;\n    if setflags then\n        PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "SDIV", "short_desc": "Signed Divide", "full_desc": "Signed Divide divides a 32-bit signed integer register value by a 32-bit signed integer register value, and writes the result to the destination register. The condition flags are not affected.", "syntax": ["SDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "SDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the dividend, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the divisor, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);\nif d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    if SInt(R[m]) == 0 then\n        result = 0;\n    else\n        result = RoundTowardsZero(Real(SInt(R[n])) / Real(SInt(R[m])));\n    R[d] = result<31:0>;"}, {"mnemonic": "Shared Pseudocode Functions", "short_desc": "This page displays common pseudocode functions shared by many pages", "syntax": [], "symbols": [], "operation": "// AArch32.VCRMatch()\n// ==================\n\nboolean AArch32.VCRMatch(bits(32) vaddress)\n\n    if UsingAArch32() && ELUsingAArch32(EL1) && IsZero(vaddress<1:0>) && PSTATE.EL != EL2 then\n        // Each bit position in this string corresponds to a bit in DBGVCR and an exception vector.\n        match_word = Zeros(32);\n\n        if vaddress<31:5> == ExcVectorBase()<31:5> then\n            if HaveEL(EL3) && !IsSecure() then\n                match_word<UInt(vaddress<4:2>) + 24> = '1';     // Non-secure vectors\n            else\n                match_word<UInt(vaddress<4:2>) + 0> = '1';      // Secure vectors (or no EL3)\n\n        if HaveEL(EL3) && ELUsingAArch32(EL3) && IsSecure() && vaddress<31:5> == MVBAR<31:5> then\n            match_word<UInt(vaddress<4:2>) + 8> = '1';          // Monitor vectors\n\n        // Mask out bits not corresponding to vectors.\n        if !HaveEL(EL3) then\n            mask = '00000000':'00000000':'00000000':'11011110'; // DBGVCR[31:8] are RES0\n        elsif !ELUsingAArch32(EL3) then\n            mask = '11011110':'00000000':'00000000':'11011110'; // DBGVCR[15:8] are RES0\n        else\n            mask = '11011110':'00000000':'11011100':'11011110';\n\n        match_word = match_word AND DBGVCR AND mask;\n        match = !IsZero(match_word);\n\n        // Check for UNPREDICTABLE case - match on Prefetch Abort and Data Abort vectors\n        if !IsZero(match_word<28:27,12:11,4:3>) && DebugTarget() == PSTATE.EL then\n            match = ConstrainUnpredictableBool(Unpredictable_VCMATCHDAPA);\n    else\n        match = FALSE;\n\n    return match;"}, {"mnemonic": "LDRSB (immediate)", "short_desc": "Load Register Signed Byte (immediate)", "full_desc": "Load Register Signed Byte (immediate) calculates an address from a base register value and an immediate offset, loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing.  For information about memory accesses see .", "syntax": ["LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]\t; Offset", "LDRSB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRSB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed", "LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1", "LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]\t; Offset", "LDRSB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>\t; Post-indexed", "LDRSB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!\t; Pre-indexed"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field. For PC use see .", "+/-\n", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<imm>\nFor encoding T2: is an 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm8\" field."], "decode": "if Rn == '1111' then SEE \"LDRSB (literal)\";\nif P == '0' && W == '1' then SEE \"LDRSBT\";\nt = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\nif t == 15 || (wback && n == t) then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);\n    address = if index then offset_addr else R[n];\n    R[t] = SignExtend(MemU[address,1], 32);\n    if wback then R[n] = offset_addr;"}, {"mnemonic": "SMLABB, SMLABT, SMLATB, SMLATT", "short_desc": "Signed Multiply Accumulate (halfwords)", "full_desc": "Signed Multiply Accumulate (halfwords) performs a signed multiply accumulate operation. The multiply acts on two signed 16-bit quantities, taken from either the bottom or the top half of their respective source registers. The other halves of these source registers are ignored.  The 32-bit product is added to a 32-bit accumulate value and the result is written to the destination register.", "syntax": ["SMLABB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLABB", "SMLABT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLABT", "SMLATB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLATB", "SMLATT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLATT", "SMLABB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLABB", "SMLABT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLABT", "SMLATB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLATB", "SMLATT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMLATT"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand in the bottom or top half (selected by ), encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier in the bottom or top half (selected by ), encoded in the \"Rm\" field.", "<Ra>\nIs the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);\nn_high = (N == '1');  m_high = (M == '1');\nif d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;\n    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;\n    result = SInt(operand1) * SInt(operand2) + SInt(R[a]);\n    R[d] = result<31:0>;\n    if result != SInt(result<31:0>) then  // Signed overflow\n        PSTATE.Q = '1';"}, {"mnemonic": "UMULL, UMULLS", "short_desc": "Unsigned Multiply Long", "full_desc": "Unsigned Multiply Long multiplies two 32-bit unsigned values to produce a 64-bit result.", "syntax": ["UMULLS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; Flag setting", "UMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; Not flag setting", "UMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<RdLo>\nIs the general-purpose destination register for the lower 32 bits of the result, encoded in the \"RdLo\" field.", "<RdHi>\nIs the general-purpose destination register for the upper 32 bits of the result, encoded in the \"RdHi\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."], "decode": "dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\nif dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;\nif dHi == dLo then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = UInt(R[n]) * UInt(R[m]);\n    R[dHi] = result<63:32>;\n    R[dLo] = result<31:0>;\n    if setflags then\n        PSTATE.N = result<63>;\n        PSTATE.Z = IsZeroBit(result<63:0>);\n        // PSTATE.C, PSTATE.V unchanged"}, {"mnemonic": "DCPS1", "short_desc": "Debug Change PE State to EL1", "full_desc": "Debug Change PE State to EL1 allows the debugger to move the PE into EL1 from EL0 or to a specific mode at the current Exception Level.", "syntax": ["DCPS1\t; T1"], "symbols": [], "decode": "// No additional decoding required.", "operation": "if !Halted() then UNDEFINED;\n\nif EL2Enabled() && PSTATE.EL == EL0 then\n    tge = if ELUsingAArch32(EL2) then HCR.TGE else HCR_EL2.TGE;\n    if tge == '1' then UNDEFINED;\n\nif PSTATE.EL != EL0 || ELUsingAArch32(EL1) then\n    if PSTATE.M == M32_Monitor then SCR.NS = '0';\n    if PSTATE.EL != EL2 then\n        AArch32.WriteMode(M32_Svc);\n        PSTATE.E = SCTLR.EE;\n        if HavePANExt() && SCTLR.SPAN == '0' then PSTATE.PAN = '1';\n        LR_svc = bits(32) UNKNOWN;\n        SPSR_svc = bits(32) UNKNOWN;\n    else\n        PSTATE.E = HSCTLR.EE;\n        ELR_hyp = bits(32) UNKNOWN;\n        HSR = bits(32) UNKNOWN;\n        SPSR_hyp = bits(32) UNKNOWN;\n\n    DLR = bits(32) UNKNOWN;\n    DSPSR = bits(32) UNKNOWN;\nelse                                        // Targeting EL1 using AArch64\n    AArch64.MaybeZeroRegisterUppers();\n    MaybeZeroSVEUppers(EL1);\n    PSTATE.nRW = '0';\n    PSTATE.SP = '1';\n    PSTATE.EL = EL1;\n    if HavePANExt() && SCTLR_EL1.SPAN == '0' then PSTATE.PAN = '1';\n    if HaveUAOExt() then PSTATE.UAO = '0';\n\n    ELR_EL1 = bits(64) UNKNOWN;\n    ESR_EL1 = bits(32) UNKNOWN;\n    SPSR_EL1 = bits(32) UNKNOWN;\n\n    DLR_EL0 = bits(64) UNKNOWN;\n    DSPSR_EL0 = bits(32) UNKNOWN;\n\n    // SCTLR_EL1.IESB might be ignored in Debug state.\n    if HaveIESB() && SCTLR_EL1.IESB == '1' &&  !ConstrainUnpredictableBool(Unpredictable_IESBinDebug) then\n        SynchronizeErrors();\n\nUpdateEDSCRFields();                        // Update EDSCR PE state flags"}, {"mnemonic": "VINS", "short_desc": "Vector move Insertion", "full_desc": "Vector move Insertion. This instruction copies the lower 16 bits of the 32-bit source SIMD&FP register into the upper 16 bits of the 32-bit destination SIMD&FP register, while preserving the values in the remaining bits.", "syntax": ["VINS{<q>}.F16 <Sd>, <Sm>\t; A1", "VINS{<q>}.F16 <Sd>, <Sm>\t; T1"], "symbols": ["<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if !HaveFP16Ext() then UNDEFINED;\nif FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;\nd = UInt(Vd:D); m = UInt(Vm:M);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    S[d] = S[m]<15:0> : S[d]<15:0>;"}, {"mnemonic": "STMDA, STMED", "short_desc": "Store Multiple Decrement After (Empty Descending)", "full_desc": "Store Multiple Decrement After (Empty Descending) stores multiple registers to consecutive memory locations using an address from a base register. The consecutive memory locations end at this address, and the address just below the lowest of those locations can optionally be written back to the base register.", "syntax": ["STMDA{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "STMED{<c>}{<q>} <Rn>{!}, <registers>\t; A1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "<registers>\nIs a list of one or more registers to be stored, separated by commas and surrounded by { and }."], "decode": "n = UInt(Rn);  registers = register_list;  wback = (W == '1');\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n] - 4*BitCount(registers) + 4;\n    for i = 0 to 14\n        if registers<i> == '1' then\n            if i == n && wback && i != LowestSetBit(registers) then\n                MemA[address,4] = bits(32) UNKNOWN;\n            else\n                MemA[address,4] = R[i];\n            address = address + 4;\n    if registers<15> == '1' then\n        MemA[address,4] = PCStoreValue();\n    if wback then R[n] = R[n] - 4*BitCount(registers);"}, {"mnemonic": "STL", "short_desc": "Store-Release Word", "full_desc": "Store-Release Word stores a word from a register to memory.  The instruction also has memory ordering semantics as described in .", "syntax": ["STL{<c>}{<q>} <Rt>, [<Rn>]\t; A1", "STL{<c>}{<q>} <Rt>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "t = UInt(Rt); n = UInt(Rn);\nif t == 15 || n == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    MemO[address, 4] = R[t];"}, {"mnemonic": "DCPS3", "short_desc": "Debug Change PE State to EL3", "full_desc": "Debug Change PE State to EL3 allows the debugger to move the PE into EL3 from a lower Exception Level or to a specific mode at the current Exception Level.", "syntax": ["DCPS3\t; T1"], "symbols": [], "decode": "if !HaveEL(EL3) then UNDEFINED;", "operation": "if !Halted() || EDSCR.SDD == '1' then UNDEFINED;\n\nif ELUsingAArch32(EL3) then\n    from_secure = IsSecure();\n    if PSTATE.M == M32_Monitor then SCR.NS = '0';\n    AArch32.WriteMode(M32_Monitor);\n    if HavePANExt() then\n        if !from_secure then\n            PSTATE.PAN = '0';\n        elsif SCTLR.SPAN == '0' then\n            PSTATE.PAN = '1';\n    PSTATE.E = SCTLR.EE;\n\n    LR_mon = bits(32) UNKNOWN;\n    SPSR_mon = bits(32) UNKNOWN;\n\n    DLR = bits(32) UNKNOWN;\n    DSPSR = bits(32) UNKNOWN;\nelse                                        // Targeting EL3 using AArch64\n    AArch64.MaybeZeroRegisterUppers();\n    MaybeZeroSVEUppers(EL3);\n    PSTATE.nRW = '0';\n    PSTATE.SP = '1';\n    PSTATE.EL = EL3;\n    if HaveUAOExt() then PSTATE.UAO = '0';\n\n    ELR_EL3 = bits(64) UNKNOWN;\n    ESR_EL3 = bits(32) UNKNOWN;\n    SPSR_EL3 = bits(32) UNKNOWN;\n\n    DLR_EL0 = bits(64) UNKNOWN;\n    DSPSR_EL0 = bits(32) UNKNOWN;\n\n    sync_errors = HaveIESB() && SCTLR_EL3.IESB == '1';\n    if HaveDoubleFaultExt() && SCR_EL3.EA == '1' && SCR_EL3.NMEA == '1' then\n        sync_errors = TRUE;\n    // SCTLR_EL3.IESB might be ignored in Debug state.\n    if !ConstrainUnpredictableBool(Unpredictable_IESBinDebug) then\n        sync_errors = FALSE;\n    if sync_errors then SynchronizeErrors();\n\nUpdateEDSCRFields();                        // Update EDSCR PE state flags"}, {"mnemonic": "LDMIB, LDMED", "short_desc": "Load Multiple Increment Before (Empty Descending)", "full_desc": "Load Multiple Increment Before (Empty Descending) loads multiple registers from consecutive memory locations using an address from a base register. The consecutive memory locations start just above this address, and the address of the last of those locations can optionally be written back to the base register.", "syntax": ["LDMIB{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "LDMED{<c>}{<q>} <Rn>{!}, <registers>\t; A1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "<registers>\nIs a list of one or more registers to be loaded, separated by commas and surrounded by { and }."], "decode": "n = UInt(Rn);  registers = register_list;  wback = (W == '1');\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;\nif wback && registers<n> == '1' then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n] + 4;\n    for i = 0 to 14\n        if registers<i> == '1' then\n            R[i] = MemA[address,4];  address = address + 4;\n    if registers<15> == '1' then\n        LoadWritePC(MemA[address,4]);\n    if wback && registers<n> == '0' then R[n] = R[n] + 4*BitCount(registers);\n    if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;"}, {"mnemonic": "VNEG", "short_desc": "Vector Negate", "full_desc": "Vector Negate negates each element in a vector, and places the results in a second vector. The floating-point version only inverts the sign bit.", "syntax": ["VNEG{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VNEG{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VNEG{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VNEG{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VNEG{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar", "VNEG{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VNEG{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VNEG{<c>}{<q>}.F16 <Sd>, <Sm>\t; Half-precision scalar", "VNEG{<c>}{<q>}.F32 <Sd>, <Sm>\t; Single-precision scalar", "VNEG{<c>}{<q>}.F64 <Dd>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if size == '11' then UNDEFINED;\nif F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nadvsimd = TRUE;  floating_point = (F == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if advsimd then  // Advanced SIMD instruction\n        for r = 0 to regs-1\n            for e = 0 to elements-1\n                if floating_point then\n                    Elem[D[d+r],e,esize] = FPNeg(Elem[D[m+r],e,esize]);\n                else\n                    result = -SInt(Elem[D[m+r],e,esize]);\n                    Elem[D[d+r],e,esize] = result<esize-1:0>;\n    else             // VFP instruction\n        case esize of\n            when 16 S[d] = Zeros(16) : FPNeg(S[m]<15:0>);\n            when 32 S[d] = FPNeg(S[m]);\n            when 64 D[d] = FPNeg(D[m]);"}, {"mnemonic": "UHASX", "short_desc": "Unsigned Halving Add and Subtract with Exchange", "full_desc": "Unsigned Halving Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one unsigned 16-bit integer addition and one unsigned 16-bit subtraction, halves the results, and writes the results to the destination register.", "syntax": ["UHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);\n    sum  = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);\n    R[d]<15:0>  = diff<16:1>;\n    R[d]<31:16> = sum<16:1>;"}, {"mnemonic": "VPMAX (floating-point)", "short_desc": "Vector Pairwise Maximum (floating-point)", "full_desc": "Vector Pairwise Maximum compares adjacent pairs of elements in two doubleword vectors, and copies the larger of each pair into the corresponding element in the destination doubleword vector.", "syntax": ["VPMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; A1", "VPMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>\t; T1"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if sz == '1' && !HaveFP16Ext() then UNDEFINED;\nmaximum = (op == '0');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    bits(64) dest;\n    h = elements DIV 2;\n\n    for e = 0 to h-1\n        op1 = Elem[D[n],2*e,esize];  op2 = Elem[D[n],2*e+1,esize];\n        Elem[dest,e,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());\n        op1 = Elem[D[m],2*e,esize];  op2 = Elem[D[m],2*e+1,esize];\n        Elem[dest,e+h,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());\n\n    D[d] = dest;"}, {"mnemonic": "VPADAL", "short_desc": "Vector Pairwise Add and Accumulate Long", "full_desc": "Vector Pairwise Add and Accumulate Long adds adjacent pairs of elements of a vector, and accumulates the results into the elements of the destination vector.", "syntax": ["VPADAL{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VPADAL{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VPADAL{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VPADAL{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nunsigned = (op == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    h = elements DIV 2;\n\n    for r = 0 to regs-1\n        for e = 0 to h-1\n            op1 = Elem[D[m+r],2*e,esize];  op2 = Elem[D[m+r],2*e+1,esize];\n            result = Int(op1, unsigned) + Int(op2, unsigned);\n            Elem[D[d+r],e,2*esize] = Elem[D[d+r],e,2*esize] + result;"}, {"mnemonic": "VRINTX (Advanced SIMD)", "short_desc": "Vector round floating-point to integer inexact", "full_desc": "Vector round floating-point to integer inexact rounds a vector of floating-point values to integral floating-point values of the same size, using the Round to Nearest rounding mode, and raises the Inexact exception when the result value is not numerically equal to the input value. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTX{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTX{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VRINTX{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTX{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\nrounding = FPRounding_TIEEVEN;  exact = TRUE;\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        op1 = Elem[D[m+r],e,esize];\n        result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);\n        Elem[D[d+r],e,esize] = result;"}, {"mnemonic": "SHA256H2", "short_desc": "SHA256 hash update part 2", "full_desc": "SHA256 hash update part 2.", "syntax": ["SHA256H2.32 <Qd>, <Qn>, <Qm>\t; A1", "SHA256H2.32 <Qd>, <Qn>, <Qm>\t; T1"], "symbols": ["<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if !HaveSHA256Ext() then UNDEFINED;\nif Q != '1' then UNDEFINED;\nif Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;\nd = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations(); CheckCryptoEnabled32();\n    X = Q[n>>1]; Y = Q[d>>1]; W = Q[m>>1]; part1 = FALSE;\n    Q[d>>1] = SHA256hash(X, Y, W, part1);"}, {"mnemonic": "STLEXD", "short_desc": "Store-Release Exclusive Doubleword", "full_desc": "Store-Release Exclusive Doubleword stores a doubleword from two registers to memory if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.", "syntax": ["STLEXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]\t; A1", "STLEXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the destination general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rd\" field. The value returned is:", "<Rt>\nFor encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.  must be even-numbered and not R14.", "<Rt>\nFor encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt2>\nFor encoding A1: is the second general-purpose register to be transferred.  must be .", "<Rt2>\nFor encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field."], "decode": "d = UInt(Rd);  t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);\nif d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;\nif d == n || d == t || d == t2 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.\n    value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];\n    if AArch32.ExclusiveMonitorsPass(address, 8) then\n        MemO[address, 8] = value;\n        R[d] = ZeroExtend('0');\n    else\n        R[d] = ZeroExtend('1');"}, {"mnemonic": "REV16", "short_desc": "Byte-Reverse Packed Halfword", "full_desc": "Byte-Reverse Packed Halfword reverses the byte order in each16-bit halfword of a 32-bit register.", "syntax": ["REV16{<c>}{<q>} <Rd>, <Rm>\t; A1", "REV16{<c>}{<q>} <Rd>, <Rm>\t; T1", "REV16{<c>}.W <Rd>, <Rm>\t; T2", "REV16{<c>}{<q>} <Rd>, <Rm>\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rm>\nFor encoding A1 and T1: is the general-purpose source register, encoded in the \"Rm\" field.", "<Rm>\nFor encoding T2: is the general-purpose source register, encoded in the \"Rm\" field. It must be encoded with an identical value in the \"Rn\" field."], "decode": "d = UInt(Rd);  m = UInt(Rm);\nif d == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    bits(32) result;\n    result<31:24> = R[m]<23:16>;\n    result<23:16> = R[m]<31:24>;\n    result<15:8>  = R[m]<7:0>;\n    result<7:0>   = R[m]<15:8>;\n    R[d] = result;"}, {"mnemonic": "LDR (register)", "short_desc": "Load Register (register)", "full_desc": "Load Register (register) calculates an address from a base register value and an offset register value, loads a word from memory, and writes it to a register. The offset register value can optionally be shifted. For information about memory accesses, see .", "syntax": ["LDR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]\t; Offset", "LDR{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}\t; Post-indexed", "LDR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!\t; Pre-indexed", "LDR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]\t; T1", "LDR{<c>}.W <Rt>, [<Rn>, {+}<Rm>]\t; T2", "LDR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]\t; T2"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nFor encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used. If the PC is used, the instruction branches to the address (data) loaded to the PC. This branch is an interworking branch, see .", "<Rt>\nFor encoding T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rt>\nFor encoding T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC can be used, provided the instruction is either outside an IT block or the last instruction of an IT block. If the PC is used, the instruction branches to the address (data) loaded to the PC. This is an interworking branch, see .", "<Rn>\nFor encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be used in the offset variant.", "<Rn>\nFor encoding T1 and T2: is the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+\nSpecifies the index register is added to the base register.", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "<shift>\nThe shift to apply to the value read from . If absent, no shift is applied. Otherwise, see .", "<imm>\nIf present, the size of the left shift to apply to the value from , in the range 1-3.  is encoded in imm2. If absent, no shift is specified and imm2 is encoded as ."], "decode": "if P == '0' && W == '1' then SEE \"LDRT\";\nt = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);\nindex = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);\nif m == 15 then UNPREDICTABLE;\nif wback && (n == 15 || n == t) then UNPREDICTABLE;", "operation": "if CurrentInstrSet() == InstrSet_A32 then\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n        offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n        address = if index then offset_addr else R[n];\n        data = MemU[address,4];\n        if wback then R[n] = offset_addr;\n        if t == 15 then\n            if address<1:0> == '00' then\n                LoadWritePC(data);\n            else\n                UNPREDICTABLE;\n        else\n            R[t] = data;\nelse\n    if ConditionPassed() then\n        EncodingSpecificOperations();\n        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);\n        offset_addr = (R[n] + offset);\n        address = offset_addr;\n        data = MemU[address,4];\n        if t == 15 then\n            if address<1:0> == '00' then\n                LoadWritePC(data);\n            else\n                UNPREDICTABLE;\n        else\n            R[t] = data;"}, {"mnemonic": "UADD16", "short_desc": "Unsigned Add 16", "full_desc": "Unsigned Add 16 performs two 16-bit unsigned integer additions, and writes the results to the destination register. It sets .GE according to the results of the additions.", "syntax": ["UADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);\n    sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);\n    R[d]<15:0>  = sum1<15:0>;\n    R[d]<31:16> = sum2<15:0>;\n    PSTATE.GE<1:0> = if sum1 >= 0x10000 then '11' else '00';\n    PSTATE.GE<3:2> = if sum2 >= 0x10000 then '11' else '00';"}, {"mnemonic": "ADC, ADCS (register)", "short_desc": "Add with Carry (register)", "full_desc": "Add with Carry (register) adds a register value, the Carry flag value, and an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ADC, rotate right with extend", "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ADC, shift or rotate by value", "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ADCS, rotate right with extend", "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ADCS, shift or rotate by value", "ADC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "ADCS{<q>} {<Rdn>,} <Rdn>, <Rm>\t; T1", "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ADC, rotate right with extend", "ADC<c>.W {<Rd>,} <Rn>, <Rm>\t; ADC, shift or rotate by value", "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ADC, shift or rotate by value", "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; ADCS, rotate right with extend", "ADCS.W {<Rd>,} <Rn>, <Rm>\t; ADCS, shift or rotate by value", "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; ADCS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rdn>\nIs the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.", "<Rd>\nFor encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rd>\nFor encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T2: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);\n    if d == 15 then          // Can only occur for A32 encoding\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "SUB, SUBS (register-shifted register)", "short_desc": "Subtract (register-shifted register)", "full_desc": "Subtract (register-shifted register) subtracts a register-shifted register value from a register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.", "syntax": ["SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Flag setting", "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <shift> <Rs>\t; Not flag setting"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<Rs>\nIs the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);\nsetflags = (S == '1');  shift_t = DecodeRegShift(stype);\nif d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shift_n = UInt(R[s]<7:0>);\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');\n    R[d] = result;\n    if setflags then\n        PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "CLREX", "short_desc": "Clear-Exclusive", "full_desc": "Clear-Exclusive clears the local monitor of the executing PE.", "syntax": ["CLREX{<c>}{<q>}\t; A1", "CLREX{<c>}{<q>}\t; T1"], "symbols": ["<c>\nFor encoding A1: see . Must be  or omitted.", "<c>\nFor encoding T1: see .", "<q>\nSee ."], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    ClearExclusiveLocal(ProcessorID());"}, {"mnemonic": "VCVT (floating-point to integer, floating-point)", "short_desc": "Convert floating-point to integer with Round towards Zero", "full_desc": "Convert floating-point to integer with Round towards Zero converts a value in a register from floating-point to a 32-bit integer, using the Round towards Zero rounding mode, and places the result in a second register.", "syntax": ["VCVT{<c>}{<q>}.U32.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVT{<c>}{<q>}.S32.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVT{<c>}{<q>}.U32.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVT{<c>}{<q>}.S32.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVT{<c>}{<q>}.U32.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVT{<c>}{<q>}.S32.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVT{<c>}{<q>}.U32.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVT{<c>}{<q>}.S32.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVT{<c>}{<q>}.U32.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVT{<c>}{<q>}.S32.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVT{<c>}{<q>}.U32.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVT{<c>}{<q>}.S32.F64 <Sd>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if opc2 != '000' && opc2 != '10x' then SEE \"Related encodings\";\nif size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nif size == '01' && cond != '1110' then UNPREDICTABLE;\nto_integer = (opc2<2> == '1');\nif to_integer then\n    unsigned = (opc2<0> == '0');\n    rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);\n    d = UInt(Vd:D);\n    case size of\n        when '01' esize = 16; m = UInt(Vm:M);\n        when '10' esize = 32; m = UInt(Vm:M);\n        when '11' esize = 64; m = UInt(M:Vm);\nelse\n    unsigned = (op == '0');\n    rounding = FPRoundingMode(FPSCR);\n    m = UInt(Vm:M);\n    case size of\n        when '01' esize = 16; d = UInt(Vd:D);\n        when '10' esize = 32; d = UInt(Vd:D);\n        when '11' esize = 64; d = UInt(D:Vd);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckVFPEnabled(TRUE);\n    if to_integer then\n        case esize of\n            when 16\n                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);\n            when 32\n                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);\n            when 64\n                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);\n    else\n        case esize of\n            when 16\n                bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);\n                S[d] = Zeros(16):fp16;\n            when 32\n                S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);\n            when 64\n                D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);"}, {"mnemonic": "VMVN (register)", "short_desc": "Vector Bitwise NOT (register)", "full_desc": "Vector Bitwise NOT (register) takes a value from a register, inverts the value of each bit, and places the result in the destination register. The registers can be either doubleword or quadword.", "syntax": ["VMVN{<c>}{<q>}{.<dt>} <Dd>, <Dm>\t; 64-bit SIMD vector", "VMVN{<c>}{<q>}{.<dt>} <Qd>, <Qm>\t; 128-bit SIMD vector", "VMVN{<c>}{<q>}{.<dt>} <Dd>, <Dm>\t; 64-bit SIMD vector", "VMVN{<c>}{<q>}{.<dt>} <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size != '00' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        D[d+r] = NOT(D[m+r]);"}, {"mnemonic": "VCVTP (floating-point)", "short_desc": "Convert floating-point to integer with Round towards +Infinity", "full_desc": "Convert floating-point to integer with Round towards +Infinity converts a value in a register from floating-point to a 32-bit integer using the Round towards +Infinity rounding mode, and places the result in a second register.", "syntax": ["VCVTP{<q>}.<dt>.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTP{<q>}.<dt>.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTP{<q>}.<dt>.F64 <Sd>, <Dm>\t; Double-precision scalar", "VCVTP{<q>}.<dt>.F16 <Sd>, <Sm>\t; Half-precision scalar", "VCVTP{<q>}.<dt>.F32 <Sd>, <Sm>\t; Single-precision scalar", "VCVTP{<q>}.<dt>.F64 <Sd>, <Dm>\t; Double-precision scalar"], "symbols": ["<q>\nSee .", "<dt>\n", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sm>\nIs the 32-bit name of the SIMD&FP source register, encoded in the \"Vm:M\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;\nrounding = FPDecodeRM(RM);  unsigned = (op == '0');\nd = UInt(Vd:D);\ncase size of\n    when '01' esize = 16; m = UInt(Vm:M);\n    when '10' esize = 32; m = UInt(Vm:M);\n    when '11' esize = 64; m = UInt(M:Vm);", "operation": "EncodingSpecificOperations(); CheckVFPEnabled(TRUE);\ncase esize of\n    when 16\n        S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);\n    when 32\n        S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);\n    when 64\n        S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);"}, {"mnemonic": "SMMLA, SMMLAR", "short_desc": "Signed Most Significant Word Multiply Accumulate", "full_desc": "Signed Most Significant Word Multiply Accumulate multiplies two signed 32-bit values, extracts the most significant 32 bits of the result, and adds an accumulate value.", "syntax": ["SMMLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMMLA", "SMMLAR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMMLAR", "SMMLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMMLA", "SMMLAR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>\t; SMMLAR"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Ra>\nIs the third general-purpose source register holding the addend, encoded in the \"Ra\" field."], "decode": "if Ra == '1111' then SEE \"SMMUL\";\nd = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    result = (SInt(R[a]) << 32) + SInt(R[n]) * SInt(R[m]);\n    if round then result = result + 0x80000000;\n    R[d] = result<63:32>;"}, {"mnemonic": "VSRI", "short_desc": "Vector Shift Right and Insert", "full_desc": "Vector Shift Right and Insert takes each element in the operand vector, right shifts them by an immediate value, and inserts the results in the destination vector. Bits shifted out of the right of each element are lost.", "syntax": ["VSRI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSRI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector", "VSRI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm>\t; 64-bit SIMD vector", "VSRI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<size>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<imm>\nIs an immediate value, in the range 1 to , encoded in the \"imm6\" field as  - ."], "decode": "if (L:imm6) == '0000xxx' then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\ncase L:imm6 of\n    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);\n    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);\n    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);\n    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    mask = LSR(Ones(esize), shift_amount);\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            shifted_op = LSR(Elem[D[m+r],e,esize], shift_amount);\n            Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;"}, {"mnemonic": "VMLS (floating-point)", "short_desc": "Vector Multiply Subtract (floating-point)", "full_desc": "Vector Multiply Subtract multiplies corresponding elements in two vectors, subtracts the products from corresponding elements of the destination vector, and places the results in the destination vector.", "syntax": ["VMLS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMLS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMLS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VMLS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VMLS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar", "VMLS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>\t; 64-bit SIMD vector", "VMLS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>\t; 128-bit SIMD vector", "VMLS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>\t; Half-precision scalar", "VMLS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>\t; Single-precision scalar", "VMLS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>\t; Double-precision scalar"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding A2, T1 and T2: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Sd>\nIs the 32-bit name of the SIMD&FP destination register, encoded in the \"Vd:D\" field.", "<Sn>\nIs the 32-bit name of the first SIMD&FP source register, encoded in the \"Vn:N\" field.", "<Sm>\nIs the 32-bit name of the second SIMD&FP source register, encoded in the \"Vm:M\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif sz == '1' && !HaveFP16Ext() then UNDEFINED;\nadvsimd = TRUE;  add = (op == '0');\ncase sz of\n    when '0' esize = 32; elements = 2;\n    when '1' esize = 16; elements = 4;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);\n    if advsimd then  // Advanced SIMD instruction\n        for r = 0 to regs-1\n            for e = 0 to elements-1\n                product = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());\n                addend = if add then product else FPNeg(product);\n                Elem[D[d+r],e,esize] = FPAdd(Elem[D[d+r],e,esize], addend, StandardFPSCRValue());\n    else             // VFP instruction\n        case esize of\n            when 16\n                addend16 = if add then FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR) else FPNeg(FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR));\n                S[d] = Zeros(16) : FPAdd(S[d]<15:0>, addend16, FPSCR);\n            when 32\n                addend32 = if add then FPMul(S[n], S[m], FPSCR) else FPNeg(FPMul(S[n], S[m], FPSCR));\n                S[d] = FPAdd(S[d], addend32, FPSCR);\n            when 64\n                addend64 = if add then FPMul(D[n], D[m], FPSCR) else FPNeg(FPMul(D[n], D[m], FPSCR));\n                D[d] = FPAdd(D[d], addend64, FPSCR);"}, {"mnemonic": "VRINTM (Advanced SIMD)", "short_desc": "Vector Round floating-point to integer towards -Infinity", "full_desc": "Vector Round floating-point to integer towards -Infinity rounds a vector of floating-point values to integral floating-point values of the same size, using the Round towards -Infinity rounding mode. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.", "syntax": ["VRINTM{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTM{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VRINTM{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VRINTM{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if op<2> != op<0> then SEE \"Related encodings\";\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\n// Rounding encoded differently from other VCVT and VRINT instructions\nrounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        op1 = Elem[D[m+r],e,esize];\n        result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);\n        Elem[D[d+r],e,esize] = result;"}, {"mnemonic": "RSC, RSCS (register)", "short_desc": "Reverse Subtract with Carry (register)", "full_desc": "Reverse Subtract with Carry (register) subtracts a register value and the value of NOT (Carry flag) from an optionally-shifted register value, and writes the result to the destination register.", "syntax": ["RSC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; RSC, rotate right with extend", "RSC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; RSC, shift or rotate by value", "RSCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX\t; RSCS, rotate right with extend", "RSCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}\t; RSCS, shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the same as . Arm deprecates using the PC as the destination register, but if the PC is used:", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<shift>\n", "<amount>\nIs the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);\n    (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);\n    if d == 15 then\n        if setflags then\n            ALUExceptionReturn(result);\n        else\n            ALUWritePC(result);\n    else\n        R[d] = result;\n        if setflags then\n            PSTATE.<N,Z,C,V> = nzcv;"}, {"mnemonic": "VCVT (between half-precision and single-precision, Advanced SIMD)", "short_desc": "Vector Convert between half-precision and single-precision", "full_desc": "Vector Convert between half-precision and single-precision converts each element in a vector from single-precision to half-precision floating-point, or from half-precision to single-precision, and places the results in a second vector.", "syntax": ["VCVT{<c>}{<q>}.F32.F16 <Qd>, <Dm>\t; Half-precision to single-precision", "VCVT{<c>}{<q>}.F16.F32 <Dd>, <Qm>\t; Single-precision to half-precision", "VCVT{<c>}{<q>}.F32.F16 <Qd>, <Dm>\t; Half-precision to single-precision", "VCVT{<c>}{<q>}.F16.F32 <Dd>, <Qm>\t; Single-precision to half-precision"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2."], "decode": "if size != '01' then UNDEFINED;\nhalf_to_single = (op == '1');\nif half_to_single && Vd<0> == '1' then UNDEFINED;\nif !half_to_single && Vm<0> == '1' then UNDEFINED;\nesize = 16;  elements = 4;\nm = UInt(M:Vm);  d = UInt(D:Vd);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for e = 0 to elements-1\n        if half_to_single then\n            Elem[Q[d>>1],e,32] = FPConvert(Elem[Din[m],e,16], StandardFPSCRValue());\n        else\n            Elem[D[d],e,16] = FPConvert(Elem[Qin[m>>1],e,32], StandardFPSCRValue());"}, {"mnemonic": "TEQ (register)", "short_desc": "Test Equivalence (register)", "full_desc": "Test Equivalence (register) performs a bitwise exclusive OR operation on a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.", "syntax": ["TEQ{<c>}{<q>} <Rn>, <Rm>, RRX\t; Rotate right with extend", "TEQ{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}\t; Shift or rotate by value", "TEQ{<c>}{<q>} <Rn>, <Rm>, RRX\t; Rotate right with extend", "TEQ{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}\t; Shift or rotate by value"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nFor encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used, but this is deprecated.", "<Rn>\nFor encoding T1: is the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nFor encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used, but this is deprecated.", "<Rm>\nFor encoding T1: is the second general-purpose source register, encoded in the \"Rm\" field.", "<shift>\n", "<amount>\nFor encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.", "<amount>\nFor encoding T1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> = LSR or ASR), encoded in the \"imm3:imm2\" field as <amount> modulo 32."], "decode": "n = UInt(Rn);  m = UInt(Rm);\n(shift_t, shift_n) = DecodeImmShift(stype, imm5);", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);\n    result = R[n] EOR shifted;\n    PSTATE.N = result<31>;\n    PSTATE.Z = IsZeroBit(result);\n    PSTATE.C = carry;\n    // PSTATE.V unchanged"}, {"mnemonic": "LDRHT", "short_desc": "Load Register Halfword Unprivileged", "full_desc": "Load Register Halfword Unprivileged loads a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses see .", "syntax": ["LDRHT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}\t; A1", "LDRHT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>\t; A2", "LDRHT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rt>\nIs the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "+/-\n", "+/-\n", "<Rm>\nIs the general-purpose index register, encoded in the \"Rm\" field.", "+\nSpecifies the offset is added to the base register.", "<imm>\nFor encoding A1: is the 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 if omitted, and encoded in the \"imm4H:imm4L\" field.", "<imm>\nFor encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255, defaulting to 0 and encoded in the \"imm8\" field."], "decode": "t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');\nregister_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);\nif t == 15 || n == 15 || n == t then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode\n    EncodingSpecificOperations();\n    offset = if register_form then R[m] else imm32;\n    offset_addr = if add then (R[n] + offset) else (R[n] - offset);\n    address = if postindex then R[n] else offset_addr;\n    data = MemU_unpriv[address,2];\n    if postindex then R[n] = offset_addr;\n    R[t] = ZeroExtend(data, 32);"}, {"mnemonic": "VCLS", "short_desc": "Vector Count Leading Sign Bits", "full_desc": "Vector Count Leading Sign Bits counts the number of consecutive bits following the topmost bit, that are the same as the topmost bit, in each element in a vector, and places the results in a second vector. The count does not include the topmost bit itself.", "syntax": ["VCLS{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCLS{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector", "VCLS{<c>}{<q>}.<dt> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCLS{<c>}{<q>}.<dt> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            Elem[D[d+r],e,esize] = CountLeadingSignBits(Elem[D[m+r],e,esize])<esize-1:0>;"}, {"mnemonic": "VCVTA (Advanced SIMD)", "short_desc": "Vector Convert floating-point to integer with Round to Nearest with Ties to Away", "full_desc": "Vector Convert floating-point to integer with Round to Nearest with Ties to Away converts each element in a vector from floating-point to integer using the Round to Nearest with Ties to Away rounding mode, and places the results in a second vector.", "syntax": ["VCVTA{<q>}.<dt>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVTA{<q>}.<dt>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector", "VCVTA{<q>}.<dt>.<dt2> <Dd>, <Dm>\t; 64-bit SIMD vector", "VCVTA{<q>}.<dt>.<dt2> <Qd>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<q>\nSee .", "<dt>\n", "<dt2>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nif (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;\nrounding = FPDecodeRM(RM);  unsigned = (op == '1');\ncase size of\n    when '01' esize = 16; elements = 4;\n    when '10' esize = 32; elements = 2;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "EncodingSpecificOperations(); CheckAdvSIMDEnabled();\nbits(esize) result;\nfor r = 0 to regs-1\n    for e = 0 to elements-1\n        Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,\n                                         StandardFPSCRValue(), rounding);"}, {"mnemonic": "DMB", "short_desc": "Data Memory Barrier", "full_desc": "Data Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see .", "syntax": ["DMB{<c>}{<q>} {<option>}\t; A1", "DMB{<c>}{<q>} {<option>}\t; T1"], "symbols": ["<c>\nFor encoding A1: see . Must be  or omitted.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<option>\nSpecifies an optional limitation on the barrier operation. Values are:"], "decode": "// No additional decoding required", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    case option of\n        when '0001'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Reads;\n        when '0010'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Writes;\n        when '0011'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_All;\n        when '0101'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Reads;\n        when '0110'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Writes;\n        when '0111'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_All;\n        when '1001'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Reads;\n        when '1010'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Writes;\n        when '1011'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_All;\n        when '1101'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Reads;\n        when '1110'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Writes;\n        otherwise    domain = MBReqDomain_FullSystem;      types = MBReqTypes_All;\n\n    if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then\n        if HCR.BSU == '11' then\n            domain = MBReqDomain_FullSystem;\n        if HCR.BSU == '10' && domain != MBReqDomain_FullSystem then\n            domain = MBReqDomain_OuterShareable;\n        if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then\n            domain = MBReqDomain_InnerShareable;\n\n    DataMemoryBarrier(domain, types);"}, {"mnemonic": "VORN (register)", "short_desc": "Vector bitwise OR NOT (register)", "full_desc": "Vector bitwise OR NOT (register) performs a bitwise OR NOT operation between two registers, and places the result in the destination register.  The operand and result registers can be quadword or doubleword.  They must all be the same size.", "syntax": ["VORN{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VORN{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector", "VORN{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>\t; 64-bit SIMD vector", "VORN{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\nAn optional data type. It is ignored by assemblers, and does not affect the encoding.", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qn>\nIs the 128-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field as <Qn>*2.", "<Qm>\nIs the 128-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dn>\nIs the 64-bit name of the first SIMD&FP source register, encoded in the \"N:Vn\" field.", "<Dm>\nIs the 64-bit name of the second SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;\nd = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        D[d+r] = D[n+r] OR NOT(D[m+r]);"}, {"mnemonic": "DCPS2", "short_desc": "Debug Change PE State to EL2", "full_desc": "Debug Change PE State to EL2 allows the debugger to move the PE into EL2 from a lower Exception level.", "syntax": ["DCPS2\t; T1"], "symbols": [], "decode": "if !HaveEL(EL2) then UNDEFINED;", "operation": "if !Halted() || IsSecure() then UNDEFINED;\n\nif ELUsingAArch32(EL2) then\n    AArch32.WriteMode(M32_Hyp);\n    PSTATE.E = HSCTLR.EE;\n\n    ELR_hyp = bits(32) UNKNOWN;\n    HSR = bits(32) UNKNOWN;\n    SPSR_hyp = bits(32) UNKNOWN;\n\n    DLR = bits(32) UNKNOWN;\n    DSPSR = bits(32) UNKNOWN;\nelse                                        // Targeting EL2 using AArch64\n    AArch64.MaybeZeroRegisterUppers();\n    MaybeZeroSVEUppers(EL2);\n    PSTATE.nRW = '0';\n    PSTATE.SP = '1';\n    PSTATE.EL = EL2;\n    if HavePANExt() && SCTLR_EL2.SPAN == '0' && HCR_EL2.E2H == '1' && HCR_EL2.TGE == '1' then\n        PSTATE.PAN = '1';\n    if HaveUAOExt() then PSTATE.UAO = '0';\n\n    ELR_EL2 = bits(64) UNKNOWN;\n    ESR_EL2 = bits(32) UNKNOWN;\n    SPSR_EL2 = bits(32) UNKNOWN;\n\n    DLR_EL0 = bits(64) UNKNOWN;\n    DSPSR_EL0 = bits(32) UNKNOWN;\n\n    // SCTLR_EL2.IESB might be ignored in Debug state.\n    if HaveIESB() && SCTLR_EL2.IESB == '1' && !ConstrainUnpredictableBool(Unpredictable_IESBinDebug) then\n        SynchronizeErrors();\n\nUpdateEDSCRFields();                        // Update EDSCR PE state flags"}, {"mnemonic": "STM, STMIA, STMEA", "short_desc": "Store Multiple (Increment After, Empty Ascending)", "full_desc": "Store Multiple (Increment After, Empty Ascending) stores multiple registers to consecutive memory locations using an address from a base register. The consecutive memory locations start at this address, and the address just above the last of those locations can optionally be written back to the base register.", "syntax": ["STM{IA}{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "STMEA{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "STM{IA}{<c>}{<q>} <Rn>!, <registers>\t; T1", "STMEA{<c>}{<q>} <Rn>!, <registers>\t; T1", "STM{IA}{<c>}.W <Rn>{!}, <registers>\t; T2", "STMEA{<c>}.W <Rn>{!}, <registers>\t; T2", "STM{IA}{<c>}{<q>} <Rn>{!}, <registers>\t; T2", "STMEA{<c>}{<q>} <Rn>{!}, <registers>\t; T2"], "symbols": ["IA\nIs an optional suffix for the Increment After form.", "<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "<registers>\nFor encoding A1: is a list of one or more registers to be stored, separated by commas and surrounded by { and }.", "<registers>\nFor encoding T1: is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The registers in the list must be in the range R0-R7, encoded in the \"register_list\" field. If the base register is not the lowest-numbered register in the list, such an instruction stores an  value for the base register.", "<registers>\nFor encoding T2: is a list of one or more registers to be stored, separated by commas and surrounded by { and }."], "decode": "n = UInt(Rn);  registers = register_list;  wback = (W == '1');\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n];\n    for i = 0 to 14\n        if registers<i> == '1' then\n            if i == n && wback && i != LowestSetBit(registers) then\n                MemA[address,4] = bits(32) UNKNOWN;  // Only possible for encodings T1 and A1\n            else\n                MemA[address,4] = R[i];\n            address = address + 4;\n    if registers<15> == '1' then  // Only possible for encoding A1\n        MemA[address,4] = PCStoreValue();\n    if wback then R[n] = R[n] + 4*BitCount(registers);"}, {"mnemonic": "VCGE (immediate #0)", "short_desc": "Vector Compare Greater Than or Equal to Zero", "full_desc": "Vector Compare Greater Than or Equal to Zero takes each element in a vector, and compares it with zero. If it is greater than or equal to zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.", "syntax": ["VCGE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0\t; 64-bit SIMD vector", "VCGE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0\t; 128-bit SIMD vector"], "symbols": ["<c>\nFor encoding A1: see . This encoding must be unconditional.", "<c>\nFor encoding T1: see .", "<q>\nSee .", "<dt>\n", "<Qd>\nIs the 128-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field as <Qd>*2.", "<Qm>\nIs the 128-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field as <Qm>*2.", "<Dd>\nIs the 64-bit name of the SIMD&FP destination register, encoded in the \"D:Vd\" field.", "<Dm>\nIs the 64-bit name of the SIMD&FP source register, encoded in the \"M:Vm\" field."], "decode": "if size == '11' then UNDEFINED;\nif F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;\nif Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;\nfloating_point = (F == '1');\nesize = 8 << UInt(size);  elements = 64 DIV esize;\nd = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();  CheckAdvSIMDEnabled();\n    for r = 0 to regs-1\n        for e = 0 to elements-1\n            if floating_point then\n                bits(esize) zero = FPZero('0');\n                test_passed = FPCompareGE(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());\n            else\n                test_passed = (SInt(Elem[D[m+r],e,esize]) >= 0);\n            Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);"}, {"mnemonic": "STMDB, STMFD", "short_desc": "Store Multiple Decrement Before (Full Descending)", "full_desc": "Store Multiple Decrement Before (Full Descending) stores multiple registers to consecutive memory locations using an address from a base register. The consecutive memory locations end just below this address, and the address of the first of those locations can optionally be written back to the base register.", "syntax": ["STMDB{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "STMFD{<c>}{<q>} <Rn>{!}, <registers>\t; A1", "STMDB{<c>}{<q>} <Rn>{!}, <registers>\t; T1", "STMFD{<c>}{<q>} <Rn>{!}, <registers>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rn>\nIs the general-purpose base register, encoded in the \"Rn\" field.", "!\nThe address adjusted by the size of the data loaded is written back to the base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.", "<registers>\nFor encoding A1: is a list of one or more registers to be stored, separated by commas and surrounded by { and }.", "<registers>\nFor encoding T1: is a list of one or more registers to be stored, separated by commas and surrounded by { and }."], "decode": "n = UInt(Rn);  registers = register_list;  wback = (W == '1');\nif n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    address = R[n] - 4*BitCount(registers);\n    for i = 0 to 14\n        if registers<i> == '1' then\n            if i == n && wback && i != LowestSetBit(registers) then\n                MemA[address,4] = bits(32) UNKNOWN;  // Only possible for encoding A1\n            else\n                MemA[address,4] = R[i];\n            address = address + 4;\n    if registers<15> == '1' then  // Only possible for encoding A1\n        MemA[address,4] = PCStoreValue();\n    if wback then R[n] = R[n] - 4*BitCount(registers);"}, {"mnemonic": "UHSUB8", "short_desc": "Unsigned Halving Subtract 8", "full_desc": "Unsigned Halving Subtract 8 performs four unsigned 8-bit integer subtractions, halves the results, and writes the results to the destination register.", "syntax": ["UHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; A1", "UHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>\t; T1"], "symbols": ["<c>\nSee .", "<q>\nSee .", "<Rd>\nIs the general-purpose destination register, encoded in the \"Rd\" field.", "<Rn>\nIs the first general-purpose source register, encoded in the \"Rn\" field.", "<Rm>\nIs the second general-purpose source register, encoded in the \"Rm\" field."], "decode": "d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);\nif d == 15 || n == 15 || m == 15 then UNPREDICTABLE;", "operation": "if ConditionPassed() then\n    EncodingSpecificOperations();\n    diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);\n    diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);\n    diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);\n    diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);\n    R[d]<7:0>   = diff1<8:1>;\n    R[d]<15:8>  = diff2<8:1>;\n    R[d]<23:16> = diff3<8:1>;\n    R[d]<31:24> = diff4<8:1>;"}]