#!/usr/bin/env raku
use v6;
use lib '/Users/kleb/bethesda/work/repo/translator/raku';
use util;
use typemap;
use grammar;

#use Grammar::Tracer;

our grammar Translator does ParserRules {
    rule TOP {
        <.ws>
        [ 
            | <struct-member-declarations>
            | <abstract-function-declarations>
            | <pound-define>
            | <default-ctor>
            | <op-convert-function-header>
            | <constructor-definition-header>
            | <op-mul-function-header>
            | <op-xor-function-header>
            | <op-bitand-function-header>
            | <op-bitor-function-header>
            | <op-eq-function-header>
            | <op-lt-function-header>
            | <op-div-eq-function-header>
            | <class-constructor-declaration>
            | <function-declaration>
            | <hashing-function>
            | <op-add-function-header>
            | <op-add-eq-function-header>
            | <op-bitor-assign-function-header>
            | <op-bitand-assign-function-header>
            | <op-div-function-header>
            | <op-mul-eq-function-header>
            | <op-negate-function-header>
            | <op-sub-function-header>
            | <op-sub-eq-function-header>
            | <freestanding-template-function-header>
            | <op-index-function-header>
            | <op-ostream-function-header>
            | <static-constants>
            | <function-local-declarations>
            | <destructor>
            | <ctor-header>
            | <using-declarations>
            | <typedef-fn-ptr>
            | <constexpr-global-block>
        ]
    }
}

our sub get-hook($hookname) {

    #key matches grammar rules
    #will return one of these values
    my %dispatch = %(

        default-ctor                          => { use default;            &translate-default-ctor },
        hashing-function                      => { use hasher;             &translate-hasher },
        op-add-eq-function-header             => { use op_add;             &translate-op-add-eq },
        op-bitor-assign-function-header       => { use op_bitor;           &translate-op-bitor-assign },
        op-bitand-assign-function-header      => { use op_bitand;          &translate-op-bitand-assign },
        op-add-function-header                => { use op_add;             &translate-op-add },
        function-declaration                  => { use function;           &translate-function },
        constructor-definition-header         => { use constructor;        &translate-ctor },
        op-div-function-header                => { use op_div;             &translate-op-div },
        op-div-eq-function-header             => { use op_div_eq;          &translate-op-div-eq },
        op-eq-function-header                 => { use op_eq;              &translate-op-eq },
        op-lt-function-header                 => { use op_eq;              &translate-op-lt },
        op-index-function-header              => { use op_index;           &translate-op-index },
        op-xor-function-header                => { use op_xor;             &translate-op-xor },
        op-bitand-function-header             => { use op_bitand;          &translate-op-bitand },
        op-bitor-function-header              => { use op_bitor;           &translate-op-bitor },
        op-mul-function-header                => { use op_mul;             &translate-op-mul },
        op-mul-eq-function-header             => { use op_mul_eq;          &translate-op-mul-eq },
        op-negate-function-header             => { use op_negate;          &translate-op-negate },
        op-sub-function-header                => { use op_sub;             &translate-op-sub },
        op-sub-eq-function-header             => { use op_sub_eq;          &translate-op-sub-eq },
        freestanding-template-function-header => { use template;           &translate-freestanding-template-function },
        op-ostream-function-header            => { use ostream;            &translate-op-ostream },
        op-convert-function-header            => { use op_convert;         &translate-op-convert },
        static-constants                      => { use static_const;       &translate-static-const },
        function-local-declarations           => { use function-locals;    &translate-function-locals },
        struct-member-declarations            => { use struct_members;     &translate-struct-member-declarations },
        abstract-function-declarations        => { use abstract_functions; &translate-abstract-function-declarations },
        destructor                            => { use destructor;         &translate-destructor },
        ctor-header                           => { use ctor_header;        &translate-ctor-header },
        using-declarations                    => { use using_declarations; &translate-using-declarations },
        typedef-fn-ptr                        => { use typedef_fn_ptr;     &translate-typedef-fn-ptr },
        pound-define                          => { use pound_define;       &translate-pound-define },
        constexpr-global-block                => { use constexpr_globals;       &translate-constexpr-global-block },
    );

    %dispatch{$hookname}()
}

sub MAIN(:$chop = False, :$class = Nil, :$de-semicolon = False) { 

    #this makes it so we don't have to recompile 
    #every time we want to change the typemap
    my %*typemap = %typemap;

    #add whitelisted types to typemap
    #a whitelisted type is the same in Rust as it is in c++
    for "/Users/kleb/bethesda/work/repo/translator/raku/whitelist.txt".IO.slurp.lines {
        %*typemap{$_} = $_;
    }

    for "/Users/kleb/bethesda/work/repo/translator/raku/text-typemap.txt".IO.slurp.lines {
        my @tokens = $_.split(" ");
        my $head = @tokens[0];
        my $tail = @tokens[1..*].join(" ");
        %*typemap{$head} = $tail;
    }

    my $in = $*IN.slurp.chomp;

    if $de-semicolon {
        $in = $in.subst(rule { ';' $ }, '{ }');
    }

    my ($head, $body) = get_parts($in, $chop);

    my $match     = Translator.parse($head);

    my $hookname  = $match.keys[0].Str;
    my &hook      = &get-hook($hookname);

    my $submatch = $match{$hookname};

    if $submatch {

        say &hook($submatch, $body, $class);

    } else {

        say "could not parse submatch";
    }
}

